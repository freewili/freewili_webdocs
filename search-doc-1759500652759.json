{"searchDocs":[{"title":"Project Story: Safe X Guardian","type":0,"sectionRef":"#","url":"/blog/safe-x-guardian/","content":"","keywords":"","version":null},{"title":"Built With‚Äã","type":1,"pageTitle":"Project Story: Safe X Guardian","url":"/blog/safe-x-guardian/#built-with","content":" c freewili python raspberry-pi whadda  ","version":null,"tagName":"h3"},{"title":"Try it out‚Äã","type":1,"pageTitle":"Project Story: Safe X Guardian","url":"/blog/safe-x-guardian/#try-it-out","content":"  GitHub Repo  Source - https://devpost.com/software/safe-x-guardian ","version":null,"tagName":"h3"},{"title":"VisionCane - Empowering independence through intelligent navigation","type":0,"sectionRef":"#","url":"/blog/visioncane/","content":"","keywords":"","version":null},{"title":"üåü Inspiration‚Äã","type":1,"pageTitle":"VisionCane - Empowering independence through intelligent navigation","url":"/blog/visioncane/#-inspiration","content":" I was inspired by the daily challenges faced by visually impaired individuals in navigating unfamiliar environments and wanted to create an affordable, accessible solution that could enhance their independence and safety using modern technology.    ","version":null,"tagName":"h2"},{"title":"üëÄ What it does‚Äã","type":1,"pageTitle":"VisionCane - Empowering independence through intelligent navigation","url":"/blog/visioncane/#-what-it-does","content":" VisionCane uses YOLO object detection to identify obstacles and landmarks, HC-SR04 ultrasonic sensors for precise distance measurement, and FREE-WILi's LIS3DH accelerometer to detect cane movement and orientation. The integrated speaker provides real-time audio feedback with spatial cues to help users navigate safely through their surroundings.    ","version":null,"tagName":"h2"},{"title":"üõ†Ô∏è How I built it‚Äã","type":1,"pageTitle":"VisionCane - Empowering independence through intelligent navigation","url":"/blog/visioncane/#Ô∏è-how-i-built-it","content":" I'm building a modular architecture with separate components: CameraModule.py for camera initialization, objectDetection.py for YOLO-based obstacle detection, ultraSonic.py for distance sensing, stateMachine.py for decision logic, and main.py as the central controller. The system integrates with FREE-WILi's API to access the LIS3DH accelerometer for motion detection and the digital speaker for audio feedback, processing real-time sensor fusion to generate intelligent navigation assistance.    ","version":null,"tagName":"h2"},{"title":"‚öîÔ∏è Challenges I ran into‚Äã","type":1,"pageTitle":"VisionCane - Empowering independence through intelligent navigation","url":"/blog/visioncane/#Ô∏è-challenges-i-ran-into","content":" Integrating real-time computer vision processing with ultrasonic sensor data and FREE-WILi accelerometer readings while maintaining low latency, ensuring reliable object detection across different lighting conditions, synchronizing multiple sensor inputs through the FREE-WILi API, and creating an intuitive audio feedback system that provides useful spatial information without overwhelming users.    ","version":null,"tagName":"h2"},{"title":"üèÜ Accomplishments I‚Äôm proud of‚Äã","type":1,"pageTitle":"VisionCane - Empowering independence through intelligent navigation","url":"/blog/visioncane/#-accomplishments-im-proud-of","content":" Successfully setting up the modular architecture with separate components for camera handling, object detection, ultrasonic sensing, and state management. Implementing integration with FREE-WILi's LIS3DH accelerometer for motion detection and speaker for audio feedback, creating a clean separation of concerns that allows for easy testing and debugging of individual components.    ","version":null,"tagName":"h2"},{"title":"üìö What I learned‚Äã","type":1,"pageTitle":"VisionCane - Empowering independence through intelligent navigation","url":"/blog/visioncane/#-what-i-learned","content":" The importance of modular design in complex sensor fusion projects, how to integrate FREE-WILi's API for accelerometer data streaming and speaker control, structuring a state machine for real-time decision making with multiple sensor inputs, the challenges of synchronizing computer vision, ultrasonic, and accelerometer data, and the critical need for user-centered design when creating assistive technology that must be reliable and intuitive.    ","version":null,"tagName":"h2"},{"title":"üöÄ What‚Äôs next for VisionCane‚Äã","type":1,"pageTitle":"VisionCane - Empowering independence through intelligent navigation","url":"/blog/visioncane/#-whats-next-for-visioncane","content":" Completing the implementation of each module, integrating the YOLOv8 model for object detection, implementing FREE-WILi accelerometer event handling for motion-based state changes, adding spatial audio feedback generation through the FREE-WILi speaker, implementing the state machine logic for navigation decisions, and testing the complete system with real-world scenarios to refine the user experience and optimize sensor fusion algorithms.    ","version":null,"tagName":"h2"},{"title":"üß© Built With‚Äã","type":1,"pageTitle":"VisionCane - Empowering independence through intelligent navigation","url":"/blog/visioncane/#-built-with","content":" embedded freewili python raspberry-pi    ","version":null,"tagName":"h2"},{"title":"Try it out‚Äã","type":1,"pageTitle":"VisionCane - Empowering independence through intelligent navigation","url":"/blog/visioncane/#try-it-out","content":"  GitHub Repo  Source - https://devpost.com/software/visioncane/ ","version":null,"tagName":"h3"},{"title":"WiLi-Party LED Minigames","type":0,"sectionRef":"#","url":"/blog/wiLi-party/","content":"","keywords":"","version":null},{"title":"Inspiration‚Äã","type":1,"pageTitle":"WiLi-Party LED Minigames","url":"/blog/wiLi-party/#inspiration","content":" We love competitive games like Mario Party and the cuteness of small devices like Tamagotchi. We wanted a project that combines the two, which is why the free wili seemed like a great system to use.  ","version":null,"tagName":"h2"},{"title":"What it does‚Äã","type":1,"pageTitle":"WiLi-Party LED Minigames","url":"/blog/wiLi-party/#what-it-does","content":" Gives users the ability to play four 1v1 games  Mashing game - Who can rack up the highest number of button presses before time runs out?Memory game - A pattern sequence, up to 3 levels of increasing difficulty. Test your memory!Counting game - Keep track of your color light and how many times it flashes. Don't blink.Reaction game - Who can react faster? Click the color that shows up as quick as you can.  The lights at the end of a game blink red if P1 has won and green if P2 (yellow if tie).  ","version":null,"tagName":"h2"},{"title":"How we built it‚Äã","type":1,"pageTitle":"WiLi-Party LED Minigames","url":"/blog/wiLi-party/#how-we-built-it","content":" We used two Python libraries. The FreeWheel API to communicate with the FREE-WILi and flash our code, and the pygame library to receive and read controller input. We also have a given header file for C++ definitions of useful functions that allow us to configure the FREE-WILi board, such as LED toggles and Display images.  ","version":null,"tagName":"h2"},{"title":"Challenges we ran into‚Äã","type":1,"pageTitle":"WiLi-Party LED Minigames","url":"/blog/wiLi-party/#challenges-we-ran-into","content":" The FREE-WILi had some hardware limitations that prevented us from fully fledging out our implementation as was planned. Primarily, its I/O capabilities are limited, and cannot read controller input through USB-C as a general purpose computer can, so we had to keep the system wired to the computer during play. We also ran into space issues in uploading images to the display, so the UI is not as in depth as we would have liked.  ","version":null,"tagName":"h2"},{"title":"Accomplishments that we're proud of‚Äã","type":1,"pageTitle":"WiLi-Party LED Minigames","url":"/blog/wiLi-party/#accomplishments-that-were-proud-of","content":" For having found out about this device only 24 hours before submission, we are very proud of the fact that we were able to flash the device with our software, turn on LEDs, upload images, and have it function properly with our controller input, despite the limitations we encountered.  ","version":null,"tagName":"h2"},{"title":"What we learned‚Äã","type":1,"pageTitle":"WiLi-Party LED Minigames","url":"/blog/wiLi-party/#what-we-learned","content":" We learned a lot about how FREE-WILi works, how to write to it, and its functionalities. We also learned how to use pygame to process user inputs from a controller, to parse and control them correctly, and also how to manage multiple controllers.  ","version":null,"tagName":"h2"},{"title":"What's next for Wili-Party‚Äã","type":1,"pageTitle":"WiLi-Party LED Minigames","url":"/blog/wiLi-party/#whats-next-for-wili-party","content":" Ideally, we would love to make the controller input work without running it through a computer for processing. We want the games to be able to be fully run on the FREE-WILi itself, with just two controllers as support. We would also like to make the communication wireless, so we are not cluttered with USB-C cables while playing.  ","version":null,"tagName":"h2"},{"title":"Built With‚Äã","type":1,"pageTitle":"WiLi-Party LED Minigames","url":"/blog/wiLi-party/#built-with","content":" c++ freewili pygame python time  Source - https://devpost.com/software/wili-party ","version":null,"tagName":"h3"},{"title":"Wili pass","type":0,"sectionRef":"#","url":"/blog/wili-pass/","content":"","keywords":"","version":null},{"title":"üåü Inspiration‚Äã","type":1,"pageTitle":"Wili pass","url":"/blog/wili-pass/#-inspiration","content":" We were inspired by the nostalgic charm of Nintendo DS StreetPass, where chance encounters led to exciting virtual interactions. We wanted to bring that sense of discovery and connection to the hacker community, fostering real-world interactions in a digital age.    ","version":null,"tagName":"h2"},{"title":"üéµ What it does‚Äã","type":1,"pageTitle":"Wili pass","url":"/blog/wili-pass/#-what-it-does","content":" Wili-Pass allows hackers to exchange digital 'passports' when their FREE-WILi devices come within range. These passports contain user-defined profiles, including stats, personalized images, and audio messages. It's a way to instantly learn about and connect with fellow hackers at events and gatherings.    ","version":null,"tagName":"h2"},{"title":"üõ†Ô∏è How we built it‚Äã","type":1,"pageTitle":"Wili pass","url":"/blog/wili-pass/#Ô∏è-how-we-built-it","content":" We used the FREE-WILi dev board's antenna capabilities to detect near by hackers. Once detected, the unique hacker signature is used to query their profile. The passing hacker profile is then displayed for each hacker to view and connect with one another.    ","version":null,"tagName":"h2"},{"title":"üöß Challenges we ran into‚Äã","type":1,"pageTitle":"Wili pass","url":"/blog/wili-pass/#-challenges-we-ran-into","content":" Communicating with the FREE-WILi over antenna proved to be very challenging. Getting the environment and tool chain setup, was also harder than expected.    ","version":null,"tagName":"h2"},{"title":"üèÜ Accomplishments that we're proud of‚Äã","type":1,"pageTitle":"Wili pass","url":"/blog/wili-pass/#-accomplishments-that-were-proud-of","content":" Communicating between boards.    ","version":null,"tagName":"h2"},{"title":"üìö What we learned‚Äã","type":1,"pageTitle":"Wili pass","url":"/blog/wili-pass/#-what-we-learned","content":" Planning and re-evaluating feasibility of ideas.    ","version":null,"tagName":"h2"},{"title":"üöÄ What's next for Wili pass‚Äã","type":1,"pageTitle":"Wili pass","url":"/blog/wili-pass/#-whats-next-for-wili-pass","content":" Wide spread hackathon use!    ","version":null,"tagName":"h2"},{"title":"Built With‚Äã","type":1,"pageTitle":"Wili pass","url":"/blog/wili-pass/#built-with","content":" c++ freewili  ","version":null,"tagName":"h3"},{"title":"Try it out‚Äã","type":1,"pageTitle":"Wili pass","url":"/blog/wili-pass/#try-it-out","content":"  GitHub Repo  Source - https://devpost.com/software/wili-pass ","version":null,"tagName":"h3"},{"title":"Buy Now from Our\n Distributor Network","type":0,"sectionRef":"#","url":"/buy-now/","content":"Buy Now from Our Distributor Network Where to Buy‚Äã Buy Now From Intrepid Control Systems, Inc. Buy Now From Jameco","keywords":"FREE-WILi buy FREE-WILi FREE-WILi distributor purchase FREE-WILi","version":"Next"},{"title":"WiLi Watch ‚Äì Voice-Activated Wearable for Smart Home Control","type":0,"sectionRef":"#","url":"/blog/wiLi-watch/","content":"","keywords":"","version":null},{"title":"Inspiration‚Äã","type":1,"pageTitle":"WiLi Watch ‚Äì Voice-Activated Wearable for Smart Home Control","url":"/blog/wiLi-watch/#inspiration","content":" In a world increasingly reliant on technology, the ability to interact with our surroundings effortlessly is essential, especially for individuals with mobility challenges. Enter the WiLi Watch, a wearable wristband powered by FREE-WILi and Groq aimed to empower users with independence.  The journey began with a vision: to create a device that could simplify and enhance daily living for individuals with movement impairments. Our team recognized the need for an intuitive interface that would allow users to control their smart home environment without the barriers typically posed by traditional devices. By harnessing the capabilities of the watch's built-in infrared (IR) transmitters, we sought to bridge the gap between technology and accessibility.  ","version":null,"tagName":"h2"},{"title":"What it does‚Äã","type":1,"pageTitle":"WiLi Watch ‚Äì Voice-Activated Wearable for Smart Home Control","url":"/blog/wiLi-watch/#what-it-does","content":" The user wears an embedded wristband device that can be used to control and interact with their environment. Here is the specific tasks that can be performed wirelessly from your wrist:  Turn on and off lightsLock and unlock your doorDisplay live steamed camera footage of your doorstepBring up your GCal or the weather to be displayed These tasks can either be initiated through buttons on the wristband, or from asking out loud for certain actions to be done. We use AI to predict your needs as well based on what you say. For example, if you mention &quot;Oh did I forget to lock the door?&quot; the door will lock automatically, and saying &quot;will I need an umbrella later?&quot; will cause the weather report to go on display. Additionally, a speaker announces to you every action that is done for peace of mind. Finally, one can inquire about who is at their door and the hub will describe to you your visitor.  ","version":null,"tagName":"h2"},{"title":"How we built it‚Äã","type":1,"pageTitle":"WiLi Watch ‚Äì Voice-Activated Wearable for Smart Home Control","url":"/blog/wiLi-watch/#how-we-built-it","content":" This project relies on the wireless IR communication between a FREE-WILi device and a smart home &quot;hub&quot; consisting of an Orange Pi 5 and Arduino Nano that control other peripherals such as a camera, door &quot;locking&quot; system, IR receiver module, speaker, microphone, and external monitor. The frameworks we used for development are Groq for easy LLM use (Whisper for speech to text and Llama for natural language reasoning) and Cartesia for speech-text interfacing, all developed on a python virtual environment. The project is also modular to be used with Intel's IDC if private LLM generation is desired (we setup a flask server serving llama.cpp inferencing on a compute instance but ran out of credits)  ","version":null,"tagName":"h2"},{"title":"Challenges we ran into‚Äã","type":1,"pageTitle":"WiLi Watch ‚Äì Voice-Activated Wearable for Smart Home Control","url":"/blog/wiLi-watch/#challenges-we-ran-into","content":" Using GPIO on the Orange Pi; we had to pivot after hours to integrate another microcontroller with a functional GPIO interface for motor control and IF receivingNetworking compatibility; we found out later than we'd like that the Free WiLi device which we centered our project around does not have capabilities to connect to the internet / Bluetooth so we switched to IF communicationPython development on Linux; Python virtual environments are not for the weak of heart  ","version":null,"tagName":"h2"},{"title":"Accomplishments that we're proud of‚Äã","type":1,"pageTitle":"WiLi Watch ‚Äì Voice-Activated Wearable for Smart Home Control","url":"/blog/wiLi-watch/#accomplishments-that-were-proud-of","content":" Fully functional prototype built from the ground up in 24 hours!!Door locking system on a physical prototype + doorstep cameraOvercoming Free WiLi debugging hurdles in the middle of the nightKept persistence even through sleep deprivation  ","version":null,"tagName":"h2"},{"title":"What we learned‚Äã","type":1,"pageTitle":"WiLi Watch ‚Äì Voice-Activated Wearable for Smart Home Control","url":"/blog/wiLi-watch/#what-we-learned","content":" Hardware hacking is challenging, but super fun!Cable management can and will stress you outImplementing APIs in a larger programWireless communication (IR and RF)Ideation is so important  ","version":null,"tagName":"h2"},{"title":"What's next for The WiLi Watch‚Äã","type":1,"pageTitle":"WiLi Watch ‚Äì Voice-Activated Wearable for Smart Home Control","url":"/blog/wiLi-watch/#whats-next-for-the-wili-watch","content":" Increase in functionalities available on the watch as well as real world implementation (metal instead of cardboard). A few functionalities that we came up with that could be expanded on in further development are as follows:  Autonomous robotic car assistant that can retrieve itemsInteract with kitchen appliances (turn on/off stove)Emergency response / alarm systemTemperature control  ","version":null,"tagName":"h2"},{"title":"Built With‚Äã","type":1,"pageTitle":"WiLi Watch ‚Äì Voice-Activated Wearable for Smart Home Control","url":"/blog/wiLi-watch/#built-with","content":" arduino-nano cartesia freewili groq llama orange-pi python whisper  ","version":null,"tagName":"h2"},{"title":"Try it out‚Äã","type":1,"pageTitle":"WiLi Watch ‚Äì Voice-Activated Wearable for Smart Home Control","url":"/blog/wiLi-watch/#try-it-out","content":"  GitHub Repo  Source - https://devpost.com/software/wili-watch ","version":null,"tagName":"h3"},{"title":"thereMINI: Creating Music with Hand Gestures Using FREE-WILi for a Touch-Free Sound Experience","type":0,"sectionRef":"#","url":"/blog/theremini/","content":"","keywords":"","version":null},{"title":"üé∂ thereMINI: A Wearable Theremin üé∂‚Äã","type":1,"pageTitle":"thereMINI: Creating Music with Hand Gestures Using FREE-WILi for a Touch-Free Sound Experience","url":"/blog/theremini/#-theremini-a-wearable-theremin-","content":" Turning motion into music with FREE-WILi    ","version":null,"tagName":"h2"},{"title":"üåü Inspiration‚Äã","type":1,"pageTitle":"thereMINI: Creating Music with Hand Gestures Using FREE-WILi for a Touch-Free Sound Experience","url":"/blog/theremini/#-inspiration","content":" We designed this as an accessibility device for one-handed music creation but soon saw its broader potential. Inspired by conducting, we mapped hand motion to notes and volume, making music creation more intuitive and inclusive. We continue to design this as a accessible device, but it is for everyone!    ","version":null,"tagName":"h2"},{"title":"üéµ What It Does‚Äã","type":1,"pageTitle":"thereMINI: Creating Music with Hand Gestures Using FREE-WILi for a Touch-Free Sound Experience","url":"/blog/theremini/#-what-it-does","content":" Using the FREE-WILi we were able to extract the accelerometer data as serial data. Converting said data to MIDI data (a music data type) we were able to use music software, like Ableton to translate it into virtual instrument playing. Moving your hand down increases volume and putting it down increases it. Moving your hand left or right changes notes, specifically a scale of 8 notes. Combining all that we can emulate a full virtual keyboard with just the movement of your hand!    ","version":null,"tagName":"h2"},{"title":"üõ†Ô∏è How We Built It‚Äã","type":1,"pageTitle":"thereMINI: Creating Music with Hand Gestures Using FREE-WILi for a Touch-Free Sound Experience","url":"/blog/theremini/#Ô∏è-how-we-built-it","content":" Hardware: FREE-WILi device is a wearable microprocessor, outfitted with many sensors and capabilities, the one we focused on is the accelerometer. We used this mainly to translate xyz coordinates into angles, and then MIDI values for the notes and volume. This data is sent through USB serial data to be read by the software.Software: We used C++, and C to embed functionality for the FREE-WILi and python to clean and extract the data from it. loopMIDI is a software that creates a virtual MIDI controller that reads from our script, and feeds it to DAWs.Implementation: The horizontal rotation is used for the notes on a rotation of -90 -&gt; 90 degrees, and the vertical rotation is used for lowering and increasing the pitch on -30 -&gt; 30 degrees.    ","version":null,"tagName":"h2"},{"title":"üöß Challenges We Ran Into‚Äã","type":1,"pageTitle":"thereMINI: Creating Music with Hand Gestures Using FREE-WILi for a Touch-Free Sound Experience","url":"/blog/theremini/#-challenges-we-ran-into","content":" We addressed USB port access challenges between WSL and Windows, ensuring proper connectivity. Translating accelerometer data into MIDI required refining sensitivity and applying filtering to improve accuracy. By optimizing data formatting and transmission, we facilitated seamless MIDI transfer. Through continuous troubleshooting and iterative testing, we achieved smooth integration between hardware and software.    ","version":null,"tagName":"h2"},{"title":"üèÜ Accomplishments We're Proud Of‚Äã","type":1,"pageTitle":"thereMINI: Creating Music with Hand Gestures Using FREE-WILi for a Touch-Free Sound Experience","url":"/blog/theremini/#-accomplishments-were-proud-of","content":" Our project focused on turning complex tasks into key milestones. A major achievement was enabling MIDI data transfer from FREE-WILi to a computer, converting user movements into precise musical instructions like pitch and velocity. Our greatest achievement was the design of the notes and pitch to hand movements, and what was the most ergonomic and accessible way we would implement it.    ","version":null,"tagName":"h2"},{"title":"üìö What We Learned‚Äã","type":1,"pageTitle":"thereMINI: Creating Music with Hand Gestures Using FREE-WILi for a Touch-Free Sound Experience","url":"/blog/theremini/#-what-we-learned","content":" We learned how to process real-time sensor data into MIDI signals, ensuring seamless hardware-software integration. Designing for accessibility taught us the importance of intuitive and ergonomic control. Optimizing MIDI implementation required refining pitch, velocity, and minimizing latency. Through iterative problem-solving, we debugged formatting errors and fine-tuned movement sensitivity.    ","version":null,"tagName":"h2"},{"title":"üöÄ What's Next for thereMINI‚Äã","type":1,"pageTitle":"thereMINI: Creating Music with Hand Gestures Using FREE-WILi for a Touch-Free Sound Experience","url":"/blog/theremini/#-whats-next-for-theremini","content":" We plan to enhance thereMINI with scale mode, chord mode, and octave control, mapped to buttons on the FREE-WILi for seamless switching. A GUI will provide visual feedback and customization options. Beyond development, thereMINI has potential as an accessible instrument, an innovative tool for musicians, and an educational device for learning music through motion.    ","version":null,"tagName":"h2"},{"title":"Built With‚Äã","type":1,"pageTitle":"thereMINI: Creating Music with Hand Gestures Using FREE-WILi for a Touch-Free Sound Experience","url":"/blog/theremini/#built-with","content":" ableton accelerometer c c++ freewili loopmidi pyserial python rtmidi  ","version":null,"tagName":"h3"},{"title":"Try it out‚Äã","type":1,"pageTitle":"thereMINI: Creating Music with Hand Gestures Using FREE-WILi for a Touch-Free Sound Experience","url":"/blog/theremini/#try-it-out","content":"  GitHub Repo  Source - https://devpost.com/software/theremini ","version":null,"tagName":"h3"},{"title":"DEFCON Badges","type":0,"sectionRef":"#","url":"/defcon-badges/","content":"","keywords":"DEFCON badges DEFCON 32 badge DEFCON 33 badge ICS Village DEFCON 33 badge DEFCON badge setup DEFCON badge guide DEFCON badge features DEFCON hardware badge DEFCON badge instructions DEFCON special edition badges","version":"Next"},{"title":"Available Badges‚Äã","type":1,"pageTitle":"DEFCON Badges","url":"/defcon-badges/#available-badges","content":" ","version":"Next","tagName":"h2"},{"title":"- ICS Village Badge ‚Äì DEFCON 33‚Äã","type":1,"pageTitle":"DEFCON Badges","url":"/defcon-badges/#--ics-village-badge--defcon-33","content":" Explore the ICS Village badge from DEFCON 33, including hardware details, setup instructions, and challenges.  ","version":"Next","tagName":"h3"},{"title":"- DEFCON 32 Badge Edition‚Äã","type":1,"pageTitle":"DEFCON Badges","url":"/defcon-badges/#--defcon-32-badge-edition","content":" Learn more about the DEFCON 32 badge, its unique features, and how to get started.    ‚ú® Use the links above to dive into each badge edition and get the most out of your DEFCON badge experience! ","version":"Next","tagName":"h3"},{"title":"Extending with Orcas","type":0,"sectionRef":"#","url":"/extending-with-orcas/","content":"","keywords":"FREE-WILi Orca modules Maestro Jambu extension connector custom modules serial LED control debugger board","version":"Next"},{"title":"Custom Orca Modules‚Äã","type":1,"pageTitle":"Extending with Orcas","url":"/extending-with-orcas/#custom-orca-modules","content":" To create your own, example projects are provided. ","version":"Next","tagName":"h2"},{"title":"Jambu Serial LED Control Orca","type":0,"sectionRef":"#","url":"/extending-with-orcas/jambu-orca/","content":"","keywords":"Jambu LED Control Orca 8-channel LED driver RGB LED controller I2C LED driver Qwiic LED module LED breakout board LED strip controller serial LED control dynamic lighting module 5V LED driver","version":"Next"},{"title":"Features‚Äã","type":1,"pageTitle":"Jambu Serial LED Control Orca","url":"/extending-with-orcas/jambu-orca/#features","content":" 8-channel LED Driver BreakoutControl 8 LED Strips5V Barrel Jack PowerSuitable for common anode Serial RGB LED strips, LEDs and Incandescent bulbsTwo-Wire I2C-Compatible Control InterfacePrototyping connectors for I2C (QWIIC) ","version":"Next","tagName":"h3"},{"title":"Bottlenose WiFi Orca","type":0,"sectionRef":"#","url":"/extending-with-orcas/bottlenose-wifi-orca/","content":"","keywords":"Bottlenose WiFi Orca ESP32-C6 development board IoT dev board WiFi Bluetooth board ESP32 USB-C Qwiic connector FreeRTOS low power IoT board ESP32 prototyping embedded systems","version":"Next"},{"title":"Features‚Äã","type":1,"pageTitle":"Bottlenose WiFi Orca","url":"/extending-with-orcas/bottlenose-wifi-orca/#features","content":" 2.4GHz Dual Mode WiFi + Bluetooth Development Board (ESP32-C6)Support LWIP protocol, FreeRTOSSupport Three Modes: AP, STA, and AP+STAUltra-Low power consumptionESP32 is a safe, reliable, and scalable to a variety of applicationsUSB Type C for Debug and Host ModeI2C ConnectPrototyping connectors for I2C (QWIIC)LEDs which display IO statusStandard ESP32 BOOT &amp; RESET Buttons for easy debugging / Programming ","version":"Next","tagName":"h3"},{"title":"Bottlenose Hardware Hookup Guide","type":0,"sectionRef":"#","url":"/extending-with-orcas/bottlenose-wifi-orca/bottlenose-hardware-hookup/","content":"","keywords":"Bottlenose hardware hookup ESP32-C6 connections WiFi setup USB-C FREE-WILi Orca connection hardware setup guide","version":"Next"},{"title":"Required Components‚Äã","type":1,"pageTitle":"Bottlenose Hardware Hookup Guide","url":"/extending-with-orcas/bottlenose-wifi-orca/bottlenose-hardware-hookup/#required-components","content":" 1 x Bottlenose WiFi Orca (ESP32-C6 board)1 x USB-C cable for programming/power1 x FREE-WILi device with Orca connector  ","version":"Next","tagName":"h2"},{"title":"Physical Connections‚Äã","type":1,"pageTitle":"Bottlenose Hardware Hookup Guide","url":"/extending-with-orcas/bottlenose-wifi-orca/bottlenose-hardware-hookup/#physical-connections","content":" ","version":"Next","tagName":"h2"},{"title":"Connecting to FREE-WILi‚Äã","type":1,"pageTitle":"Bottlenose Hardware Hookup Guide","url":"/extending-with-orcas/bottlenose-wifi-orca/bottlenose-hardware-hookup/#connecting-to-free-wili","content":" This guide covers the physical setup and connections for the Bottlenose WiFi Orca module.  Power down your FREE-WILi device before making connectionsAlign the Orca connector on the Bottlenose module with the Orca port on your FREE-WILi deviceGently press the modules together until the connectors are fully seatedVerify alignment by checking that the boards are parallel and the connector is fully engaged  warning Connection Precautions- 1 x Bottlenose WiFi Orca (ESP32-C6 board)- 1 x Bottlenose WiFi Orca (ESP32-C6 board) Always power down both devices before connecting or disconnecting Orca modules to prevent damage to the electronics.  ","version":"Next","tagName":"h3"},{"title":"Power Supply Options‚Äã","type":1,"pageTitle":"Bottlenose Hardware Hookup Guide","url":"/extending-with-orcas/bottlenose-wifi-orca/bottlenose-hardware-hookup/#power-supply-options","content":" The Bottlenose WiFi Orca can be powered in two ways:  Option 1: Power via FREE-WILi (Recommended)‚Äã  Power is supplied through the Orca connectorNo additional power connections requiredMost convenient for portable applications  Option 2: USB-C Power + Programming‚Äã  Connect USB-C cable to Bottlenose's USB portProvides power and enables programming/debuggingRequired for firmware development and debugging.Can be used simultaneously with Orca connector power  ","version":"Next","tagName":"h3"},{"title":"Communication between ESP32-C6 and FREE-WILi‚Äã","type":1,"pageTitle":"Bottlenose Hardware Hookup Guide","url":"/extending-with-orcas/bottlenose-wifi-orca/bottlenose-hardware-hookup/#communication-between-esp32-c6-and-free-wili","content":" The Bottlenose WiFi Orca communicates with FREE-WILi through the Orca connector interface using UART communication.  UART Pinout‚Äã  ESP32-C6 Pin\tFREE-WILi Pin\tFunctionESP_5V\t5V OUT\tPower Supply (5V) GPIO16\tUART1_TX_Out\tTransmit Data (FREE-WILi ‚Üí ESP32) GPIO17\tUART1_RX_IN\tReceive Data (ESP32 ‚Üí FREE-WILi) GPIO4\tUART1_CTS_IN\tClear to Send (Hardware Flow Control) GPIO5\tUART1_RTS_OUT\tRequest to Send (Hardware Flow Control) GND\tGND\tGround Reference  Both device's UART is configured with the following parameters:  3 Mbps Baudrate - Optimized for WiFi command and data transferCTS and RTS Controls Enabled - Hardware flow control for reliable transmission8 Data Bits - Standard data frame sizeThe Bottlenose WiFi Orca can be powered by the 20-pin orca connector, the USB C connector does not supply power to the board.1 Stop Bit - Standard frame terminationNo Parity - Error detection handled at higher protocol levels  ","version":"Next","tagName":"h3"},{"title":"GPIO and Expansion## MicroSD Card Installation‚Äã","type":1,"pageTitle":"Bottlenose Hardware Hookup Guide","url":"/extending-with-orcas/bottlenose-wifi-orca/bottlenose-hardware-hookup/#gpio-and-expansion-microsd-card-installation","content":" Hardware Flow Control Benefits CTS (Clear to Send) and RTS (Request to Send) hardware flow control ensures reliable communication for network data, terminal bridging, and configuration commands between FREE-WILi and Bottlenose.  ","version":"Next","tagName":"h2"},{"title":"Communication between ESP32-P4-EYE and FREE-WILi‚Äã","type":1,"pageTitle":"Bottlenose Hardware Hookup Guide","url":"/extending-with-orcas/bottlenose-wifi-orca/bottlenose-hardware-hookup/#communication-between-esp32-p4-eye-and-free-wili","content":" UART parameters on FREE-WILi Qwiic Connector The FREE-WIL-EYE Orca module Adapter routes UART data and hardware handshake lines between ESP32-P4-EYE and FREE-WILi.‚Äã FREE-WILi will automatically set the required UART parameters if you enable Bottlenose Communication in the Orca Setup Setting. We will be going over that later.  The Bottlenose includes a Qwiic connector for easy I2C device connections: ::: ","version":"Next","tagName":"h3"},{"title":"ü§ñ ICS Village Badge for DEFCON 33 with AI Power","type":0,"sectionRef":"#","url":"/defcon-badges/icsvillage-badge-defcon33/","content":"","keywords":"ICS Village Badge DEFCON 33 badge AI gas sensor ESP32-C6 WiFi RP2350 microcontroller WASM scripting ICS security hardware FREE-WILi Zig Rust CircuitPython MicroPython I2C SAO expansion real-time clock GUI badge interface","version":"Next"},{"title":"Introduction and Overview‚Äã","type":1,"pageTitle":"ü§ñ ICS Village Badge for DEFCON 33 with AI Power","url":"/defcon-badges/icsvillage-badge-defcon33/#introduction-and-overview","content":" Thank you for purchasing a FREE-WILi ICS Village Badge tool sponsored by FREE-WiLi and Intrepid Control Systems. Thanks to our sponsors for allowing us to keep the prices low for everyone to get access to this badge at an affordable price.  The ICS Village Badge for DEF CON 33 is a hands-on tool designed to explore Industrial Control Systems (ICS) security. It expands on last year's FREE-WILi Whale Tail badge by focusing on physical and environmental exploitation. With a rich set of built-in hardware, sensors, and software features, the badge allows you to interact with real-world ICS challenges.  The hardware is housed in a stunning, full-color PCB designed by Detroit artist Kyle Irving. At its core, the badge is powered by a Raspberry Pi RP2350A microcontroller.  Front Side  Front Side View of the Badge.  Back Side  Back Side View of the Badge.  Summary Key Features:‚Äã  BME688 ‚Äì First gas sensor with AI and integrated high-linearity and high-accuracy pressure, humidity and temperature sensorsAlcohol Sensor (MQ-3)ESP 32 WiFi C6XYZ Position sensorInfrared Receive and TransmitPowered by Raspberry Pi RP2350A with SRAM and FlashSpeaker320√ó240 Full Color Screen design5x Buttons5x Full color LEDsReal Time Clock (RTC)Compatible with FREE-WILI I2C applicationsFREE-WILi GUI Application supportFull Color PCB by local Detroit artist Kyle IrvingUSB terminal for I2C / SAO sensor interfacingI2C Expansion configured as DEFCON SAO1000 ma Lithium ION battery with integrated charger  Software Features‚Äã  Works with FREE-WILi GUIWiFi interface for ESP32 with Websocket interface to FREE-WILi GUIFuzzerUSB Serial console API to control from host PC without installing any softwareWASM (webassembly) scripting engine with examples for C/C++, Rust, Zig and Tiny GoHost API Python softwareFAT File systemWASM API to control all device featuresGUI Software with custom panels and graphical controlsIntegrated sounds and images in ROM for enhancing user appsNumbers To Speech feature to speak numbersFile formats compatible with existing market devicesStandard USB boot-loader for firmware updatesRaspberry Pi Pico (RP2350) Open Micro Platform for specific applications or custom code with C/C++, Micro-python or Circuit Python  info üöÄ We have released a new firmware updates for the badge, Check it out on GitHub and get the latest version now. üì± You can determine what firmware you have from the About app.    ICS village Badge has one RP2350 processors. Please follow the instructions in the FREE-WILi firmware update to update the badge manually.  ","version":"Next","tagName":"h2"},{"title":"üé• ‚á® Sensor View on the ICS Village DEFCON33 Badge: A Step-by-Step Guide‚Äã","type":1,"pageTitle":"ü§ñ ICS Village Badge for DEFCON 33 with AI Power","url":"/defcon-badges/icsvillage-badge-defcon33/#--sensor-view-on-the-ics-village-defcon33-badge-a-step-by-step-guide","content":"           ","version":"Next","tagName":"h2"},{"title":"üé• ‚á® Flash ESP32 on the ICS Village DEFCON33 Badge‚Äã","type":1,"pageTitle":"ü§ñ ICS Village Badge for DEFCON 33 with AI Power","url":"/defcon-badges/icsvillage-badge-defcon33/#--flash-esp32-on-the-ics-village-defcon33-badge","content":"           ","version":"Next","tagName":"h2"},{"title":"üé• ‚á® Exploring ESP32-C6 WiFi Features on the DEFCON 33 ICS Village Badge‚Äã","type":1,"pageTitle":"ü§ñ ICS Village Badge for DEFCON 33 with AI Power","url":"/defcon-badges/icsvillage-badge-defcon33/#--exploring-esp32-c6-wifi-features-on-the-defcon-33-ics-village-badge","content":"           ","version":"Next","tagName":"h2"},{"title":"üé• ‚á® Exploring ESP32-C6 BT Features on the DEFCON 33 ICS Village Badge‚Äã","type":1,"pageTitle":"ü§ñ ICS Village Badge for DEFCON 33 with AI Power","url":"/defcon-badges/icsvillage-badge-defcon33/#--exploring-esp32-c6-bt-features-on-the-defcon-33-ics-village-badge","content":" Download the Bluefruit Connect app from the Google Play Store.          ","version":"Next","tagName":"h2"},{"title":"Build-A-Badge üöÄ‚Äã","type":1,"pageTitle":"ü§ñ ICS Village Badge for DEFCON 33 with AI Power","url":"/defcon-badges/icsvillage-badge-defcon33/#build-a-badge-","content":"   An interactive badge customization application built with Rust and Iced GUI framework. Create and configure custom badges with personalized images, LED patterns, and names for DEFCON and other events.  ","version":"Next","tagName":"h2"},{"title":"Features‚Äã","type":1,"pageTitle":"ü§ñ ICS Village Badge for DEFCON 33 with AI Power","url":"/defcon-badges/icsvillage-badge-defcon33/#features","content":" üé® Custom Image Selection - Choose from 5 pre-loaded images or upload your ownüí° LED Pattern Configuration - 14 different LED light modes including Rainbow, Audio-reactive, and Accelerometer-based patternsüìù Badge Naming - Personalize your badge with a custom name (up to 23 characters)üîß Real-time Device Configuration - Live console output during device programmingüì± Cross-platform Support - Available for Windows, macOS, and LinuxüöÄ WASM Application Support - Upload and execute WebAssembly applications on your badge  ","version":"Next","tagName":"h3"},{"title":"Screenshots‚Äã","type":1,"pageTitle":"ü§ñ ICS Village Badge for DEFCON 33 with AI Power","url":"/defcon-badges/icsvillage-badge-defcon33/#screenshots","content":" The application features a intuitive multi-step workflow:  Welcome Screen - Introduction and getting startedImage Selection - Choose your badge image from available optionsLED Configuration - Select LED light patterns and effectsBadge Naming - Enter your personalized badge nameConfiguration Summary - Review and deploy to device  Install at https://github.com/freewili/build_a_badge ","version":"Next","tagName":"h3"},{"title":"Maestro Debug Orca","type":0,"sectionRef":"#","url":"/extending-with-orcas/maestro-debug-orca/","content":"","keywords":"Maestro Orca FREE-WILi USB debugger RP2040 IO test points Pico scope Logic Analyzer GPIO testing I2C SDCARD prototyping connectors","version":"Next"},{"title":"Features‚Äã","type":1,"pageTitle":"Maestro Debug Orca","url":"/extending-with-orcas/maestro-debug-orca/#features","content":" Integrated Raspberry Pi Debug Probe https://www.raspberrypi.com/documentation/microcontrollers/debug-probe.htmlPico scope Logic Analyzer Connector https://www.picotech.com/oscilloscope/2000/picoscope-2000-overviewLEDs which display IO statusSwitches to test GPIOs that are inputsPrototyping connectors for I2C (QWIIC) and SDCARDs.Jumper for selecting or injecting IO voltageConnector for plugging in additional Orca modules  ","version":"Next","tagName":"h2"},{"title":"Schematic‚Äã","type":1,"pageTitle":"Maestro Debug Orca","url":"/extending-with-orcas/maestro-debug-orca/#schematic","content":"   ","version":"Next","tagName":"h2"},{"title":"Useful tools‚Äã","type":1,"pageTitle":"Maestro Debug Orca","url":"/extending-with-orcas/maestro-debug-orca/#useful-tools","content":" Jumper wires  ELEGOO Breadbord Jumper Wires Amazon.com ","version":"Next","tagName":"h2"},{"title":"WhaleTail Orca","type":0,"sectionRef":"#","url":"/extending-with-orcas/whaletail-orca/","content":"WhaleTail Orca Please visit - https://whaletail.freewili.com/","keywords":"test","version":"Next"},{"title":"DEFCON32 Badge Edition","type":0,"sectionRef":"#","url":"/defcon-badges/defcon32-badge-edition/","content":"","keywords":"FREE-WILi DEFCON32 badge DEFCON32 badge FREE-WILi I2C control IR transmission IR reception GPIO SAO connector FREE-WILi firmware WASM scripting LED control badge development USB serial terminal RP2350 bootloader TSOP38238","version":"Next"},{"title":"Features of FREE-WILi Supported‚Äã","type":1,"pageTitle":"DEFCON32 Badge Edition","url":"/defcon-badges/defcon32-badge-edition/#features-of-free-wili-supported","content":" The badge does not contain all hardware in FREE-WILi but it does support a significant amount:  ScreenButtonsAccelerometerLEDs, light show with up to one LED light stripIR TransmissionIR Reception with addition of one sensorI2C controlGPIO control of USER1, USER2, and SAO pinsSound board with integrated buzzerUSB Serial Console TerminalWASM Scripting with ROM images  ","version":"Next","tagName":"h2"},{"title":"Loading FREE-WILi Software‚Äã","type":1,"pageTitle":"DEFCON32 Badge Edition","url":"/defcon-badges/defcon32-badge-edition/#loading-free-wili-software","content":" You can load the FREE-WILi uf2 by forcing the badge into the RP2350 boot loader. This is done by holding both the reset and the bootload button down and then releasing the reset. The reset and boot load buttons are on the back of back shown below.  After doing this the badge will present itself as a mass storage device (USB drive). Simple copy over the FreeWilliDefconVX.uf2 file to the drive. It will reset when it is complete flashing.  Booting new firmware into The Defcon32 badge.  ","version":"Next","tagName":"h2"},{"title":"Using The IR receive function‚Äã","type":1,"pageTitle":"DEFCON32 Badge Edition","url":"/defcon-badges/defcon32-badge-edition/#using-the-ir-receive-function","content":" The badge has an IRDa sensor. This is not directly compatible with IR Remote devices (although IR Transmit works). To use the FREE-WILi IR features you can add an IRSensor to the SAO connector as shown below. The output of the sensor must be connected to USER 1 as shown.  Addition of an IR Sensor to the SAO connector.  The recommend and tested sensor is the TSOP38238. It is available from Digikey    TSOP38238 | DigiKey Electronics DigiKey Electronics  ","version":"Next","tagName":"h2"},{"title":"The SAO Connector‚Äã","type":1,"pageTitle":"DEFCON32 Badge Edition","url":"/defcon-badges/defcon32-badge-edition/#the-sao-connector","content":" The badge has a SAO connector. This is a DEFCON standard IO connector for expansion. The connector has 4 GPIO of which two can be used as I2C. SAO pin in the lower left corner. Please note the I2C pins have pull up resistors. Also, the badge has 3 devices (touch screen, accel, rtc) already connected to the i2c.  The SAO pins with pin 1 in the lower left corner.  The schematic of the badge SAO connector is below.  The connections on the SAO connector.  FREE-WILi allows you to use these as i2c, PWM, IR Rx, GPIO or LED light strip control.  The GPIO view will allow you to manual control your SAO.  ","version":"Next","tagName":"h2"},{"title":"WASM Scripting‚Äã","type":1,"pageTitle":"DEFCON32 Badge Edition","url":"/defcon-badges/defcon32-badge-edition/#wasm-scripting","content":" The FREE-WILi badge firmware does not support the touch screen or RTC devices on the badge. This is a great use for WASM scripting. You can write WASM scripts that send and received I2C data. ","version":"Next","tagName":"h2"},{"title":"Custom Orca","type":0,"sectionRef":"#","url":"/extending-with-orcas/custom-orca/","content":"Custom Orca There are example projects for Orca for KiCAD and Altium Designer.","keywords":"Custom Orca KiCAD Altium Designer FREE-WILi Orca modules example projects custom design KiCAD Orca projects Altium Orca projects","version":"Next"},{"title":"The Basics","type":0,"sectionRef":"#","url":"/getting-started/the-basics/","content":"","keywords":"FREE-WILi device operation USB interfaces FPGA IO App GUI App firmware update USB boot loader hardware guide FREE-WILi USB ports","version":"Next"},{"title":"Turning FREE-WILi On or Off‚Äã","type":1,"pageTitle":"The Basics","url":"/getting-started/the-basics/#turning-free-wili-on-or-off","content":" You can turn FREE-WILi on by pressing the gray button or by connecting it to USB. You can turn FREE-WILi off by holding the red button for 5 seconds. Note when connected to USB FREE-WILi remains on.  ","version":"Next","tagName":"h2"},{"title":"Using the USB interfaces‚Äã","type":1,"pageTitle":"The Basics","url":"/getting-started/the-basics/#using-the-usb-interfaces","content":" When you plug FREE-WILi into a host, it will present 3 USB serial ports. One port connects to the FREE-WILi FPGA, One port connects to the IO App, and the last port connects to the GUI App processor.  ","version":"Next","tagName":"h2"},{"title":"Updating Firmware‚Äã","type":1,"pageTitle":"The Basics","url":"/getting-started/the-basics/#updating-firmware","content":" The FREE-WILi has an integrated USB boot loader to update firmware. Please see this topic. ","version":"Next","tagName":"h2"},{"title":"FREE-WILi Firmware Update","type":0,"sectionRef":"#","url":"/getting-started/freewili-firmware-update/","content":"","keywords":"FREE-WILi Firmware Update RP2040 Processor Update MAIN Processor Firmware DISPLAY Processor Firmware UF2 File Update FREE-WILi USB Bootloader Firmware Installation Guide","version":"Next"},{"title":"‚á® How to Use the FREE-WILi Updater (No Button Press Needed!)‚Äã","type":1,"pageTitle":"FREE-WILi Firmware Update","url":"/getting-started/freewili-firmware-update/#-how-to-use-the-free-wili-updater-no-button-press-needed","content":"           ","version":"Next","tagName":"h2"},{"title":"Updating the Main Processor‚Äã","type":1,"pageTitle":"FREE-WILi Firmware Update","url":"/getting-started/freewili-firmware-update/#updating-the-main-processor","content":" Pressing and holding the RED button as USB is connected activates the RP2040 ROM bootloader. This will enable the default way to program the RP2040 via USB.  Receive or create a FREE-WILi MAIN UF2 file.Hold the RED button and plug in USB.The host computer will show FREE-WILi as a flash drive.Copy the MAIN UF2 file to the flash drive. Allow firmware to update.After the update, FREE-WILi will disconnect from USB and reconnect as a USB COM Port (normal operation).  ","version":"Next","tagName":"h2"},{"title":"Updating the Display Processor‚Äã","type":1,"pageTitle":"FREE-WILi Firmware Update","url":"/getting-started/freewili-firmware-update/#updating-the-display-processor","content":" Pressing and holding the BLUE button as USB is connected activates the display processor bootloader.  Receive or create a FREE-WILi DISPLAY UF2 file.Hold the BLUE button and plug in USB.The host computer will show FREE-WILi as a flash drive.Copy the DISPLAY UF2 file to the flash drive. Allow firmware to update.After the update, FREE-WILi will disconnect from USB and reconnect as a USB COM Port (normal operation).  ","version":"Next","tagName":"h2"},{"title":"‚á® How to Update Your FREE-WILi Firmware (Main & Display)‚Äã","type":1,"pageTitle":"FREE-WILi Firmware Update","url":"/getting-started/freewili-firmware-update/#-how-to-update-your-free-wili-firmware-main--display","content":" Watch our video for more details.‚Äã   ","version":"Next","tagName":"h2"},{"title":"GPIO","type":0,"sectionRef":"#","url":"/gpio/","content":"","keywords":"FREE-WILi GPIO pin header SPI I2C UART digital protocols FPGA voltage levels embedded development protocol interface","version":"Next"},{"title":"Overview‚Äã","type":1,"pageTitle":"GPIO","url":"/gpio/#overview","content":" FREE-WILi includes a GPIO pin header for interacting with digital protocols. This GPIO header is flexible, allowing varying voltage levels and IO direction control. The GPIO system supports SPI, I2C, UART, and general-purpose digital I/O operations.  FREE-WILi Pinout.    FREE-WILi GPIO Header  ","version":"Next","tagName":"h2"},{"title":"GPIO System Architecture‚Äã","type":1,"pageTitle":"GPIO","url":"/gpio/#gpio-system-architecture","content":" The GPIO pins are routed through level-shifting buffers and an iCE40UP5K FPGA before connecting to the RP2040 main processor. This architecture enables real-time operations such as the logic analyzer functionality while maintaining protocol compatibility.  ","version":"Next","tagName":"h2"},{"title":"Quick Start‚Äã","type":1,"pageTitle":"GPIO","url":"/gpio/#quick-start","content":" Set I/O Voltage Level: Connect a jumper between pins 2-4 (5V) or 4-6 (3.3V) Pin 4 MUST have voltage for GPIO to function Configure Pin Directions: Use the GPIO panel in the GUI or settings menu via serial consoleSelect Protocol: Access SPI, I2C, or UART functionality through the main console application  ","version":"Next","tagName":"h2"},{"title":"GPIO Documentation Sections‚Äã","type":1,"pageTitle":"GPIO","url":"/gpio/#gpio-documentation-sections","content":" Pinout &amp; Electrical Specifications - Pin descriptions, voltage levels, and electrical characteristicsProtocol Configuration - SPI, I2C, and UART setup and specificationsCommon Issues &amp; Troubleshooting - Solutions to frequent problems  ","version":"Next","tagName":"h2"},{"title":"Related Documentation‚Äã","type":1,"pageTitle":"GPIO","url":"/gpio/#related-documentation","content":" Logic Analyzer - Real-time GPIO monitoring and analysisWASM Scripting - Advanced GPIO control through WebAssemblyZoomIO Scripting - Nanosecond-precision GPIO timingSettings Menu - GPIO direction and protocol configuration ","version":"Next","tagName":"h2"},{"title":"WILEYE Camera Orca","type":0,"sectionRef":"#","url":"/extending-with-orcas/wileye-camera-orca/","content":"","keywords":"WILEYE Camera Orca FREE-WILi Orca ESP32-P4 module embedded vision accessory IoT camera module robotics camera ESP32 debugging USB JTAG MicroSD logging MIPI-CSI ESP32 camera hardware hacking Orca ecosystem","version":"Next"},{"title":"Features‚Äã","type":1,"pageTitle":"WILEYE Camera Orca","url":"/extending-with-orcas/wileye-camera-orca/#features","content":" Plug-and-play programming &amp; debugging via USB JTAGReal-time image capture for robotics, IoT &amp; RF projectsOn-device LCD for logs, status &amp; previewsMicroSD logging for field experimentsTripod/enclosure mounting for flexible setupsBuilt to extend FREE-WILi Orca ecosystemESP32-P4 Dual-core RISC-V SoC32MB PSRAM, 16MB Flash, MicroSD support2MP MIPI-CSI camera, manual focus + software zoom1.54‚Ä≥ SPI LCD, 240√ó240 resolutionUSB 2.0 HS + USB Serial JTAG1/4‚Ä≥ screw mount ","version":"Next","tagName":"h2"},{"title":"GPIO Protocol Configuration","type":0,"sectionRef":"#","url":"/gpio/gpio-protocols/","content":"","keywords":"FREE-WILi protocols SPI configuration I2C setup UART parameters protocol settings frequency configuration concurrent protocols digital communication","version":"Next"},{"title":"Overview‚Äã","type":1,"pageTitle":"GPIO Protocol Configuration","url":"/gpio/gpio-protocols/#overview","content":" FREE-WILi's GPIO header supports multiple digital communication protocols. Each protocol can be configured through the Settings Menu and operates independently on dedicated pin sets.  ","version":"Next","tagName":"h2"},{"title":"SPI Configuration‚Äã","type":1,"pageTitle":"GPIO Protocol Configuration","url":"/gpio/gpio-protocols/#spi-configuration","content":" ","version":"Next","tagName":"h2"},{"title":"Pin Assignment‚Äã","type":1,"pageTitle":"GPIO Protocol Configuration","url":"/gpio/gpio-protocols/#pin-assignment","content":" Pin 1: Chip Select (CS) - OutputPin 12: RX (MISO) - InputPin 13: TX (MOSI) - OutputPin 15: SCLK - Output  ","version":"Next","tagName":"h3"},{"title":"SPI Parameters‚Äã","type":1,"pageTitle":"GPIO Protocol Configuration","url":"/gpio/gpio-protocols/#spi-parameters","content":" Frequency Configuration:  Range: Up to 70 MHzDefault: 5 MHzConfiguration: Via settings menu  Clock Polarity and Phase:  CPOL: Programmable clock polarityCPHA: Programmable clock phase  ","version":"Next","tagName":"h3"},{"title":"I2C Configuration‚Äã","type":1,"pageTitle":"GPIO Protocol Configuration","url":"/gpio/gpio-protocols/#i2c-configuration","content":" ","version":"Next","tagName":"h2"},{"title":"Pin Assignment‚Äã","type":1,"pageTitle":"GPIO Protocol Configuration","url":"/gpio/gpio-protocols/#pin-assignment-1","content":" Pin 8: SCL (Clock) - BidirectionalPin 10: SDA (Data) - Bidirectional  ","version":"Next","tagName":"h3"},{"title":"I2C Parameters‚Äã","type":1,"pageTitle":"GPIO Protocol Configuration","url":"/gpio/gpio-protocols/#i2c-parameters","content":" Frequency Configuration:  Range: Up to 1 MHzDefault: 100 kHz (Standard mode)Supported: Standard (100 kHz), Fast (400 kHz), Fast+ (1 MHz)  Pull-up Resistors:  Built-in: Software-controlled 10kŒ© pull-ups on PCA9517 bufferControl: Enable/disable via settings menuVoltage: Matches V PINS IN level  ","version":"Next","tagName":"h3"},{"title":"UART Configuration‚Äã","type":1,"pageTitle":"GPIO Protocol Configuration","url":"/gpio/gpio-protocols/#uart-configuration","content":" ","version":"Next","tagName":"h2"},{"title":"Pin Assignment‚Äã","type":1,"pageTitle":"GPIO Protocol Configuration","url":"/gpio/gpio-protocols/#pin-assignment-2","content":" Pin 5: RX (Receive) - InputPin 7: CTS (Clear To Send) - InputPin 9: TX (Transmit) - OutputPin 11: RTS (Request To Send) - Output  ","version":"Next","tagName":"h3"},{"title":"UART Parameters‚Äã","type":1,"pageTitle":"GPIO Protocol Configuration","url":"/gpio/gpio-protocols/#uart-parameters","content":" Baud Rate:  Range: Up to 8,000,000 bpsDefault: 115,200 bpsConfiguration: Programmable via settings menu  Data Format:  Data Bits: 4-16 bits (default: 8)Parity: None, Even, Odd (default: None)Stop Bits: 1-2 (default: 1)Flow Control: RTS/CTS handshaking available (default: disabled)  Full Duplex: Simultaneous transmit and receive operations supported.  ","version":"Next","tagName":"h3"},{"title":"Protocol Interaction‚Äã","type":1,"pageTitle":"GPIO Protocol Configuration","url":"/gpio/gpio-protocols/#protocol-interaction","content":" ","version":"Next","tagName":"h2"},{"title":"Concurrent Protocol Operation‚Äã","type":1,"pageTitle":"GPIO Protocol Configuration","url":"/gpio/gpio-protocols/#concurrent-protocol-operation","content":" Supported Combinations:  All three protocols (SPI, I2C, UART) can operate simultaneouslyNo hardware conflicts between protocolsIndependent configuration and operation  Shared Resources:  All protocols share the same V PINS IN voltage levelLogic analyzer can monitor all protocols  ","version":"Next","tagName":"h3"},{"title":"Configuration Examples‚Äã","type":1,"pageTitle":"GPIO Protocol Configuration","url":"/gpio/gpio-protocols/#configuration-examples","content":" ","version":"Next","tagName":"h2"},{"title":"High-Speed SPI Setup‚Äã","type":1,"pageTitle":"GPIO Protocol Configuration","url":"/gpio/gpio-protocols/#high-speed-spi-setup","content":" Settings Menu &gt; SPI Configuration: - Frequency: 20 MHz - CPOL: 0 (Clock idle low) - CPHA: 0 (Sample on rising edge)   ","version":"Next","tagName":"h3"},{"title":"Fast I2C Configuration‚Äã","type":1,"pageTitle":"GPIO Protocol Configuration","url":"/gpio/gpio-protocols/#fast-i2c-configuration","content":" Settings Menu &gt; I2C Configuration: - Frequency: 400 kHz (Fast mode) - Pull-ups: Enabled   ","version":"Next","tagName":"h3"},{"title":"High Baud Rate UART‚Äã","type":1,"pageTitle":"GPIO Protocol Configuration","url":"/gpio/gpio-protocols/#high-baud-rate-uart","content":" Settings Menu &gt; UART Configuration: - Baud Rate: 2,000,000 bps - RTS Hand Shaking: Enabled - CTS Hand Shaking: Enabled - Data Bits: 8 - Parity: None - Stop Bits: 1   Related documentation:  Settings Menu DocumentationWASM Scripting for automated protocol control ","version":"Next","tagName":"h3"},{"title":"FPGA Connections","type":0,"sectionRef":"#","url":"/hardware-low-level-details/ice40-fpga/fpga-connections/","content":"FPGA Connections The FPGA connects to the Serial SRAM, IO Drivers, and the RP2040. The FPGA development tools including Open Source (yosys, nextpnr, icestorm) and commercial (icecube2) support a pin constraints file that defines how the pins connect to the HDL (verilog/vhdl) connections. This is included below: The PCF file is a text file you can view in a text editor. In the file you will see the names that end with Rp or Out. The Rp names connect to the RP2040 and the Out connects to the IO driver. set_io SPI_MISO_Rp 14 set_io SPI_MISO_Out 25 fw.pcf","keywords":"FPGA Connections iCE40 FPGA Pin Constraints RP2040 FPGA Serial SRAM FPGA IO Drivers FPGA PCF File FPGA Development Tools yosys nextpnr icestorm icecube2","version":"Next"},{"title":"iCE40 FPGA","type":0,"sectionRef":"#","url":"/hardware-low-level-details/ice40-fpga/","content":"iCE40 FPGA The FREE-WILi contains an iCE40 FPGA between the RP2040 main processor and the IO drivers. The FPGA allows sophisticated high speed IO and state machines that can process IO and communicate to the RP2040 or communicate to the host directly using high speed USB. The FPGA contains a default application so changing FPGA configuration is entirely optional. But changing the configuration is allowed and can be done at anytime and an unlimited number of times. See FPGA Programming for details. The FPGA is connected to a high speed FTDI USB interface and an 8Mbyte Serial SRAM. The block diagram is shown below. The part numbers associated with the FPGA IO system are below: Part\tPart Number\tNotesFTDI USB\tFT232HQ\tOperates in FT1248 mode. https://ftdichip.com/products/ft232hq/ Serial SRAM 8 MByte\tAPS6404L-3SQR-ZR\thttps://www.apmemory.com FPGA\tICE40UP5K-SG48I\thttps://www.latticesemi.com/en/Products/FPGAandCPLD/iCE40UltraPlus","keywords":"iCE40 FPGA FREE-WILi FPGA Overview FTDI USB FT232HQ Serial SRAM APS6404L FPGA Configuration RP2040 FPGA Integration High-Speed IO FPGA","version":"Next"},{"title":"FPGA Default Application","type":0,"sectionRef":"#","url":"/hardware-low-level-details/ice40-fpga/fpga-default-application/","content":"FPGA Default Application The default FPGA application is a simple design that transforms the FREE-WILi into a sigrok-compatible logic analyzer. The design features an IO buffer that can set the directions of the SPI and UART pins as well as GPIO_26 and GPIO27. To enable this programming, the IO_CONFIG_ENABLE pin must be asserted - this allows the FPGA's SPI-Slave to assume control of the SPI interface with the main RP2040 as the master. The pin direction defaults are as specified in GPIO. Please note that the pin directionality is also dependent on the sn74lxc1t45 hardware IO buffers between the FPGA and breakout pins. For the logic analyzer, the FPGA samples the SPI pins at the clock frequency provided by the main RP2040 - this design expects a frequency of 31.25 MHz. The samples are encoded via Run-Length Encoding and, once the FPGA is initiated by sigrok via FTDI, stored in a 32 kB FIFO built using the iCE40's on-chip SPRAM. Finally, these samples are sent via the FT1248 4-wire communication protocol to USB where sigrok can collect them. The libsigrok fork where the FREE-WILi hardware driver was developed can be found at libsigrok-fwili. The translation from the sigrok channel name to the corresponding pin for SPI protocol is detailed below. sigrok channel name\tSPI4\tCS 3\tSCLK 2\tMOSI 1\tMISO","keywords":"FPGA Default Application FREE-WILi Logic Analyzer Sigrok-Compatible FPGA SPI Configuration iCE40 FPGA FTDI Communication Run-Length Encoding libsigrok-fwili","version":"Next"},{"title":"GPIO Troubleshooting Guide","type":0,"sectionRef":"#","url":"/gpio/gpio-troubleshooting/","content":"","keywords":"FREE-WILi troubleshooting GPIO problems voltage issues protocol debugging signal integrity pin direction V PINS IN diagnostic tools","version":"Next"},{"title":"Most Common Issue: No Voltage Applied‚Äã","type":1,"pageTitle":"GPIO Troubleshooting Guide","url":"/gpio/gpio-troubleshooting/#most-common-issue-no-voltage-applied","content":" ","version":"Next","tagName":"h2"},{"title":"Problem: GPIO pins not responding or protocols not working‚Äã","type":1,"pageTitle":"GPIO Troubleshooting Guide","url":"/gpio/gpio-troubleshooting/#problem-gpio-pins-not-responding-or-protocols-not-working","content":" Root Cause: Pin 4 (V PINS IN) does not have voltage applied.  Solution:  Verify Jumper Connection:  For 5V: Jumper between pins 2 and 4For 3.3V: Jumper between pins 4 and 6For custom voltage: Apply 1.1V-5.5V directly to pin 4  This is the #1 cause of GPIO problems. Always check voltage first.  ","version":"Next","tagName":"h3"},{"title":"Pin Direction Issues‚Äã","type":1,"pageTitle":"GPIO Troubleshooting Guide","url":"/gpio/gpio-troubleshooting/#pin-direction-issues","content":" ","version":"Next","tagName":"h2"},{"title":"Problem: Pins not responding as expected‚Äã","type":1,"pageTitle":"GPIO Troubleshooting Guide","url":"/gpio/gpio-troubleshooting/#problem-pins-not-responding-as-expected","content":" Symptoms:  Output pins not driving signalsInput pins not reading correctlyProtocol communication failures  Diagnosis:  Check pin direction configuration in GPIO panel or settings menuVerify directions match your intended usage (input vs output)Confirm protocol-specific direction requirements  Solutions:  On the device:  Open GPIO panelSelect affected pinsSet correct direction (input/output)Changes take effect immediately  Via Serial Console:  Navigate to Settings &gt; GPIO DirectionsConfigure pin directionsCritical: Return to main menu for changes to take effectRe-test GPIO operation  ","version":"Next","tagName":"h3"},{"title":"Protocol Configuration Problems‚Äã","type":1,"pageTitle":"GPIO Troubleshooting Guide","url":"/gpio/gpio-troubleshooting/#protocol-configuration-problems","content":" ","version":"Next","tagName":"h2"},{"title":"SPI Issues‚Äã","type":1,"pageTitle":"GPIO Troubleshooting Guide","url":"/gpio/gpio-troubleshooting/#spi-issues","content":" Problem: SPI communication not working  Common Causes:  Incorrect clock polarity/phase settingsFrequency too high for target deviceWrong pin directions  Solutions:  Verify SPI mode (CPOL/CPHA) matches target deviceReduce frequency to 1 MHz for testingCheck connections: CS (pin 1), MOSI (pin 13), MISO (pin 12), SCLK (pin 15)Ensure target device shares same ground reference  ","version":"Next","tagName":"h3"},{"title":"I2C Issues‚Äã","type":1,"pageTitle":"GPIO Troubleshooting Guide","url":"/gpio/gpio-troubleshooting/#i2c-issues","content":" Problem: I2C devices not detected or responding  Common Causes:  Pull-up resistors not enabledWrong I2C frequencyVoltage level mismatchAddress conflicts  Solutions:  Enable built-in 10kŒ© pull-ups in settings menuReduce frequency to 100 kHz (standard mode)Verify device I2C address with scanner functionCheck voltage level compatibility (pin 4 voltage)  ","version":"Next","tagName":"h3"},{"title":"UART Issues‚Äã","type":1,"pageTitle":"GPIO Troubleshooting Guide","url":"/gpio/gpio-troubleshooting/#uart-issues","content":" Problem: UART data corruption or no communication  Common Causes:  Baud rate mismatchWrong data format (bits, parity, stop bits)Hardware flow control issuesTX/RX connections swapped  Solutions:  Verify baud rate matches target device exactlyCheck data format: 8-N-1 is most commonDisable hardware flow control initiallyVerify TX (pin 9) connects to target RX, RX (pin 5) to target TX  ","version":"Next","tagName":"h3"},{"title":"Signal Integrity Problems‚Äã","type":1,"pageTitle":"GPIO Troubleshooting Guide","url":"/gpio/gpio-troubleshooting/#signal-integrity-problems","content":" ","version":"Next","tagName":"h2"},{"title":"Problem: Intermittent communication or data errors‚Äã","type":1,"pageTitle":"GPIO Troubleshooting Guide","url":"/gpio/gpio-troubleshooting/#problem-intermittent-communication-or-data-errors","content":" Symptoms:  Occasional protocol failuresData corruptionTiming-sensitive issues  Diagnosis Tools:  Use Logic Analyzer to examine signalsCheck for proper rise/fall timesVerify clock stability and timing  Common Solutions:  Ground Issues:  Ensure solid ground connection (pins 19/20)Use shortest possible ground wiresConnect target device ground to FREE-WILi ground  Cable Length:  Keep connections as short as possibleUse twisted pairs for differential signalsAdd termination for high-speed signals  Voltage Level Matching:  Verify target device voltage compatibilityCheck that V PINS IN voltage matches target requirementsConsider voltage dividers for 5V ‚Üî 3.3V interfacing  ","version":"Next","tagName":"h3"},{"title":"Getting Additional Help‚Äã","type":1,"pageTitle":"GPIO Troubleshooting Guide","url":"/gpio/gpio-troubleshooting/#getting-additional-help","content":" ","version":"Next","tagName":"h2"},{"title":"Documentation Resources‚Äã","type":1,"pageTitle":"GPIO Troubleshooting Guide","url":"/gpio/gpio-troubleshooting/#documentation-resources","content":" Protocol Configuration - Detailed protocol setupPinout Specifications - Electrical characteristicsLogic Analyzer - Signal analysis toolsSettings Menu - Configuration interface  ","version":"Next","tagName":"h3"},{"title":"Self-Help Debugging‚Äã","type":1,"pageTitle":"GPIO Troubleshooting Guide","url":"/gpio/gpio-troubleshooting/#self-help-debugging","content":" Start Simple: Test with basic GPIO toggle before complex protocolsIsolate Variables: Test one protocol/pin at a timeUse Built-in Tools: GPIO panel, logic analyzer, protocol menusCheck Connections: Physical wiring is often the issueVerify Voltage: Always confirm V PINS IN has proper voltage  ","version":"Next","tagName":"h3"},{"title":"Common Debugging Sequence‚Äã","type":1,"pageTitle":"GPIO Troubleshooting Guide","url":"/gpio/gpio-troubleshooting/#common-debugging-sequence","content":" Power Check: Verify USB-C connected, voltage on pin 4Basic GPIO: Test simple pin toggle with GPIO panelPin Directions: Confirm input/output settings match usageProtocol Settings: Verify frequency, mode, format settingsSignal Quality: Use logic analyzer to examine waveformsLoad Testing: Check current requirements vs. drive capability  Remember: The most common issue is forgetting to apply voltage to V PINS IN (pin 4). Always check this first when troubleshooting GPIO problems. ","version":"Next","tagName":"h3"},{"title":"FPGA Clock","type":0,"sectionRef":"#","url":"/hardware-low-level-details/ice40-fpga/fpga-clock/","content":"FPGA Clock The clock signal to the FPGA is supplied by the main RP2040. This is done on GPIO23 using the Clock Generator feature. The clock generated can be generated from numerous clock sources with a integer and fractional divider. For example, the default sys clock of 125 mhz can be used or divided down. Please see the rp2040 data sheet for details. The Intrepid IO app has a device setting where you can select the FPGA clock source and divider. The default setting is sys clock (125Mhz) divided by 4 (31.25 Mhz) .","keywords":"FPGA Clock Configuration RP2040 FPGA Clock Signal Clock Generator Feature iCE40 FPGA Clock Source Intrepid IO App FPGA Settings FPGA Clock Divider","version":"Next"},{"title":"WILEYE Hardware Hookup Guide","type":0,"sectionRef":"#","url":"/extending-with-orcas/wileye-camera-orca/wileye-hardware-hookup/","content":"","keywords":"WILEYE hardware hookup ESP32-P4 connections camera mounting MicroSD setup USB JTAG FREE-WILi Orca connection hardware setup guide","version":"Next"},{"title":"About the ESP32-P4-EYE Platform‚Äã","type":1,"pageTitle":"WILEYE Hardware Hookup Guide","url":"/extending-with-orcas/wileye-camera-orca/wileye-hardware-hookup/#about-the-esp32-p4-eye-platform","content":" The WILEYE Camera Orca is built around the ESP32-P4-EYE development board from Espressif. For comprehensive technical documentation about the hardware platform, refer to:  üìñ ESP32-P4-EYE Official Documentation: https://docs.espressif.com/projects/esp-dev-kits/en/latest/esp32p4/esp32-p4-eye/index.html  This official documentation provides detailed information about:  Complete hardware schematics and component layoutCamera sensor specifications and configurationGPIO pin assignments and electrical characteristicsPower consumption and thermal considerationsAdvanced programming examples and ESP-IDF integration  Hardware Reference For advanced users working directly with the ESP32-P4-EYE, the official Espressif documentation is the authoritative source for all hardware specifications and programming details.  ","version":"Next","tagName":"h2"},{"title":"Required Components‚Äã","type":1,"pageTitle":"WILEYE Hardware Hookup Guide","url":"/extending-with-orcas/wileye-camera-orca/wileye-hardware-hookup/#required-components","content":" 1 x ESP32-P4-EYE1 x FREE-WIL-EYE Orca module Adapter1 x USB-C cable for programming/power (optional, for interfacing with FREE-WILi or getting images from ESP32 P4 EYE)1 x MicroSD card (optional, for data logging)  ","version":"Next","tagName":"h2"},{"title":"Physical Connections‚Äã","type":1,"pageTitle":"WILEYE Hardware Hookup Guide","url":"/extending-with-orcas/wileye-camera-orca/wileye-hardware-hookup/#physical-connections","content":" ","version":"Next","tagName":"h2"},{"title":"Connecting to FREE-WILi‚Äã","type":1,"pageTitle":"WILEYE Hardware Hookup Guide","url":"/extending-with-orcas/wileye-camera-orca/wileye-hardware-hookup/#connecting-to-free-wili","content":" Power down your FREE-WILi device before making connectionsAlign the Orca connector on the WILEYE module with the Orca port on your FREE-WILi deviceGently press the modules together until the connectors are fully seatedVerify alignment by checking that the boards are parallel and the connector is fully engaged  Proper Orientation Required! CRITICAL: The camera lens must be visible on the same side as the FREE-WILi logo on the adapter board. Before connecting the FREE-WIL-EYE Orca adapter to FREE-WILi, verify this alignment to prevent damage. Incorrect orientation may cause a short circuit that could damage both your FREE-WILi and the ESP32-P4-EYE!  ","version":"Next","tagName":"h3"},{"title":"MicroSD Card Installation‚Äã","type":1,"pageTitle":"WILEYE Hardware Hookup Guide","url":"/extending-with-orcas/wileye-camera-orca/wileye-hardware-hookup/#microsd-card-installation","content":" An MicroSD card can be connected to the ESP-P4-EYE to save videos and pictures.  SD Card Recommendations Use Class 10 or higher MicroSD cards for optimal performanceFormat the card as FAT32 for best compatibility32GB or smaller cards are recommended for fastest boot times  ","version":"Next","tagName":"h2"},{"title":"GPIO and Expansion‚Äã","type":1,"pageTitle":"WILEYE Hardware Hookup Guide","url":"/extending-with-orcas/wileye-camera-orca/wileye-hardware-hookup/#gpio-and-expansion","content":" ","version":"Next","tagName":"h2"},{"title":"Communication between ESP32-P4-EYE and FREE-WILi‚Äã","type":1,"pageTitle":"WILEYE Hardware Hookup Guide","url":"/extending-with-orcas/wileye-camera-orca/wileye-hardware-hookup/#communication-between-esp32-p4-eye-and-free-wili","content":" The FREE-WIL-EYE Orca module Adapter routes UART data and hardware handshake lines between ESP32-P4-EYE and FREE-WILi.  UART Pinout‚Äã  ESP32-P4-EYE Pin\tFREE-WILi Pin\tFunctionESP_5V\t5V OUT\tPower Supply (5V) GPIO37\tUART1_TX_Out\tTransmit Data (FREE-WILi ‚Üí ESP32 ) GPIO38\tUART1_RX_IN\tReceive Data (ESP32 ‚Üí FREE-WILi) GPIO34\tUART1_CTS_IN\tClear to Send (Hardware Flow Control) GPIO51\tUART1_RTS_OUT\tRequest to Send (Hardware Flow Control) GND\tGND\tGround Reference  Both device's UART is configured with the following parameters:  5 Mbps Baudrate - High-speed communication for image/video dataCTS and RTS Controls Enabled - Hardware flow control for reliable transmission8 Data Bits - Standard data frame size1 Stop Bit - Standard frame terminationNo Parity - Error detection handled at higher protocol levels  UART parameters on FREE-WILi FREE-WILi will automatically set the required UART parameters if you enable WILEye Communicaiotn in the Orac Setup Setting. We will be going over that later.  ","version":"Next","tagName":"h3"},{"title":"Additional Exposed Pins‚Äã","type":1,"pageTitle":"WILEYE Hardware Hookup Guide","url":"/extending-with-orcas/wileye-camera-orca/wileye-hardware-hookup/#additional-exposed-pins","content":" The FREE-WIL-EYE Orca adapter also exposes additional FREE-WILi's IO to allow interfacing with additional interfaces:  I2C communication (SDA/SCL) over the QWIIC connectorSPI interfaceDigital I/O pinsPower rails (3.3V, 5V, GND)  ","version":"Next","tagName":"h3"},{"title":"Pin Configuration‚Äã","type":1,"pageTitle":"WILEYE Hardware Hookup Guide","url":"/extending-with-orcas/wileye-camera-orca/wileye-hardware-hookup/#pin-configuration","content":" For detailed pin assignments and GPIO capabilities, refer to the ESP32-P4-EYE official documentation: https://docs.espressif.com/projects/esp-dev-kits/en/latest/esp32p4/esp32-p4-eye/index.html  ","version":"Next","tagName":"h3"},{"title":"Troubleshooting Hardware Issues‚Äã","type":1,"pageTitle":"WILEYE Hardware Hookup Guide","url":"/extending-with-orcas/wileye-camera-orca/wileye-hardware-hookup/#troubleshooting-hardware-issues","content":" ","version":"Next","tagName":"h2"},{"title":"Camera Problems‚Äã","type":1,"pageTitle":"WILEYE Hardware Hookup Guide","url":"/extending-with-orcas/wileye-camera-orca/wileye-hardware-hookup/#camera-problems","content":" No image: Check camera cable connection and lens capBlurry images: Adjust manual focus ringPoor image quality: Clean lens surface and check lighting conditions  ","version":"Next","tagName":"h3"},{"title":"Next Steps‚Äã","type":1,"pageTitle":"WILEYE Hardware Hookup Guide","url":"/extending-with-orcas/wileye-camera-orca/wileye-hardware-hookup/#next-steps","content":" Once your hardware is connected:  Try the WILEYE Getting Started tutorialExplore advanced features in the main WILEYE Camera Orca documentation  ","version":"Next","tagName":"h2"},{"title":"Additional Resources‚Äã","type":1,"pageTitle":"WILEYE Hardware Hookup Guide","url":"/extending-with-orcas/wileye-camera-orca/wileye-hardware-hookup/#additional-resources","content":" For advanced hardware work and custom development:  üìñ ESP32-P4-EYE Official Documentation - Complete hardware specificationsüîß ESP32-P4-EYE GitHub Repository - Schematics and design filesüíª ESP-IDF Programming Guide - Advanced ESP32-P4 programmingüìê ESP32-P4 Datasheet - Technical specifications ","version":"Next","tagName":"h2"},{"title":"Hardware Low Level Details","type":0,"sectionRef":"#","url":"/hardware-low-level-details/","content":"Hardware Low Level Details The hardware low level details section is provided so end users can write their own apps that run on the main RP2040 PI Pico processor and/or develop their own FPGA front end design","keywords":"FREE-WILi Hardware Details RP2040 PI Pico FPGA Front End Design Custom Hardware Apps Low-Level Hardware Development FPGA Integration","version":"Next"},{"title":"GPIO Pinout & Electrical Specifications","type":0,"sectionRef":"#","url":"/gpio/gpio-pinout/","content":"","keywords":"FREE-WILi pinout GPIO specifications voltage levels current ratings ESD protection SN74LXC1T45 PCA9517 pin configuration electrical characteristics","version":"Next"},{"title":"Pinout Diagram‚Äã","type":1,"pageTitle":"GPIO Pinout & Electrical Specifications","url":"/gpio/gpio-pinout/#pinout-diagram","content":" FREE-WILi includes a 20-pin GPIO header with the following layout:  FREE-WILi Pinout.    FREE-WILi GPIO Header  ","version":"Next","tagName":"h2"},{"title":"GPIO Pin Descriptions‚Äã","type":1,"pageTitle":"GPIO Pinout & Electrical Specifications","url":"/gpio/gpio-pinout/#gpio-pin-descriptions","content":" Pin\tDescription\tDefault Direction\tRP2040 GPIO\tBuffer Chip\tNotes1\tSPI Chip Select Out\tOutput\tGPIO13\tSN74LXC1T45 2\t5V Out\tOutput\t-\t-\t5V power output for external circuits 3\tGPIO27 OUT\tOutput\tGPIO27\tSN74LXC1T45\tGeneral purpose I/O 4\tV PINS IN\tInput\t-\t-\tREQUIRED: Sets I/O voltage level (1.1V to 5.5V) 5\tUART1 Rx IN\tInput\tGPIO9\tSN74LXC1T45\tUART receive 6\t3.3V Out\tOutput\t-\t-\t3.3V power output for external circuits 7\tUART1 CTS IN\tInput\tGPIO10\tSN74LXC1T45\tUART Clear To Send 8\tI2C0 SCL\tIn/Out\tGPIO17\tPCA9517\tI2C clock with software-controlled pullups 9\tUART1 TX OUT\tOutput\tGPIO8\tSN74LXC1T45\tUART transmit 10\tI2C0 SDA\tIn/Out\tGPIO16\tPCA9517\tI2C data with software-controlled pullups 11\tUART1 RTS OUT\tOutput\tGPIO11\tSN74LXC1T45\tUART Request To Send 12\tSPI1 RX IN\tInput\tGPIO12\tSN74LXC1T45\tSPI receive (MISO) 13\tSPI1 TX OUT\tOutput\tGPIO15\tSN74LXC1T45\tSPI transmit (MOSI) 14\tGPIO 26 IN\tInput\tGPIO26\tSN74LXC1T45\tGeneral purpose I/O 15\tSPI1 SCLK OUT\tOutput\tGPIO14\tSN74LXC1T45\tSPI clock 16\tSWCLK IN\tInput\tSWCLK\t-\tSWD debugger clock input 17\tGPIO25 OUT\tOutput\tGPIO25\tSN74LXC1T45\tGeneral purpose I/O (also board status LED) 18\tSWDIO\tIn/Out\tSWDIO\t-\tSWD debugger I/O 19\tGND\t-\t-\t-\tGround reference 20\tGND\t-\t-\t-\tGround reference  ","version":"Next","tagName":"h2"},{"title":"Voltage Level Configuration‚Äã","type":1,"pageTitle":"GPIO Pinout & Electrical Specifications","url":"/gpio/gpio-pinout/#voltage-level-configuration","content":" Critical: Pin 4 (V PINS IN) MUST have a voltage applied for GPIO functionality to work.  ","version":"Next","tagName":"h2"},{"title":"Jumper Configuration‚Äã","type":1,"pageTitle":"GPIO Pinout & Electrical Specifications","url":"/gpio/gpio-pinout/#jumper-configuration","content":" 5V Operation: Connect jumper between pins 2 and 43.3V Operation: Connect jumper between pins 4 and 6Custom Voltage: Apply 1.1V to 5.5V directly to pin 4  The voltage on pin 4 sets the I/O level for all buffered GPIO pins.  ","version":"Next","tagName":"h3"},{"title":"Electrical Specifications‚Äã","type":1,"pageTitle":"GPIO Pinout & Electrical Specifications","url":"/gpio/gpio-pinout/#electrical-specifications","content":" ","version":"Next","tagName":"h2"},{"title":"Current Drive Capabilities‚Äã","type":1,"pageTitle":"GPIO Pinout & Electrical Specifications","url":"/gpio/gpio-pinout/#current-drive-capabilities","content":" SN74LXC1T45 Buffered Pins (UART, SPI, GPIO 25/26/27):  Recommended: 24 mA @ 3.3V, 32 mA @ 5VAbsolute Maximum: 50 mA (regardless of voltage)Voltage Range: 1.1V to 5.5V (set by V PINS IN)  PCA9517 Buffered Pins (I2C):  Maximum: 50 mAVoltage Range: 0.9V to 5.5V (set by V PINS IN)Features: Software-controllable 10kŒ© pull-up resistors  Power Supply Pins:  Pin 2 (5V): Up to 3A theoretical maximum (shared with entire system)Pin 6 (3.3V): Up to 3A theoretical maximum (shared with entire system)  ","version":"Next","tagName":"h3"},{"title":"Buffer Chip Datasheets‚Äã","type":1,"pageTitle":"GPIO Pinout & Electrical Specifications","url":"/gpio/gpio-pinout/#buffer-chip-datasheets","content":" ","version":"Next","tagName":"h2"},{"title":"SN74LXC1T45 (UART, SPI, GPIO pins):‚Äã","type":1,"pageTitle":"GPIO Pinout & Electrical Specifications","url":"/gpio/gpio-pinout/#sn74lxc1t45-uart-spi-gpio-pins","content":"   sn74lxc1t45.pdf pdf  ","version":"Next","tagName":"h3"},{"title":"PCA9517 (I2C pins):‚Äã","type":1,"pageTitle":"GPIO Pinout & Electrical Specifications","url":"/gpio/gpio-pinout/#pca9517-i2c-pins","content":" PCA9517-3139014.pdf pdf  ","version":"Next","tagName":"h3"},{"title":"Pin Direction Control‚Äã","type":1,"pageTitle":"GPIO Pinout & Electrical Specifications","url":"/gpio/gpio-pinout/#pin-direction-control","content":" All GPIO pins can be configured as input or output:  GUI Method: Use the GPIO panel in the graphical interface on the deviceSerial Console: Navigate to Settings &gt; GPIO Directions Important: Settings changes via serial console take effect only after returning to the main menu  Pin directions can be changed dynamically during operation. The RP2040, FPGA, and I/O buffers automatically coordinate direction changes. ","version":"Next","tagName":"h2"},{"title":"Helpful Links","type":0,"sectionRef":"#","url":"/helpful-links/","content":"Helpful Links C/C++ Installer for RP2040 Open Processor Raspberry Pi Pico Windows Installer - Raspberry Pi Raspberry Pi Texas Instruments Sub Ghz Help Forums Sub-1 GHz forum - Sub-1 GHz - TI E2E support forums Shawn Hymel's FPGA Tutorials using ice40 and open source tools GitHub - ShawnHymel/introduction-to-fpga Github More info on WebAssembly WebAssembly","keywords":"RP2040 Installer Raspberry Pi Pico Installer Sub-GHz Help Forums Texas Instruments FPGA Tutorials iCE40 FPGA Open Source FPGA Tools WebAssembly Resources","version":"Next"},{"title":"Learn UART","type":0,"sectionRef":"#","url":"/helpful-links/learn-uart/","content":"","keywords":"UART Introduction RP2040 UART Tutorial UART Communication RP2040 Video Guide UART Deep Dive","version":"Next"},{"title":"Watch this introduction video:‚Äã","type":1,"pageTitle":"Learn UART","url":"/helpful-links/learn-uart/#watch-this-introduction-video","content":"           ","version":"Next","tagName":"h3"},{"title":"Do a deep dive with the rp2040 UART‚Äã","type":1,"pageTitle":"Learn UART","url":"/helpful-links/learn-uart/#do-a-deep-dive-with-the-rp2040-uart","content":"  ","version":"Next","tagName":"h3"},{"title":"FPGA Programming","type":0,"sectionRef":"#","url":"/hardware-low-level-details/ice40-fpga/fpga-programming/","content":"FPGA Programming The ice40 FPGA is a SRAM configured FPGA that is programmed automatically at power up. By default the ice40 reads a default configuration from its OTP memory. This default image allows basic pass through configuration of the RP2040 gpio to the IO drivers. Because of the SRAM configuration, the FPGA can be reprogrammed unlimted times at anytime by the RP2040 chip. To do this the RP2040 uses the the FPGA DONE, FPGA RESET and SPI interface from the RP2040. The ice40 documentation calls this the &quot;SPI Slave Configuration Interface&quot;. This method of programming is described in the Lattice ICE40 document &quot;iCE40 Programming and Configuration&quot; with document number FPGA-TN-02001. When reprogramming the FPGA the bit file would be fed from the RP2040. An obvious place to store the bit file is RP2040 flash as a const byte array. The Intrepid IO app can store multiple FPGA bit files in its file system and load them on command or at startup. It can also load them directly from USB.","keywords":"iCE40 FPGA Programming FPGA SRAM Configuration RP2040 FPGA Reprogramming SPI Slave Configuration Interface Intrepid IO App FPGA Management FPGA Bit Files Storage","version":"Next"},{"title":"Scripting","type":0,"sectionRef":"#","url":"/scripting/","content":"","keywords":"FREE-WILi scripting FREE-WILi CLI FREE-WILi Python library FREE-WILi Rust examples FREE-WILi WebAssembly FREE-WILi Wasm FREE-WILi GUI control FREE-WILi radios FREE-WILi automation FREE-WILi command line interface","version":"Next"},{"title":"Available Options‚Äã","type":1,"pageTitle":"Scripting","url":"/scripting/#available-options","content":" IO App ‚Äì Serial Command Line Interface Access FREE-WILi devices through a lightweight serial command line interface. GUI: Screen, Buttons, and Lights Control devices via a graphical interface with screen, buttons, and indicator lights. Radios Documentation on configuring and using FREE-WILi radios. Python Library and Examples Install and explore Freewili‚Äôs Python library with example code. WebAssembly (Wasm) Examples Learn how to run FREE-WILi functionality in the browser with WebAssembly. Rust Examples and Video Explore Freewili‚Äôs Rust integration with sample code and video tutorials.    ‚ú® Start with the method that matches your workflow ‚Äî from quick CLI scripting to advanced Rust or Wasm development. ","version":"Next","tagName":"h2"},{"title":"WILEYE Getting Started Guide","type":0,"sectionRef":"#","url":"/extending-with-orcas/wileye-camera-orca/wileye-getting-started/","content":"","keywords":"WILEYE getting started FREE-WILi integration camera setup UART configuration command line interface FREE-WILi UI WebAssembly API","version":"Next"},{"title":"What You'll Accomplish‚Äã","type":1,"pageTitle":"WILEYE Getting Started Guide","url":"/extending-with-orcas/wileye-camera-orca/wileye-getting-started/#what-youll-accomplish","content":" By the end of this guide, you'll have:  ‚úÖ Communication enabled between FREE-WILi and WILEYE‚úÖ UART parameters configured correctly‚úÖ Command line access to camera functions‚úÖ FREE-WILi UI integration for camera control‚úÖ WebAssembly API access for advanced programming  ","version":"Next","tagName":"h2"},{"title":"Prerequisites‚Äã","type":1,"pageTitle":"WILEYE Getting Started Guide","url":"/extending-with-orcas/wileye-camera-orca/wileye-getting-started/#prerequisites","content":" Before starting, make sure you have:  WILEYE Camera Orca properly connected to FREE-WILi (see Hardware Hookup)USB-C cable for programming and powerComputer with Python installedLatest WILEYE firmware files downloaded from the official repository: https://github.com/freewili/WILEye-FirmwareFREE-WILi device powered on and accessibleUART Orca Communication enabled for WILEYE (see Step 1 below)  ","version":"Next","tagName":"h2"},{"title":"ESP32-P4-EYE Documentation‚Äã","type":1,"pageTitle":"WILEYE Getting Started Guide","url":"/extending-with-orcas/wileye-camera-orca/wileye-getting-started/#esp32-p4-eye-documentation","content":" The WILEYE Camera Orca is built around the ESP32-P4-EYE development board. For detailed technical information about the hardware platform, refer to:  üìñ ESP32-P4-EYE Official Documentation: https://docs.espressif.com/projects/esp-dev-kits/en/latest/esp32p4/esp32-p4-eye/index.html  This documentation includes:  Complete hardware specifications and pin mappingsCamera sensor configuration detailsPower requirements and electrical characteristicsAdvanced programming examples and API references  UART Communication Required CRITICAL: You must enable UART Orca Communication for WILEYE in FREE-WILi settings before the camera will function. WILEYE will not work without this setting properly configured.  Getting WILEYE Firmware Always download the latest firmware binary files from the official repository:https://github.com/freewili/WILEye-Firmware This repository contains the pre-compiled binary files needed to update your ESP32-P4-EYE firmware. Download the .bin files for flashing to your WILEYE module.    ","version":"Next","tagName":"h3"},{"title":"Step 1: Enable UART Orca Communication‚Äã","type":1,"pageTitle":"WILEYE Getting Started Guide","url":"/extending-with-orcas/wileye-camera-orca/wileye-getting-started/#step-1-enable-uart-orca-communication","content":" Before flashing firmware or using WILEYE, you must first enable UART Orca Communication in FREE-WILi settings.  ","version":"Next","tagName":"h2"},{"title":"Accessing Orca Setup Settings‚Äã","type":1,"pageTitle":"WILEYE Getting Started Guide","url":"/extending-with-orcas/wileye-camera-orca/wileye-getting-started/#accessing-orca-setup-settings","content":" Connect to FREE-WILi via USB console or web interfaceNavigate to Settings menu from main consoleFind Orca Setup section in settingsAccess Configure Orca Communication option  ","version":"Next","tagName":"h3"},{"title":"Configure UART Communication‚Äã","type":1,"pageTitle":"WILEYE Getting Started Guide","url":"/extending-with-orcas/wileye-camera-orca/wileye-getting-started/#configure-uart-communication","content":" In the Orca Setup menu, you'll see:  ======== Configure Orca Communication ======== u) Orca Communication over UART [WILEye] Enter Letter: (q to exit)   Press 'u' to configure UART communicationSelect WILEYE option from the menu:  ======== Configure Orca Communication ======== 0) Off 1) BottleNose 2) WhaleTail 3) WILEye Orca Communication over UART Enter Number [3]   Enter '3' to select WILEye (this should be the default)Save settings and exit configuration menu  ","version":"Next","tagName":"h3"},{"title":"Verify Configuration‚Äã","type":1,"pageTitle":"WILEYE Getting Started Guide","url":"/extending-with-orcas/wileye-camera-orca/wileye-getting-started/#verify-configuration","content":" After confirming UART communication is set to WILEye:  ======== Configure Orca Communication ======== u) Orca Communication over UART [WILEye] ‚úÖ   The setting should show [WILEye] for proper camera operation.  UART Parameters Auto-Configuration When you enable WILEYE Communication in Orca Setup, FREE-WILi automatically configures the required UART parameters: Baud Rate: 5 MbpsFlow Control: CTS and RTS enabled (Hardware flow control)Data Bits: 8Stop Bits: 1Parity: None Hardware flow control ensures reliable high-speed data transmission between FREE-WILi and WILEYE, preventing data loss during image and video transfers.  ","version":"Next","tagName":"h3"},{"title":"Restart FREE-WILi‚Äã","type":1,"pageTitle":"WILEYE Getting Started Guide","url":"/extending-with-orcas/wileye-camera-orca/wileye-getting-started/#restart-free-wili","content":" After confirming the UART communication setting:  Power cycle FREE-WILi to ensure configuration is activeWait for full boot before proceeding with firmware flashingVerify WILEYE detection in FREE-WILi status messages    ","version":"Next","tagName":"h3"},{"title":"Step 2: Install ESPTool and Flash Firmware‚Äã","type":1,"pageTitle":"WILEYE Getting Started Guide","url":"/extending-with-orcas/wileye-camera-orca/wileye-getting-started/#step-2-install-esptool-and-flash-firmware","content":" Before you can use WILEYE with FREE-WILi, you need to flash the proper firmware to the ESP32-P4-EYE module.  ","version":"Next","tagName":"h2"},{"title":"Install ESPTool‚Äã","type":1,"pageTitle":"WILEYE Getting Started Guide","url":"/extending-with-orcas/wileye-camera-orca/wileye-getting-started/#install-esptool","content":" First, install the ESPTool utility which is required for flashing ESP32 devices:  Windows/Mac/Linux - Using pip‚Äã  # Install esptool using pip (recommended) pip install esptool # Verify installation esptool.py --help   Alternative Installation Methods‚Äã  Windows - Using executable:  Download esptool.exe from GitHub releasesPlace it in a folder in your PATHUse esptool.exe instead of python esptool.py in commands  Linux - Using package manager:  # Ubuntu/Debian sudo apt install esptool # Fedora sudo dnf install esptool   ","version":"Next","tagName":"h3"},{"title":"Download WILEYE Firmware‚Äã","type":1,"pageTitle":"WILEYE Getting Started Guide","url":"/extending-with-orcas/wileye-camera-orca/wileye-getting-started/#download-wileye-firmware","content":" Download the latest firmware binary files from the official repository:  üîó https://github.com/freewili/WILEye-Firmware  Navigate to the GitHub repository and download the latest release or binary files Look for the pre-compiled binary files (.bin files) needed for ESP32-P4-EYE: bootloader.bin - ESP32-P4 bootloaderwileye-firmware.bin (or factory_demo.bin) - Main WILEYE application firmwarepartition-table.bin - Memory partition configuration Create a firmware folder on your computer and place all binary files inside: wileye-firmware/ ‚îú‚îÄ‚îÄ bootloader.bin ‚îú‚îÄ‚îÄ wileye-firmware.bin ‚îî‚îÄ‚îÄ partition-table.bin   Official Firmware Source Always use the official firmware repository: https://github.com/freewili/WILEye-Firmware This ensures you have the latest, tested firmware binaries specifically compiled for the ESP32-P4-EYE on WILEYE Camera Orca. The repository contains pre-built .bin files - no compilation required. For advanced users who want to modify or build custom firmware, refer to the ESP32-P4-EYE hardware documentation: https://docs.espressif.com/projects/esp-dev-kits/en/latest/esp32p4/esp32-p4-eye/index.html  ","version":"Next","tagName":"h3"},{"title":"Connect WILEYE for Programming‚Äã","type":1,"pageTitle":"WILEYE Getting Started Guide","url":"/extending-with-orcas/wileye-camera-orca/wileye-getting-started/#connect-wileye-for-programming","content":" Connect USB-C cable from your computer to the WILEYE Camera Orca Hold the BOOT button on the ESP32-P4-EYE while connecting USB (if available) Check device connection: Windows: # Check if device is detected esptool.py --list-ports # Look for something like: COM12 - USB Serial Device Mac: # Check available ports ls /dev/tty.usb* # Should show: /dev/tty.usbserial-xxxxx Linux: # Check available ports ls /dev/ttyUSB* # Should show: /dev/ttyUSB0 (or similar) Note your COM port - you'll need this for the flashing command (e.g., COM12, /dev/ttyUSB0)  ","version":"Next","tagName":"h3"},{"title":"Flash the Firmware‚Äã","type":1,"pageTitle":"WILEYE Getting Started Guide","url":"/extending-with-orcas/wileye-camera-orca/wileye-getting-started/#flash-the-firmware","content":" Navigate to your firmware folder in the command prompt/terminal and run the flashing command:  Windows Example:‚Äã  cd C:\\path\\to\\wileye-firmware python esptool.py -p COM12 -b 460800 --before default_reset --after hard_reset --chip esp32p4 write_flash --flash_mode dio --flash_freq 80m --flash_size 16MB 0x2000 bootloader.bin 0x10000 factory_demo.bin 0x8000 partition-table.bin   Mac/Linux Example:‚Äã  cd /path/to/wileye-firmware python esptool.py -p /dev/ttyUSB0 -b 460800 --before default_reset --after hard_reset --chip esp32p4 write_flash --flash_mode dio --flash_freq 80m --flash_size 16MB 0x2000 bootloader.bin 0x10000 factory_demo.bin 0x8000 partition-table.bin   ","version":"Next","tagName":"h3"},{"title":"Expected Output‚Äã","type":1,"pageTitle":"WILEYE Getting Started Guide","url":"/extending-with-orcas/wileye-camera-orca/wileye-getting-started/#expected-output","content":" You should see output similar to this:  esptool.py v4.6 Serial port COM12 Connecting..... Chip is ESP32-P4 (revision v0.1) Features: WiFi, BT, Dual Core, 400MHz, VRef calibration in efuse, Coding Scheme None Crystal is 40MHz MAC: 24:6f:28:xx:xx:xx Uploading stub... Running stub... Stub running... Changing baud rate to 460800 Changed. Configuring flash size... Flash will be erased from 0x00002000 to 0x00005fff... Flash will be erased from 0x00010000 to 0x001fffff... Flash will be erased from 0x00008000 to 0x00008fff... Compressed 15856 bytes to 9976... Wrote 15856 bytes (9976 compressed) at 0x00002000 in 0.4 seconds... Hash of data verified. Compressed 2027520 bytes to 1285632... Wrote 2027520 bytes (1285632 compressed) at 0x00010000 in 31.5 seconds... Hash of data verified. Compressed 3072 bytes to 136... Wrote 3072 bytes (136 compressed) at 0x00008000 in 0.1 seconds... Hash of data verified. Leaving... Hard resetting via RTS pin...   ","version":"Next","tagName":"h3"},{"title":"Troubleshooting Firmware Flash‚Äã","type":1,"pageTitle":"WILEYE Getting Started Guide","url":"/extending-with-orcas/wileye-camera-orca/wileye-getting-started/#troubleshooting-firmware-flash","content":" Common Issues and Solutions‚Äã  Problem: &quot;Failed to connect to ESP32&quot;  # Solution 1: Try different baud rate python esptool.py -p COM12 -b 115200 --chip esp32p4 chip_id # Solution 2: Hold BOOT button while connecting USB # Then release after connection is established # Solution 3: Try different USB cable or port   Problem: &quot;Invalid head of packet (0x50)&quot;  # Solution: Reset the device and try again python esptool.py -p COM12 --chip esp32p4 --before default_reset chip_id   Problem: &quot;File not found&quot; errors  # Make sure you're in the correct directory pwd # Check current directory ls # List files (Linux/Mac) dir # List files (Windows) # Files should be in current directory: # bootloader.bin, factory_demo.bin, partition-table.bin   Problem: Flash verification failed  # Try slower baud rate python esptool.py -p COM12 -b 115200 ... (rest of command) # Or erase flash first python esptool.py -p COM12 --chip esp32p4 erase_flash # Then try flashing again   ","version":"Next","tagName":"h3"},{"title":"Verify Firmware Installation‚Äã","type":1,"pageTitle":"WILEYE Getting Started Guide","url":"/extending-with-orcas/wileye-camera-orca/wileye-getting-started/#verify-firmware-installation","content":" After successful flashing:  Disconnect and reconnect the USB cableCheck serial output (optional): # Monitor serial output to verify firmware is running python -m serial.tools.miniterm COM12 115200 You should see WILEYE firmware startup messages.    ","version":"Next","tagName":"h3"},{"title":"Step 3: Enable WILEYE Communication in Settings‚Äã","type":1,"pageTitle":"WILEYE Getting Started Guide","url":"/extending-with-orcas/wileye-camera-orca/wileye-getting-started/#step-3-enable-wileye-communication-in-settings","content":" The first step is to enable communication between FREE-WILi and the WILEYE Camera Orca through the settings interface.  ","version":"Next","tagName":"h2"},{"title":"Accessing Settings‚Äã","type":1,"pageTitle":"WILEYE Getting Started Guide","url":"/extending-with-orcas/wileye-camera-orca/wileye-getting-started/#accessing-settings","content":" Connect to FREE-WILi: Via USB: Connect your computer to FREE-WILi using a USB cableVia Network: Ensure your computer and FREE-WILi are on the same network Open FREE-WILi Interface: Launch the FREE-WILi application on your computerOr access the web interface through your browser Navigate to Settings: Click on the Settings menuSelect Orca Setup from the dropdown  ","version":"Next","tagName":"h3"},{"title":"Enabling WILEYE Communication‚Äã","type":1,"pageTitle":"WILEYE Getting Started Guide","url":"/extending-with-orcas/wileye-camera-orca/wileye-getting-started/#enabling-wileye-communication","content":" Locate WILEYE Option: Settings ‚Üí Orca Setup ‚Üí WILEYE Communication Enable the Setting: Toggle &quot;Enable WILEYE Communication&quot; to ONYou should see a confirmation message: &quot;WILEYE Communication Enabled&quot; Apply Settings: Click &quot;Apply&quot; or &quot;Save Settings&quot;FREE-WILi will automatically configure the required parameters  Automatic Configuration When you enable WILEYE Communication, FREE-WILi automatically sets the correct UART parameters, so you don't need to configure them manually!    ","version":"Next","tagName":"h3"},{"title":"Step 4: Understanding UART Parameters‚Äã","type":1,"pageTitle":"WILEYE Getting Started Guide","url":"/extending-with-orcas/wileye-camera-orca/wileye-getting-started/#step-4-understanding-uart-parameters","content":" FREE-WILi automatically configures these UART parameters when WILEYE Communication is enabled:  ","version":"Next","tagName":"h2"},{"title":"Automatic UART Configuration‚Äã","type":1,"pageTitle":"WILEYE Getting Started Guide","url":"/extending-with-orcas/wileye-camera-orca/wileye-getting-started/#automatic-uart-configuration","content":" Parameter\tValue\tDescriptionBaud Rate\t5,000,000 bps (5 Mbps)\tHigh-speed communication for image/video data Data Bits\t8\tStandard data frame size Stop Bits\t1\tSingle stop bit for efficiency Parity\tNone\tNo parity checking Flow Control\tRTS/CTS\tHardware flow control enabled  ","version":"Next","tagName":"h3"},{"title":"UART Pin Mapping‚Äã","type":1,"pageTitle":"WILEYE Getting Started Guide","url":"/extending-with-orcas/wileye-camera-orca/wileye-getting-started/#uart-pin-mapping","content":" The hardware connection uses these pins (automatically configured):  Signal\tESP32-P4-EYE Pin\tFREE-WILi Pin\tDirectionTX\tGPIO37\tUART1_RX_IN\tESP32 ‚Üí FREE-WILi RX\tGPIO38\tUART1_TX_Out\tFREE-WILi ‚Üí ESP32 RTS\tGPIO51\tUART1_CTS_IN\tFlow Control CTS\tGPIO34\tUART1_RTS_OUT\tFlow Control    ","version":"Next","tagName":"h3"},{"title":"Next Steps‚Äã","type":1,"pageTitle":"WILEYE Getting Started Guide","url":"/extending-with-orcas/wileye-camera-orca/wileye-getting-started/#next-steps","content":" Now that your WILEYE Camera Orca is set up and working:  ","version":"Next","tagName":"h2"},{"title":"Immediate Projects‚Äã","type":1,"pageTitle":"WILEYE Getting Started Guide","url":"/extending-with-orcas/wileye-camera-orca/wileye-getting-started/#immediate-projects","content":" Time-lapse Photography: Set up automated captures at intervalsMotion Detection: Use API to detect movement and trigger recordingRemote Monitoring: Access camera through FREE-WILi's web interfaceCustom Applications: Build your own camera control software using the WASM API  ","version":"Next","tagName":"h3"},{"title":"Advanced Integration‚Äã","type":1,"pageTitle":"WILEYE Getting Started Guide","url":"/extending-with-orcas/wileye-camera-orca/wileye-getting-started/#advanced-integration","content":" IoT Integration: Connect camera data to cloud servicesAI Processing: Implement image recognition on captured photosAutomation: Trigger camera based on sensor inputsMulti-camera Setup: Coordinate multiple WILEYE modules  ","version":"Next","tagName":"h3"},{"title":"Learning Resources‚Äã","type":1,"pageTitle":"WILEYE Getting Started Guide","url":"/extending-with-orcas/wileye-camera-orca/wileye-getting-started/#learning-resources","content":" WILEYE Hardware Hookup - Physical setup and connectionsMain WILEYE Documentation - Complete feature overviewESP32-P4-EYE Official Documentation - Hardware platform detailsESP32-P4-EYE GitHub Repository - Hardware files and examplesEspressif ESP-IDF Programming Guide - Advanced ESP32-P4 programming  ","version":"Next","tagName":"h3"},{"title":"Community and Support‚Äã","type":1,"pageTitle":"WILEYE Getting Started Guide","url":"/extending-with-orcas/wileye-camera-orca/wileye-getting-started/#community-and-support","content":" FREE-WILi Forum: Share your camera projects and get helpGitHub Examples: Find sample code and contribute improvementsDiscord Community: Real-time chat with other usersDocumentation: Keep checking for updates and new features  Congratulations! Your WILEYE Camera Orca is now fully integrated with FREE-WILi and ready for your projects! üì∏ ","version":"Next","tagName":"h2"},{"title":"About App","type":0,"sectionRef":"#","url":"/scripting/gui-screen-buttons-and-lights/about-app/","content":"About App The FREE-WILi has an about app the contains screens about the device. The main about screen includes information about the version of firmware running on the main and display processors. It also includes loop times which are just an idea of how fast the FREE-WILi IO app and GUI app are running. The clr button will reset these maximum times. The about app also include screens for RTC and Battery Charging, these are described in the relative topics. The about screen includes version information, loop times and documentation links.","keywords":"FREE-WILi About App firmware version loop times device monitoring RTC battery charging FreeWili IO GUI app documentation links","version":"Next"},{"title":"FREE-WILi Overview","type":0,"sectionRef":"#","url":"/intro/","content":"","keywords":"freewili freewili documentation free-wili documentation FREE-WILi free-wili embedded systems development tool electronic systems debugging testing I2C SPI UART","version":"Next"},{"title":"Overview‚Äã","type":1,"pageTitle":"FREE-WILi Overview","url":"/intro/#overview","content":" FREE-WILi Overview  FREE-WILi is a embedded development tool for helping test, debug, and develop electronic systems.  ","version":"Next","tagName":"h2"},{"title":"Use Cases‚Äã","type":1,"pageTitle":"FREE-WILi Overview","url":"/intro/#use-cases","content":" I2C USB interfaceSPI USB interfaceUART USB interfaceGeneric Digital Protocol development (script protocol)USB attached screen and buttons Uart based protocol tool supportTPMS fuzzer or simulatorKeyless Entry simulator/monitorCybersecurity penetration testingDevelopment platform that 80% doneLearning platform for Embedded Systems CPU, FPGA or Hybrid  ","version":"Next","tagName":"h2"},{"title":"Software Features‚Äã","type":1,"pageTitle":"FREE-WILi Overview","url":"/intro/#software-features","content":" USB Serial console API to control from host PC without installing any softwareWASM (webassembly) scripting engine with examples for C/C++, Rust, Zig and Tiny GoHost API Python softwareFAT File systemSigrok Pulse view Logic Analyzer supporthost binary API for Graphical User InterfaceWASM API to control all device featuresZoomIO scripting engine controls IO pins with nanosecond precisionGUI Software with custom panels and graphical controlsIntegrated sounds and images in ROM for enhancing user appsNumbers To Speech feature to speak numbersFile formats compatible with existing market devicesStandard USB boot-loader for firmware updatesRaspberry Pi Pico (RP2040) Open Micro Platform for specific applications or custom code with C/C++, Micro-python or Circuit Python  ","version":"Next","tagName":"h2"},{"title":"Hardware Features‚Äã","type":1,"pageTitle":"FREE-WILi Overview","url":"/intro/#hardware-features","content":" SPI, I2C, PIO, and UART available on GPIO3 USB interfaces (Integrated HUB with 2 FS, 1 HS) for communication and power11 GPIO programmable voltage level for 1.1 to 5.5V with 24ma@3V or 32ma @5v (sn74lxc1t45)2 GPIO for I2C voltage level between 0.9V to 5.5V with software enabled 10K pulls (PCA9517)GPIO front end includes ICE40UP5k FPGA with 8MByte SRAM and High Speed USB (FT232H)Two SMA connectors for antenna for longer range320 x 240 Color Display5 User configurable buttons7 Full color LEDsIR transmitter and receiverDigital Speaker and Microphone Orca modules plug into GPIO header allows expansion for specific use cases 16 Mbyte x 2 on board storage (22 MByte usable)1000 ma Lithium ION battery with integrated chargerReal Time Clock (RTC)Accelerometer  ","version":"Next","tagName":"h2"},{"title":"Radio Versions‚Äã","type":1,"pageTitle":"FREE-WILi Overview","url":"/intro/#radio-versions","content":" FREE-WILi contains two radios.  FREE-WILi currently has one radio option:  Black contains two CC1101 Sub Ghz Radios with programmable filter ranges for 300-348, 387-464, 779-928 bands. ","version":"Next","tagName":"h2"},{"title":"GUI : Screen, Buttons, and Lights","type":0,"sectionRef":"#","url":"/scripting/gui-screen-buttons-and-lights/","content":"GUI : Screen, Buttons, and Lights The FREE-WILi has a user interface that makes interacting with the device use-able without a host PC. The user interface is controlled by a separate CPU and interfaces with the main CPU via a 8 Megabit hardware handshaking UART. Fw Display LEDs, and buttons The core parts of the user interface are listed below: Description\tNotesColor Display\t320 x 240 16 bit color screen with GUI library\tmore information Buttons\t5 Multi color buttons\tmore information Full Color LEDs\t7 full color LEDs\tmore information Speaker\t16 bit audio\tmore information Microphone more information InfrRed Receiver\tReception of IR remote data\tmore information Infrared Transmitter\tTransmission of IR remote data\tmore information Real Time Clock\tTime and date powered from Lith ION battery\tmore information Lithium ION Battery Manager\tControls the Lith-ION battery\tmore information Accelerometer\tUsed as sensor for custom applications\tmore information","keywords":"FREE-WILi user interface color display multi-color buttons LEDs speaker microphone IR receiver IR transmitter real-time clock lithium-ion battery manager accelerometer","version":"Next"},{"title":"Capturing Audio from Microphone","type":0,"sectionRef":"#","url":"/scripting/gui-screen-buttons-and-lights/capturing-audio-from-microphone/","content":"","keywords":"FREE-WILi microphone audio recording 8000 Hz FFT algorithm GUI API WAV file audio capture recording settings","version":"Next"},{"title":"Sensors App Microphone View‚Äã","type":1,"pageTitle":"Capturing Audio from Microphone","url":"/scripting/gui-screen-buttons-and-lights/capturing-audio-from-microphone/#sensors-app-microphone-view","content":" The sensors app has a microphone shown above. This view also you to record a wave file and play it back. The virtual LED shows if the sound quiet threshold was exceeded. Also, the LED light show indicates sound level.  ","version":"Next","tagName":"h2"},{"title":"Settings‚Äã","type":1,"pageTitle":"Capturing Audio from Microphone","url":"/scripting/gui-screen-buttons-and-lights/capturing-audio-from-microphone/#settings","content":" The recording time and volume level can be configured in the settings serial menu. This menu can also set a threshold to determine if the noise level is loud to indicate sound is present. This can be used to trigger device actions like waking up the screen. The record volume can also be set. 5 is the default volume.    ","version":"Next","tagName":"h2"},{"title":"API‚Äã","type":1,"pageTitle":"Capturing Audio from Microphone","url":"/scripting/gui-screen-buttons-and-lights/capturing-audio-from-microphone/#api","content":" You can record sounds using the API from wasm. The recordSound API allows you to record a sound to the file system for a specific length of time.  The setAudioSettings will stream the microphone or fft result to the wasm script engine as events. You can also put the mic sound level and/or fft data into a plot data store.  void recordSound(char * szSoundPath, int iLengthSeconds); void setAudioSettings(bool bStreamMic, bool bStreamFFT, bool bEnableMicPlotData, int iMICPlotDataIndex, bool bEnableFFTPlotData, int iFFTPlotDataIndex);   ","version":"Next","tagName":"h2"},{"title":"Technical Details‚Äã","type":1,"pageTitle":"Capturing Audio from Microphone","url":"/scripting/gui-screen-buttons-and-lights/capturing-audio-from-microphone/#technical-details","content":" The format of the wave file is compatible with the sound playback allowing you to play recorded sounds. ","version":"Next","tagName":"h2"},{"title":"GUI API Basics","type":0,"sectionRef":"#","url":"/scripting/gui-screen-buttons-and-lights/gui-api-basics/","content":"GUI API Basics The GUI API allows you to control all of the screen from a C API. This API is a binary API but there is an integrated wrapper for wasm. This wrapper allows everything on the display processor and GUI system to be controlled. In fact this is the API that all the apps in the FREE-WILi use. The API consists of C calls which control an element of the GUI or GUI processor. There are APIs to build a panel of controls similar to GUI development on desktop OS systems. Then there are APIs which provide access to the sensors. The API uses C function calls and events. The C functions have no return values. If the C function needs to return data it is supplied via an event. The event data goes into a queue and these are read at will by an App. The API supports logging text data through a global Log. There are current 4 global logs and these can be attached to a Log/List control to display by an Index. Similiary, the plot works the same way. Data can be added to a plot global object and then the plot control can display the data.","keywords":"FREE-WILi GUI API C API wasm wrapper display control sensor access event handling global logs GUI development","version":"Next"},{"title":"Color Display Widgets","type":0,"sectionRef":"#","url":"/scripting/gui-screen-buttons-and-lights/color-display-widgets/","content":"","keywords":"FREE-WILi color display widgets API LED image widget log list plot text control number control bargraph button control properties control data","version":"Next"},{"title":"Properties for Controls‚Äã","type":1,"pageTitle":"Color Display Widgets","url":"/scripting/gui-screen-buttons-and-lights/color-display-widgets/#properties-for-controls","content":" The table below lists the APIs properties for the controls  API\tDescription\tsetControlValueMinMax\tsets min max property of control in int32 setControlValueMinMaxF\tsets min max property of control in float32 setControlProperty\tSets the a property of a control.\tNot in wasm yet setPlotData\tSets color of plot\tNot implemented in wasm yet. Sets colors of plots  ","version":"Next","tagName":"h2"},{"title":"Data for the Controls‚Äã","type":1,"pageTitle":"Color Display Widgets","url":"/scripting/gui-screen-buttons-and-lights/color-display-widgets/#data-for-the-controls","content":" The table below lists the APIs for the data in the control.  API\tDescription\tNotessetListItemText\tsets a log text when implementing list mode\tMake sure to have a valid list index setListItemSelected\tsets the selected item in the list setListItemTopIndex\tset the top item in the list clearLogOrPlotData\tclears a log or plot buffer addControlPlotData\tadds data to a plot buffer setLogDataText\tadds test to the list setControlValue\tsets the value of the control in int32 setControlValueFloat\tsets the value of teh control in float32\t ","version":"Next","tagName":"h2"},{"title":"Displaying Images","type":0,"sectionRef":"#","url":"/scripting/gui-screen-buttons-and-lights/displaying-images/","content":"","keywords":"FREE-WILi displaying images image display custom images API integration FWI format image conversion 565 color format ROM images image processing","version":"Next"},{"title":"Converting Images to FWI Format‚Äã","type":1,"pageTitle":"Displaying Images","url":"/scripting/gui-screen-buttons-and-lights/displaying-images/#converting-images-to-fwi-format","content":" Custom images must be converted to the FREE-WILi Image (FWI) format, which is a bitmap compatible with the 565 color display used. This direct compatibility allows fast display of images without runtime conversion.  There are two ways to convert your images:  1. Use the Web-Based PNG to FWI Converter  Easily convert your .png files using our online tool: üëâ https://freewili.com/png-to-fwi-converter/  2. Use the Python Script (fw_image.py)  A Python script named fw_image.py is available on the FREE-WILi GitHub. It allows you to convert .jpg or .png images into .fwi files.  Syntax of fw_image.py:  python3 fw_image.py source_image.png output_image.fwi  ","version":"Next","tagName":"h3"},{"title":"Displaying Images from the ROM‚Äã","type":1,"pageTitle":"Displaying Images","url":"/scripting/gui-screen-buttons-and-lights/displaying-images/#displaying-images-from-the-rom","content":" The FREE-WILi ROM contains a number of images you can use for your own applications. The following file lists the ROM images available.    FwRomAssets.pdf pdf  ","version":"Next","tagName":"h2"},{"title":"Displaying Images from the API‚Äã","type":1,"pageTitle":"Displaying Images","url":"/scripting/gui-screen-buttons-and-lights/displaying-images/#displaying-images-from-the-api","content":" The GUIAPI has a function for displaying images from files or ROM. Here we display cookie.fwi in the images directory.  obGUIAPI.addControlPictureFromFile(iPanelNumber,PANEL_PICTURE_COOKIE,20,160,&quot;cookie&quot;,1 );  Cookie.fwi shown on FREE-WILi screen.  To Display from ROM you can use this API  void addControlPicture(int iPanelIndex, int iControlIndex, int iX, int iY, int iPictureId, int iVisible)   ","version":"Next","tagName":"h2"},{"title":"Structure of Image File‚Äã","type":1,"pageTitle":"Displaying Images","url":"/scripting/gui-screen-buttons-and-lights/displaying-images/#structure-of-image-file","content":" The file consists of a binary header describing the file and the pixels. The pixels are stored in 16 bit 565 format. The 565 16 bit color format is a common format in embedded systems. There are a number of resources online that discuss this format. The best way to understand the format is to review the source code of fw_image.py  ","version":"Next","tagName":"h2"},{"title":"Binary Header‚Äã","type":1,"pageTitle":"Displaying Images","url":"/scripting/gui-screen-buttons-and-lights/displaying-images/#binary-header","content":" The beginning of the file is below. Ints are 32 bit here and shorts are 16 bit.  char szOut[8] = { &quot;FW01IMG&quot; }; unsigned int iImageFlags; unsigned int iImageTotalPixelCount; unsigned short iImageWidth; unsigned short iImageHeight; unsigned short iImageTransparentColor; unsigned short iImageId;   ","version":"Next","tagName":"h2"},{"title":"Pixel Data‚Äã","type":1,"pageTitle":"Displaying Images","url":"/scripting/gui-screen-buttons-and-lights/displaying-images/#pixel-data","content":" The pixel data is described below. A 16 bit unsigned short contains the pixel with varying intensities for Red, Green, and Blue. The final value is byte swapped.  rgb = (int(R)&lt;&lt;11) | (int(G)&lt;&lt;5) | int(B) rgb = ((rgb &lt;&lt; 8) &amp; 0xFF00) | ((rgb &gt;&gt; 8) &amp; 0xFF); ","version":"Next","tagName":"h2"},{"title":"IR (Infrared) Devices","type":0,"sectionRef":"#","url":"/scripting/gui-screen-buttons-and-lights/ir-infrared-devices/","content":"","keywords":"FREE-WILi IR devices infrared receiver infrared transmitter IR control NEC protocol custom remote Roku remote IR Hacker app IR API remote learning","version":"Next"},{"title":"IR App‚Äã","type":1,"pageTitle":"IR (Infrared) Devices","url":"/scripting/gui-screen-buttons-and-lights/ir-infrared-devices/#ir-app","content":" There is an IR app (called ‚ÄúIR‚Äù in the main menu) which contains two screens. The first screen is the IR Hacker, and The second IR screen is for the Roku remote and custom remote controllers.  ","version":"Next","tagName":"h2"},{"title":"IR Hacker‚Äã","type":1,"pageTitle":"IR (Infrared) Devices","url":"/scripting/gui-screen-buttons-and-lights/ir-infrared-devices/#ir-hacker","content":" The IR Hacker allows a user to send and receive NEC IR messages. Messages sent or received in rapid succession have their first code shown in yellow, while subsequent codes are shown in white. The first code is also shown in the upper-right corner of the screen.  The IR Hacker app can sniff and send NEC IR data  The bottom of the screen shows the functions of each of the five buttons. The ‚Äúnext‚Äù button opens the remote control screen. The ‚Äúsend‚Äù button allows a user to enter an arbitrary 4-byte code to send via a NEC IR message frame. The ‚Äúplay‚Äù button replays a log of all IR messages received, and then clears that log. The ‚Äúlast‚Äù button plays the IR code shown in the upper-right corner of the screen. The ‚Äúclr‚Äù button clears the log of IR messages.  Holding down the ‚Äúlast‚Äù button for 5 seconds activates the fuzz function. The fuzz function sends all 255 possible commands for the last IR Address received.  ","version":"Next","tagName":"h3"},{"title":"IR Remote‚Äã","type":1,"pageTitle":"IR (Infrared) Devices","url":"/scripting/gui-screen-buttons-and-lights/ir-infrared-devices/#ir-remote","content":" The IR Remote screen can be used to create and utilize custom remotes. Each remote is a database of IR commands, and is stored in the file system of the FREE-WILi.  Create custom remotes for IR devices with FREE-WILi  The IR Remote screen shows a list of available remotes. You can navigate the list of remotes with the ‚Äúup‚Äù and ‚Äúdown‚Äù buttons, and the ‚Äúselect‚Äù button is used to select a remote. The ‚Äúnew‚Äù button creates a new custom remote, and the ‚Äúmain‚Äù button returns to the main menu. There is already an integrated Roku remote on the FREE-WILi. A Roku remote can also be used to control a FREE-WILi.  After selecting a remote, you can add new codes. Codes can be added by sending the code with the remote the user wishes to emulate.  ","version":"Next","tagName":"h3"},{"title":"Roku Remote Control of FREE-WILi‚Äã","type":1,"pageTitle":"IR (Infrared) Devices","url":"/scripting/gui-screen-buttons-and-lights/ir-infrared-devices/#roku-remote-control-of-free-wili","content":" You can enable the Roku remote to control FREE-WILi. This feature can be enabled or disabled in the settings menu of the display processor. This works by receiving IR codes from a Roku remote (or another FREE-WILi) and simulating the actual button presses on the FREE-WILi.  Roku Button\tFREE-WILi Action\tNotesup\tGray Button press down\tYellow Button Press ok/select\tGreen Button Press left\tBlue Button Press right\tRed Button Press home\tReturns to main screen\t  ","version":"Next","tagName":"h2"},{"title":"API‚Äã","type":1,"pageTitle":"IR (Infrared) Devices","url":"/scripting/gui-screen-buttons-and-lights/ir-infrared-devices/#api","content":" There is an API for sending IR codes in NEC format. In addition, any IR command received appears as an event, so long as IR streaming is enabled in the IR Functions menu of the display processor.  // Send IR Data void sendIRData(unsigned int iData); // IR Event Decoding if (stEvents[iCount].iEvent == FWGUI_EVENT_IR_CODE) { unsigned int iIRCode; iIRCode = stEvents[iCount].btData[0]; iIRCode |= ((unsigned int)stEvents[iCount].btData[1]) &lt;&lt; 8; iIRCode |= ((unsigned int)stEvents[iCount].btData[2]) &lt;&lt; 16; iIRCode |= ((unsigned int)stEvents[iCount].btData[3]) &lt;&lt; 24; printf(&quot;%x &quot;,iIRCode); }   ","version":"Next","tagName":"h2"},{"title":"Sample Project: LG Remote‚Äã","type":1,"pageTitle":"IR (Infrared) Devices","url":"/scripting/gui-screen-buttons-and-lights/ir-infrared-devices/#sample-project-lg-remote","content":" Many household TV remotes use the NEC IR protocol. In this example, a LG remote‚Äôs IR signals are sniffed by the FREE-WILi so that an IR database can be created.  Sample Project: LG Remote  Once the IR codes from the remote are known, a WebAssembly (WASM) project can be developed. Using the new custom remote, another FREE-WILi can have IR streaming enabled, and have a WASM script monitor the IR codes received. Once received, the FREE-WILi can carry out arbitrary tasks. See the Scripting with WASM page for information about how to use WASM with FREE-WILi. If you only have access to one FREE-WILi, you can just use the LG remote to control the FREE-WILi with IR streaming enabled and a WASM script. ","version":"Next","tagName":"h2"},{"title":"Buttons","type":0,"sectionRef":"#","url":"/scripting/gui-screen-buttons-and-lights/buttons/","content":"","keywords":"FREE-WILi buttons button functions button API click simulation Roku Remote FWGUI events setPanelMenuText bootloader user interface controls","version":"Next"},{"title":"Button Fixed Functions‚Äã","type":1,"pageTitle":"Buttons","url":"/scripting/gui-screen-buttons-and-lights/buttons/#button-fixed-functions","content":" The gray button is hard wired to the battery controller. This will wake the device from a shutdown if held for two seconds.  The red button is hard wired to the BOOTSEL feature of the Main CPU. There on a power up this will be read to determine if the Main should stay in the bootloader.  The Blue button is used by the display to enter the boot-loader. This is done in software. So if the display processor enters bootloader it will not return to the main software until the battery is depleted or a valid UF2 file is flashed. The blue button will only enter bootloader on a long press on the main screen.  ","version":"Next","tagName":"h2"},{"title":"Roku Remote Click Simulation‚Äã","type":1,"pageTitle":"Buttons","url":"/scripting/gui-screen-buttons-and-lights/buttons/#roku-remote-click-simulation","content":" The Roku Remote can be enabled to simulate a click event on the 5 buttons. More information in the IR topic.  ","version":"Next","tagName":"h2"},{"title":"API‚Äã","type":1,"pageTitle":"Buttons","url":"/scripting/gui-screen-buttons-and-lights/buttons/#api","content":" The buttons are available though API through events. Also, you can enable a button menu through the setPanelMenuText API. Please note the panel must enable the panel menu.  // Set Menu panel text, A null string will clear it, must be enabled on panel void setPanelMenuText(int iPanel, int iButtonGreyFromZero, const char * szMessage); case FWGUI_EVENT_GRAY_BUTTON: return &quot;graybutton&quot;; case FWGUI_EVENT_YELLOW_BUTTON: return &quot;yellowbutton&quot;; case FWGUI_EVENT_GREEN_BUTTON: return &quot;greenbutton&quot;; case FWGUI_EVENT_BLUE_BUTTON: return &quot;bluebutton&quot;; case FWGUI_EVENT_RED_BUTTON: return &quot;redbutton&quot;; printf(&quot;event %s &quot;, getEventName(stEvents[iCount].iEvent)); if (stEvents[iCount].iEvent &gt;= FWGUI_EVENT_GRAY_BUTTON &amp;&amp; stEvents[iCount].iEvent &lt;= FWGUI_EVENT_RED_BUTTON) { printf(&quot;%s &quot;, getButtonData(stEvents[iCount].btData[0])); } const char * getButtonData(int iValue) { switch (iValue) { case (int)rpFWGUIButtonEvent::clicked: return &quot;clicked&quot;; case (int)rpFWGUIButtonEvent::doubleclicked: return &quot;doubleclick&quot;; case (int)rpFWGUIButtonEvent::longpress: return &quot;longpress&quot;; case (int)rpFWGUIButtonEvent::poweruppressed: return &quot;longpress&quot;; } return &quot;&quot;; }  ","version":"Next","tagName":"h2"},{"title":"Li-ION Battery and Power Management","type":0,"sectionRef":"#","url":"/scripting/gui-screen-buttons-and-lights/li-ion-battery-and-power-management/","content":"","keywords":"FREE-WILi battery Lithium ION battery power management battery monitoring Li-ION specifications portable applications display timeout power saving settings battery status","version":"Next"},{"title":"Lithium ION Battery specifications‚Äã","type":1,"pageTitle":"Li-ION Battery and Power Management","url":"/scripting/gui-screen-buttons-and-lights/li-ion-battery-and-power-management/#lithium-ion-battery-specifications","content":" Spec\tValue\tNotesEnergy\t1000 mAh Charge Voltage\t4.2V Charge Temp\tbetween 0 and 45C Discharge Temp\tbetween -22 to 55 C Storage Temp\tbetween -10 C to 45C Charger Current Max\t1000 maH Max discharge current\t1000 mA\t  ","version":"Next","tagName":"h2"},{"title":"App‚Äã","type":1,"pageTitle":"Li-ION Battery and Power Management","url":"/scripting/gui-screen-buttons-and-lights/li-ion-battery-and-power-management/#app","content":" The About app contains a screen to monitor the Lithium battery charger. The battery voltage, supply voltage for charging, the charging current and the status are shown.  About App indicating battery charging.  The about screen showing battery discharging  ","version":"Next","tagName":"h2"},{"title":"Settings‚Äã","type":1,"pageTitle":"Li-ION Battery and Power Management","url":"/scripting/gui-screen-buttons-and-lights/li-ion-battery-and-power-management/#settings","content":" There are settings that control the power usage of FREE-WILi. This includes display brightness, display timeout, wake up sound, and wake up on move. Normally only the button presses wake the screen.  The wake up on sound will wake the display on a sound threshold while the move wakes if the device moves.  You can save power by sleeping the display when battery powered. ","version":"Next","tagName":"h2"},{"title":"LED Light Show","type":0,"sectionRef":"#","url":"/scripting/gui-screen-buttons-and-lights/led-light-show/","content":"","keywords":"FREE-WILI's LED light show full-color LEDs sensor effects API control light strip Roku IR remote LED patterns","version":"Next"},{"title":"Settings‚Äã","type":1,"pageTitle":"LED Light Show","url":"/scripting/gui-screen-buttons-and-lights/led-light-show/#settings","content":" The setting are show below. At startup you can pick a default light show. Also you can enable light strip control. Then you can enable a Roku IR remote to switch between the light show options.  Settings for the Light Show  ","version":"Next","tagName":"h2"},{"title":"API‚Äã","type":1,"pageTitle":"LED Light Show","url":"/scripting/gui-screen-buttons-and-lights/led-light-show/#api","content":" There are APIs to control the board LEDS below. When setBoardLED is called it will disable the light show.  You can set the LED to a static color or make it flash or fade. The setBoardLED allows you to use the LEDs this way.   // Control Manual enum fwLEDManagerLEDMode { ledsimplevalue, ledflash, ledpulse, ledflashfade, ledpulsefade, }; void setBoardLED(int iLEDIndex0_7, int iR, int iG, int iB, int iDurationMs, fwLEDManagerLEDMode iMode); // Set a Light show void setLEDShowMode(int iLEDShow);  ","version":"Next","tagName":"h2"},{"title":"Sensors: Accelerometer & Temperature","type":0,"sectionRef":"#","url":"/scripting/gui-screen-buttons-and-lights/accelerometer/","content":"","keywords":"FREE-WILi accelerometer LIS3DH ST Microelectronics sensor data API integration axis orientation serial menu accelerometer data","version":"Next"},{"title":"Sensors App‚Äã","type":1,"pageTitle":"Sensors: Accelerometer & Temperature","url":"/scripting/gui-screen-buttons-and-lights/accelerometer/#sensors-app","content":" The sensors app Accel and Temperature will display accelerometer in a graphical form on the FREE-WILi screen. The top line shows the the current range, x, y ,z and temperature. If the axis broke the move threshold it will be temporarily white text. Below is a plot of the sensor. The LED will indicate x, y, z in both led position and color. This is usable anytime as a light show.    ","version":"Next","tagName":"h2"},{"title":"Sensor Settings‚Äã","type":1,"pageTitle":"Sensors: Accelerometer & Temperature","url":"/scripting/gui-screen-buttons-and-lights/accelerometer/#sensor-settings","content":" The sensor settings contain the settings for the accelerometer. This includes a range and a move threshold. The ranges supported by the Accel include 2, 4, 8, and 16. The move threshold is how much a Accel axis must change indicate FREE-WILi is moving. The moving signal can awake the screen or create events for your custom wasm scripts.  The temperature calibration allow you to tweak the default scaling of the rp chips internal temperature sensor. The calibration applies a floating point scale and offset to the default temperature scaling.    ","version":"Next","tagName":"h2"},{"title":"API Support‚Äã","type":1,"pageTitle":"Sensors: Accelerometer & Temperature","url":"/scripting/gui-screen-buttons-and-lights/accelerometer/#api-support","content":" The setSensorSettings API call will enabled the sensors to be reported at a specific rate through a GUI event. Also, it can also add the sensor value to an indicated plot data store. The event FWGUI_EVENT_GUI_SENSOR_DATA will report sensor data. The Accel and sensors can also be logged to a text log with the API setAppLogSettings below.  // FWGUI_EVENT_GUI_SENSOR_DATA if (stEvents[iCount].iEvent == FWGUI_EVENT_GUI_SENSOR_DATA) { short iX = stEvents[iCount].btData[0] | (stEvents[iCount].btData[1]&lt;&lt;8); short iY = stEvents[iCount].btData[2] | (stEvents[iCount].btData[3]&lt;&lt;8); short iZ = stEvents[iCount].btData[4] | (stEvents[iCount].btData[5]&lt;&lt;8); short iTc = stEvents[iCount].btData[6] | (stEvents[iCount].btData[7]&lt;&lt;8); short iTf = stEvents[iCount].btData[8] | (stEvents[iCount].btData[9]&lt;&lt;8); int iMoving = stEvents[iCount].btData[10] &amp; 0x1; int iMovingX = stEvents[iCount].btData[10] &amp; 0x2 ? 1 : 0; int iMovingY = stEvents[iCount].btData[10] &amp; 0x4 ? 1 : 0; int iMovingZ = stEvents[iCount].btData[10] &amp; 0x8 ? 1 : 0; printf(&quot;x %d y %d z %d T %d C T %d F moving %d moveX %d moveY %d moveZ %d&quot;,iX, iY,iZ, iTc, iTf,iMoving,iMovingX,iMovingY,iMovingZ); }    // API to enable accelerometer data void setSensorSettings(int bStreamAccel, int iRateMilliseconds, int bEnableAccelXPlotData, int iAccelXPlotDataIndex, int bEnableAccelYPlotData, int iAccelYPlotDataIndex, int bEnableAccelZPlotData, int iAccelZPlotDataIndex, int bEnableTempPlotDataC, int iTempPlotDataIndexC, int bEnableTempPlotDataF, int iTempPlotDataIndexF ); void setAppLogSettings(int bLogIRCodes, int bLogAccel, int bLogTempC, int bLogTempF, int iLogIndex);   ","version":"Next","tagName":"h2"},{"title":"Sensor Details‚Äã","type":1,"pageTitle":"Sensors: Accelerometer & Temperature","url":"/scripting/gui-screen-buttons-and-lights/accelerometer/#sensor-details","content":"   LIS3DH - STMicroelectronics STMicroelectronics    X Axis points to the IO Connector and Y points to the buttons, Z point out of the screen. ","version":"Next","tagName":"h2"},{"title":"IO App","type":0,"sectionRef":"#","url":"/scripting/io-app/","content":"IO App FREE-WILi includes an IO app that allows you to read and write all the IO of FREE-WILi. This app has a Serial Command Line Interface, support for a host API, on-board scripting, and a file system for stand-alone operations without a host. The serial command line interface provides a menu tree of commands to control FREE-WILi's IO interfaces. This is shown below: FREE-WILi's Serial Command Line Interface Main Menu To use a command, press a letter and the enter key. Then follow the instructions. The serial API is simply sending these menu commands and the data they expect. Below is a simple Python API that sets a GPIO high or low using the &quot;h&quot; and &quot;l&quot; commands. In API mode you can disable the menu text with by sending CTRL-B or reenable the menu text with CTRL-C. On board scripting uses web assembly technology. The code uses the WASM 3 engine with custom APIs to control FREE-WILi's interfaces. With this you can compile C/C++ or Rust source code to run on FREE-WILi with our without the host. The recommend Clang based wasi sdk is recommend https://github.com/WebAssembly/wasi-sdk. C/C++ program using WASI SDK and CLion. Finally, the file system provides a way to load scripts or run them at startup, load custom FPGA bit files, and store settings. This is shown below. Note getting files on the FREE-WILi uses the &quot;Download File&quot; command. The Filesystem menu provides interaction with file system.","keywords":"FREE-WILi IO app Serial Command Line Interface Python API WASM scripting File System GPIO control FREE-WILi scripting web assembly Clang wasi sdk FREE-WILi file management","version":"Next"},{"title":"RTC Real Time Clock","type":0,"sectionRef":"#","url":"/scripting/gui-screen-buttons-and-lights/rtc-real-time-clock/","content":"","keywords":"FREE-WILi RTC MCP7940N real time clock RTC API file timestamping RTC settings RTC events Lithium ION battery RTC trim setting setRTC getRTC","version":"Next"},{"title":"App‚Äã","type":1,"pageTitle":"RTC Real Time Clock","url":"/scripting/gui-screen-buttons-and-lights/rtc-real-time-clock/#app","content":" The about app will display the current RTC. The current time is shown as well as the time FREE-WILi started.  About App Screen  ","version":"Next","tagName":"h2"},{"title":"Settings‚Äã","type":1,"pageTitle":"RTC Real Time Clock","url":"/scripting/gui-screen-buttons-and-lights/rtc-real-time-clock/#settings","content":" The RTC is currently set from the main USB serial interface (this will be supported in both CPUs in the future).  The settings include a trim setting. This setting is loaded into the MCP7940N Trim (OSCTRIM) register. Please see the data sheet below for an explanation of this value.  The settings allow you to set the RTC values.  ","version":"Next","tagName":"h2"},{"title":"API‚Äã","type":1,"pageTitle":"RTC Real Time Clock","url":"/scripting/gui-screen-buttons-and-lights/rtc-real-time-clock/#api","content":" The API supports querying and setting the RTC. The setRTC allows you to set the current time. The getRTC causes the RTC to be read and provided via an event.  // set the RTC IC (Monday is 1 and 7 is Sunday (0 is invalid)) void setRTC(int iRTCHour, int iRTCMin, int iRTCSec, int iRTCWkDay, int iDay, int iRTCMth, int iRTCYear, int iTrim); // request the current RTC via an event void getRTC(); // RTC Event Response if (stEvents[iCount].iEvent == FWGUI_EVENT_GUI_RTC_RESPONSE) { //iRTCHour, int iRTCMin, int iRTCSec, int iRTCWkDay,int iRTCDay, int iRTCMth,int iRTCYear printf(&quot;%d:%d:%d day %d of month %d of year %d weekday %d trim %d&quot;, stEvents[iCount].btData[0], stEvents[iCount].btData[1], stEvents[iCount].btData[2], stEvents[iCount].btData[4], stEvents[iCount].btData[5], stEvents[iCount].btData[6], stEvents[iCount].btData[3], stEvents[iCount].btData[7] ); }   ","version":"Next","tagName":"h2"},{"title":"Hardware Details‚Äã","type":1,"pageTitle":"RTC Real Time Clock","url":"/scripting/gui-screen-buttons-and-lights/rtc-real-time-clock/#hardware-details","content":" The MCP7940N IC is used to implement the RTC. The data sheet is below. The RTC is always powered from the Lithium ION battery. When FREE-WILi shuts down the battery will continue to supply power (about 1 micro amp) to the RTC until the battery is physically exhausted. At that point the RTC value will be lost.    MCP7940N ","version":"Next","tagName":"h2"},{"title":"Making sounds","type":0,"sectionRef":"#","url":"/scripting/gui-screen-buttons-and-lights/making-sounds/","content":"","keywords":"FREE-WILi sound playback WAV files API calls playSoundFromFile playSoundFromNameOrID playSoundFromNumber Audacity ROM sounds WAV file sources","version":"Next"},{"title":"Converting Audio to Compatible WAV Files‚Äã","type":1,"pageTitle":"Making sounds","url":"/scripting/gui-screen-buttons-and-lights/making-sounds/#converting-audio-to-compatible-wav-files","content":" To make your own sounds for FREE-WILi, the files must be in 8000 Hz, 16-bit PCM WAV format.  You can convert your audio using either method:  1. Use the Web-Based Audio to WAV Converter ‚Äê Easily convert your audio files into FREE-WILi compatible .wav files here: üëâ https://freewili.com/audio-to-wav-converter/  2. Use Desktop Software like Audacity¬Æ ‚Äê Audacity can export audio as 8000 Hz, 16-bit PCM WAV files.  ","version":"Next","tagName":"h3"},{"title":"App‚Äã","type":1,"pageTitle":"Making sounds","url":"/scripting/gui-screen-buttons-and-lights/making-sounds/#app","content":" The Sound board app allows you to play select ROM sounds and sounds from the file system.  The sound board app lets you test sounds.  ","version":"Next","tagName":"h2"},{"title":"API Calls for sounds‚Äã","type":1,"pageTitle":"Making sounds","url":"/scripting/gui-screen-buttons-and-lights/making-sounds/#api-calls-for-sounds","content":" void playSoundFromFile(char * szSoundPath); void playSoundFromNameOrID(const char * szSoundName, int iID); void playSoundFromNumber(bool bFloat, int iNumber, float fNumber, int iFloatDigits);   ","version":"Next","tagName":"h2"},{"title":"ROM Sounds‚Äã","type":1,"pageTitle":"Making sounds","url":"/scripting/gui-screen-buttons-and-lights/making-sounds/#rom-sounds","content":" FREE-WILi includes sounds in its ROM. Below is a list of ROM sounds.    FwROMAudioAssets.pdf pdf  ","version":"Next","tagName":"h2"},{"title":"Software to edit and create proper wav files‚Äã","type":1,"pageTitle":"Making sounds","url":"/scripting/gui-screen-buttons-and-lights/making-sounds/#software-to-edit-and-create-proper-wav-files","content":" Home Audacity ¬Æ    Audacity can export an 8000 hz 16 bit PCM wav file  ","version":"Next","tagName":"h2"},{"title":"Source for wav files‚Äã","type":1,"pageTitle":"Making sounds","url":"/scripting/gui-screen-buttons-and-lights/making-sounds/#source-for-wav-files","content":" WavSource.com: Free Wav Files and Sound Bites ","version":"Next","tagName":"h2"},{"title":"Host USB Serial API","type":0,"sectionRef":"#","url":"/scripting/io-app/host-usb-serial-api/","content":"","keywords":"FREE-WILi USB serial API control FREE-WILi via USB USB serial port commands FREE-WILi command line interface toggle menu text Linux Windows Raspberry Pi control","version":"Next"},{"title":"App‚Äã","type":1,"pageTitle":"Host USB Serial API","url":"/scripting/io-app/host-usb-serial-api/#app","content":" FREE-WILi includes a terminal app that allows you do everything from the USB serial terminal. You can add text input clicking the input button. The gray button allows you to switch between the main and display CPU terminal.  The Terminal app allows you to use the serial terminal on the device. ","version":"Next","tagName":"h2"},{"title":"File System Menu","type":0,"sectionRef":"#","url":"/scripting/io-app/file-system-menu/","content":"File System Menu The File System Menu allows you to interact with the file menu (shown below). Command\tDescription\tNotesChange Directory\tChanges the current directory Create Directory\tCreates a directory in the current directory Remove File or Directory Download File\tSend a file from the host to FREE-WILi device Upload File\tCopy a file from FREE-WILi to host device Print File\tDisplay file to the serial terminal Create Blank File\tCreates an empty file Rename File or Directory Append to File ","keywords":"FREE-WILi File System Menu file management commands create directory remove file download file upload file print file rename file append to file","version":"Next"},{"title":"Logic Analyzer","type":0,"sectionRef":"#","url":"/scripting/io-app/logic-analyzer/","content":"Logic Analyzer The default FPGA configuration implements a Logic Analyzer compatible with Sigrok Pulseview. This logic analyzer uses the FPGA front end and communicates with the PC using the FTDI High speed user interface. The Logic Analyzer operates transparently to the IO features of FREE-WILi so you can use it to test when you are interfacing to digital protocols. The FPGA bit files for the logic analyzer are always being implemented and are open source. These are available at the FREE-WILi github. You can change the default FPGA bit file in the settings of FREE-WILi. Analyze your digital protocols without attaching wires","keywords":"FREE-WILi Logic Analyzer FPGA Logic Analyzer Sigrok PulseView digital protocol analysis FPGA bit files FREE-WILi settings FTDI High-speed user interface","version":"Next"},{"title":"Main Menu Header","type":0,"sectionRef":"#","url":"/scripting/io-app/main-menu-header/","content":"Main Menu Header At the top of the main menu there is information on the setup and state of the FREE-WILi IOs. The IO state shows the PIN states and configuration of the UART, SPI, I2C and GPIOs. It also shows the FPGA clock and if UART streaming is enabled. After the IO state the file system contents are shown for the current directory. Finally the current real time clock setting is shown. The top of the main menu has information about the FREE-WILi configuration.","keywords":"FREE-WILi main menu IO state UART configuration SPI settings I2C setup GPIO status FPGA clock file system display real-time clock FREE-WILi configuration","version":"Next"},{"title":"Main Menu Commands","type":0,"sectionRef":"#","url":"/scripting/io-app/main-menu-commands/","content":"Main Menu Commands Commands are a single letter. After you enter the letter additonal information is entered. The following command are available from the main menu: Command\tDescription\tArguments\tNotesh\tset io high\tgpio number l\tset io low\tgpio number o\tgenerate pwm\tgpio number, frequency, and duty cycle g\tget all io Returns the state of all 32 IO of the FREE-WILi processor in hex s\tread/write spi\tthe spi write bytes\tReturns the read bytes in hex t\twrite radio\tthe radio index, and data in hex k\tread radio\tthe radio index and count of read\tReturns the data read i\twrite i2c\tdevice address, register, and additional write bytes r\tread i2c\tdevice address, register and read length\tReturns the data read p\tpoll i2c Returns a table of i2c address that responded to a read u\twrite uart\twrite bytes in hex y\tstream uart toggles on and off of sending uart data to host w\trun script\tname of script in file system m\tload fpga from file\tname of fpga bit file in file systems d\tdownload fpga\tfpga bit file bytes\tsend raw FPGA bits after this command. This has a 10 second timeout. x\tfiles Access the files menu z\tsettings Access the settings menu The Main Menu access the core FREE-WILi Features.","keywords":"FREE-WILi main menu commands GPIO control PWM generation SPI read/write I2C communication UART streaming FPGA loading script execution FREE-WILi commands overview","version":"Next"},{"title":"FPGA Settings","type":0,"sectionRef":"#","url":"/scripting/io-app/settings-menu/fpga-settings/","content":"FPGA Settings The FPGA settings are shown below: Name\tDescription\tNotesClock Source\tThis is the internal clock used to generate the FPGA Clock\tThere are 4 options: the main PLL generated clock 125 Mhz, the 12 Mhz source oscillator, the 48 Mhz USB clock, and the internal 48khz RC analog clock Clock divider (int)\tThe integer part of the divider applied to the clock source Clock divider (frac)\tThe fractional part of clock divider The FPGA settings.","keywords":"FREE-WILi FPGA Settings FPGA Clock Source FPGA Clock Divider FPGA Configuration Clock Source Options FPGA Performance Tuning","version":"Next"},{"title":"Scripting with ZoomIO","type":0,"sectionRef":"#","url":"/scripting/io-app/scripting-with-zoomio/","content":"Scripting with ZoomIO ZoomIO is a scripting language that allows sub nanosecond precision control of the GPIO. Its very high level but produces native ARM assembly in the correct way to ensure design time determinism. To achieve precise determinism, native code runs in the second CPU core of the rp2040 and takes advantage of single cycle IO and the zero latency CPUs dedicated scratch 4K RAM. The IOApp integrates the ZoomIO compiler. You can simply write the source file and download to the scripts directory. The FREE-WILi will determine which engine to target based on the file extension. The ZoomIO source files have the extension zio. The code below illustrates a simple ZoomIO program. The pin is generating a waveform on pin 27 with nanosecond control of the waveform. setio(27, 1); delay(2000); setio(27, 0); delay(1000); setio(27, 1); delay(2000); setio(27, 0); The ZoomIO commands are executed in a sequence. The following commands are currently supported. Command\tArguments\tNotessetio\t(arg 1) Io pin (arg2) state delay\t(arg1) delay in ns\t32 bit value. Delay precision is based of the CPU clock (default is 125Mhz or 8ns)","keywords":"FREE-WILi ZoomIO scripting sub-nanosecond GPIO control ZoomIO commands ARM assembly for GPIO FREE-WILi IOApp integration ZoomIO examples precision waveform generation","version":"Next"},{"title":"GPIO Settings","type":0,"sectionRef":"#","url":"/scripting/io-app/settings-menu/gpio-settings/","content":"GPIO Settings","keywords":"","version":"Next"},{"title":"Settings Menu","type":0,"sectionRef":"#","url":"/scripting/io-app/settings-menu/","content":"","keywords":"FREE-WILi Settings Menu SPI Configuration I2C Settings UART Configuration FPGA Clock Settings GPIO Directions RTC Configuration Default Script Default FPGA Save Startup Settings","version":"Next"},{"title":"Menu Options‚Äã","type":1,"pageTitle":"Settings Menu","url":"/scripting/io-app/settings-menu/#menu-options","content":" The menu options are shown below.  Name\tDescription\tNotesSPI\tConfigures SPI Baud rate, Bit Modes, Bit Width\tmore information I2C\tConfigures I2C bit rate and pull ups\tmore information UART\tConfigures UART Bit Rate, hand shaking, stop bits, and parity\tmore information FPGA Clock\tConfigures the input clock to the FPGA\tmore information Radio 1\tConfigures the CC1101 Radio 1 Radio 2\tConfigures the CC1101 Radio 1 GPIO Directions\tSets up directions of GPIO\tmore information RTC\tConfigures the real-time clock (RTC)\tmore information Default Script\tAllows a script to run on power up Default FPGA\tAllows a FPGA to configured at startup Save settings as Startup\tSaves current settings to &quot;settings.txt&quot; in root filesystem\t  ","version":"Next","tagName":"h2"},{"title":"Settings‚Äã","type":1,"pageTitle":"Settings Menu","url":"/scripting/io-app/settings-menu/#settings","content":" Settings are updated when you exit the settings menu.  The settings can be stored as a file when the &quot;r&quot; menu item is selected. This will store the settings so they will be loaded on startup.  These are stored in the file system under the filename &quot;settings.txt&quot;. ","version":"Next","tagName":"h2"},{"title":"RTC Settings","type":0,"sectionRef":"#","url":"/scripting/io-app/settings-menu/rtc-settings/","content":"RTC Settings The RTC settings allows you to configure the real time clock. See this topic for more information.","keywords":"","version":"Next"},{"title":"Radios","type":0,"sectionRef":"#","url":"/scripting/radios/","content":"Radios FREE-WILi has two radios integrate to help develop, validate and test radio systems. The different FREE-WILi devices have different radios to support different applications. Device\tDescription\tNotesblack\tCC1101 Sub GHZ red In development purple In development","keywords":"FREE-WILi CC1101 radios Sub-GHz radio systems radio development radio testing","version":"Next"},{"title":"SPI Settings","type":0,"sectionRef":"#","url":"/scripting/io-app/settings-menu/spi-settings/","content":"SPI Settings SPI settings are listed below. The settings are configured using the menu shown below. Setting\tDescription\tNotesFrequency\tSPI Clock Frequency Chip Select Pin\tGPIO used for Chip select.\tGPIO must be configured for output. Data bits\tThe width of the spi bytes\t(only 8 is currently supported) CPOL\tclock polarity\tRefer to RP2040 data sheet section 4.10 on clock phase and polarity. Most common is 0,0. CPHA\tclock phase SPI has 5 settings","keywords":"FREE-WILi SPI Settings SPI Frequency Chip Select Pin Data Bits CPOL CPHA SPI Configuration RP2040 SPI Settings","version":"Next"},{"title":"CC1101 Radio Settings","type":0,"sectionRef":"#","url":"/scripting/radios/black-radio-cc1101/cc1101-radio-settings/","content":"CC1101 Radio Settings The radio settings are shown below. The settings closely follow the ELECHOUSE CC1101 Ardunio driver from here: https://github.com/simonmonk/CC1101_arduino/blob/master/ELECHOUSE_CC1101.h Radio Settings.","keywords":"CC1101 radio settings FREE-WILi ELECHOUSE Arduino driver radio configuration CC1101 settings radio configuration guide packet radio","version":"Next"},{"title":"Black Radio (CC1101)","type":0,"sectionRef":"#","url":"/scripting/radios/black-radio-cc1101/","content":"Black Radio (CC1101) The FREE-WILi contains two CC1101 packet radios from Texas Instruments. The CC1101 radio has many settings to configure the radio and integrated packet processor. More information about the capabilities of the CC1101 radio can be found in the data sheet CC1101","keywords":"FREE-WILi Black Radio CC1101 Texas Instruments packet radio radio configuration integrated packet processor radio capabilities CC1101 datasheet","version":"Next"},{"title":"FREE-WILi Python Library and Examples","type":0,"sectionRef":"#","url":"/scripting/python-library/","content":"","keywords":"FREE-WILi FREE-WILi Python FREE-WILi fwi-serial fwi-convert FREE-WILi CLI FREE-WILi API Python hardware control USB device access FREE-WILi image conversion udev rules serial communication FPGA IR communication SPI UART Python 3.10","version":"Next"},{"title":"Documentation & Installation‚Äã","type":1,"pageTitle":"FREE-WILi Python Library and Examples","url":"/scripting/python-library/#documentation--installation","content":" üëâ Visit the official Python library documentation here: FREE-WILi Python Library ‚Äì Installation &amp; Guide  The guide includes installation steps, usage examples, and API documentation. ","version":"Next","tagName":"h2"},{"title":"I2C settings","type":0,"sectionRef":"#","url":"/scripting/io-app/settings-menu/i2c-settings/","content":"I2C settings The I2C Settings are listed below: Name\tDescription\tNotesFrequency\tBit rate of I2C bus\tLimited to 400Khz. PullUps\tEnable or disable 10K pull ups to VIO\tDefaulted to On","keywords":"FREE-WILi I2C Settings I2C Frequency I2C Bit Rate Pull-Up Resistors I2C Configuration I2C Bus Settings","version":"Next"},{"title":"FREE-WILi Rust Examples","type":0,"sectionRef":"#","url":"/scripting/rust-examples/","content":"","keywords":"FREE-WILi Rust FREE-WILi Rust examples FREE-WILi Rust integration freewili-finder-rs FREE-WILi GitHub FREE-WILi device control Rust FREE-WILi programming Rust FREE-WILi automation Rust Rust IoT examples FREE-WILi tutorials","version":"Next"},{"title":"Repository‚Äã","type":1,"pageTitle":"FREE-WILi Rust Examples","url":"/scripting/rust-examples/#repository","content":" You can find the official Rust examples and source code here: üëâ freewili-finder-rs on GitHub  ","version":"Next","tagName":"h2"},{"title":"What‚Äôs Included‚Äã","type":1,"pageTitle":"FREE-WILi Rust Examples","url":"/scripting/rust-examples/#whats-included","content":" Sample Code ‚Äì Ready-to-run Rust examples for FREE-WILi devices.Integration Support ‚Äì Designed for developers who want to bring FREE-WILi functionality into embedded, desktop, or backend systems with Rust. ","version":"Next","tagName":"h2"},{"title":"FREE-WILi WebAssembly (Wasm) Examples","type":0,"sectionRef":"#","url":"/scripting/wasm-examples/","content":"","keywords":"test","version":"Next"},{"title":"Repository‚Äã","type":1,"pageTitle":"FREE-WILi WebAssembly (Wasm) Examples","url":"/scripting/wasm-examples/#repository","content":" üëâ Visit the official repository for FREE-WILi Wasm examples: FREE-WILi wasm-examples on GitHub  ","version":"Next","tagName":"h2"},{"title":"What‚Äôs Included‚Äã","type":1,"pageTitle":"FREE-WILi WebAssembly (Wasm) Examples","url":"/scripting/wasm-examples/#whats-included","content":" Ready-to-use Wasm examples ‚Äì Run FREE-WILi functionality directly in your browser.Integration samples ‚Äì Learn how to embed FREE-WILi into web apps.Cross-platform compatibility ‚Äì Works across browsers with WebAssembly support.Lightweight execution ‚Äì Near-native performance in the web environment. ","version":"Next","tagName":"h2"},{"title":"UART Settings","type":0,"sectionRef":"#","url":"/scripting/io-app/settings-menu/uart-settings/","content":"UART Settings The UART Settings are listed below. The default is 115200 baud 8 data bits, no parity bit, and one stop bit ( 8N1 ): Learn more about UART here. Name\tDescription\tNotesFrequency\tUART Baud Rate RTS Handshaking\tHardware handshaking CTS Handshaking\tHardware handshaking Data Bits\tBits per UART frame Parity\tChecksum bit per frame Stop Bits\tBits at end of frame Module The UART settings.","keywords":"FREE-WILi UART Settings UART Baud Rate UART Handshaking Data Bits UART UART Parity UART Stop Bits UART Configuration","version":"Next"},{"title":"Tutorials","type":0,"sectionRef":"#","url":"/tutorials/","content":"","keywords":"FREE-WILi Tutorial configure FREE-WILi FREE-WILi support embedded system tutorials FREE-WILi how-to FREE-WILi resources","version":"Next"},{"title":"üìö Available Tutorials‚Äã","type":1,"pageTitle":"Tutorials","url":"/tutorials/#-available-tutorials","content":" ","version":"Next","tagName":"h2"},{"title":"- How to Disable FREE-WILi Boot Sounds via Serial CLI‚Äã","type":1,"pageTitle":"Tutorials","url":"/tutorials/#--how-to-disable-free-wili-boot-sounds-via-serial-cli","content":" ","version":"Next","tagName":"h3"},{"title":"- How to use the FREE-WILi Bracelet using .sub file‚Äã","type":1,"pageTitle":"Tutorials","url":"/tutorials/#--how-to-use-the-free-wili-bracelet-using-sub-file","content":" Stay tuned ‚Äî more tutorials are on the way! ","version":"Next","tagName":"h3"},{"title":"Scripting with WASM","type":0,"sectionRef":"#","url":"/scripting/io-app/scripting-with-wasm/","content":"","keywords":"FREE-WILi WebAssembly scripting WASM setup FREE-WILi scripting compile WASM script FREE-WILi execution WASI SDK Visual Studio Code WASM WebAssembly for FREE-WILi","version":"Next"},{"title":"Introduction to WebAssembly (WASM)‚Äã","type":1,"pageTitle":"Scripting with WASM","url":"/scripting/io-app/scripting-with-wasm/#introduction-to-webassembly-wasm","content":" WebAssembly (WASM) technology allows a program compiler to target a generic CPU architecture. The program that runs the compiled code is called a WebAssembly runtime. This technology is included in the IO app. Please note that WebAssembly has nothing to do with the Web; it is simply named after the origin of the technology.  Example wasm projects are available from the FREE-WILi Github:    GitHub - Example WASM project for FREE-WILi GitHub    Users can compile programs, store them in the FREE-WILi file system, and execute them either on demand or at power-up.  FREE-WILi uses the WASM3 runtime: WASM3 on GitHub.  ","version":"Next","tagName":"h2"},{"title":"APIs and Implementation‚Äã","type":1,"pageTitle":"Scripting with WASM","url":"/scripting/io-app/scripting-with-wasm/#apis-and-implementation","content":" The FREE-WILi IO app implements APIs to control FREE-WILi and provides them to the runtime. These APIs are defined in a header file called fwwasm.h.  ","version":"Next","tagName":"h2"},{"title":"Recommended Toolset‚Äã","type":1,"pageTitle":"Scripting with WASM","url":"/scripting/io-app/scripting-with-wasm/#recommended-toolset","content":" The recommended toolset to compile for FREE-WILi WASM is the WASI SDK.  For a development IDE, we recommend using Visual Studio Code or CLion.  ","version":"Next","tagName":"h2"},{"title":"Execution‚Äã","type":1,"pageTitle":"Scripting with WASM","url":"/scripting/io-app/scripting-with-wasm/#execution","content":" After compiling your script to WebAssembly (extension .wasm), you must upload the file to the FREE-WILi filesystem. The best way to do this is with the freewili Python library, as will be explained under Getting Started below.  After your script is uploaded to the FREE-WILi, you can have it run on startup. The script will execute every time FREE-WILi is powered on. Alternatively, you can start WASM files on demand from the serial menu, or you can start them using the freewili Python library.    Getting Started  There are a lot of different WebAssembly compilers; you can write your code in Rust, Python, C/C++, and several others.  The following example will use the wasi-sdk, which comes with a clang-based C/C++ compiler.  ","version":"Next","tagName":"h2"},{"title":"Installing the SDK‚Äã","type":1,"pageTitle":"Scripting with WASM","url":"/scripting/io-app/scripting-with-wasm/#installing-the-sdk","content":" ","version":"Next","tagName":"h2"},{"title":"Windows 10 and Windows 11‚Äã","type":1,"pageTitle":"Scripting with WASM","url":"/scripting/io-app/scripting-with-wasm/#windows-10-and-windows-11","content":" There are issues with using the WASI-SDK Windows binaries in Windows 11. Therefore, we recommend installing and using Windows Subsystem for Linux provided by Microsoft.  Install WSL with the following command in Command Prompt or PowerShell wsl --install After installation, open the WSL app and follow the installation prompt. (You can search for WSL in Window's search bar, or you can select it in the Windows Terminal)Once WSL has successfully installed, follow the Ubuntu Linux setup and build instructions  ","version":"Next","tagName":"h3"},{"title":"Ubuntu Linux‚Äã","type":1,"pageTitle":"Scripting with WASM","url":"/scripting/io-app/scripting-with-wasm/#ubuntu-linux","content":" In Ubuntu Linux, the quickest way to get up and running is to download the .deb prebuilt package from Github under Releases. For Ubuntu Linux on an x86-based machine, grab the Debian package (.deb) file for x86. In this example, the file is wasi-sdk-24.0-x86_64-linux.deb.  Download the package with: sudo wget https://github.com/WebAssembly/wasi-sdk/releases/download/wasi-sdk-24/wasi-sdk-24.0-x86_64-linux.deb Then, install the package with: sudo dpkg --install wasi-sdk-24.0-x86_64-linux.deb After installation, the compiler will be located here: /opt/wasi-sdk/bin/wasm32-wasi-clang++ If you want, you could set an alias to the wasm clang compiler with the following command: alias wasm32-wasi-clang++='/opt/wasi-sdk/bin/wasm32-wasi-clang++'   ","version":"Next","tagName":"h3"},{"title":"Writing a Script‚Äã","type":1,"pageTitle":"Scripting with WASM","url":"/scripting/io-app/scripting-with-wasm/#writing-a-script","content":" Use VS Code or a text editor, and write your script. For this example, we will use C++ and write a simple script to turn each of the board LEDs a different color.  Make sure you have the fwwasm.h header fileCopy and paste this example script below into your text editor, and save it as leds.cpp  #include &quot;fwwasm.h&quot; #define MAX_LOOPS 20 #define NUM_LEDS 7 #define DELAY_MS 50 #define LED_FADE_DURATION 300 //different color RGB values #define RED 0xFF0000 #define PINK 0xFFC6FF #define ORANGE 0xFF7F00 #define YELLOW 0xFFFF00 #define GREEN 0x00FF00 #define LIGHT_GREEN 0xCAFFBF #define BLUE 0x0000FF #define LIGHT_BLUE 0x9BF6FF #define INDIGO 0x4B0082 #define VIOLET 0x9400D3 #define MAX_COLORS 10 //some macros to get color RGB components #define GET_RED(x) ((x &gt;&gt; 16) &amp; 0xFF) #define GET_GREEN(x) ((x &gt;&gt; 8) &amp; 0xFF) #define GET_BLUE(x) (x &amp; 0xFF) int main() { int rainbow[MAX_COLORS] = {RED, ORANGE, YELLOW, GREEN, LIGHT_GREEN, BLUE, LIGHT_BLUE, INDIGO, VIOLET, PINK}; int color_choice = 0; //do the whole thing multiple times for (int loops = 0; loops &lt; MAX_LOOPS; loops++) { //set every LED one at a time for (int led = 0; led &lt; NUM_LEDS; led++) { //pick a color int color = rainbow[color_choice]; //set the LED setBoardLED(led, GET_RED(color), GET_GREEN(color), GET_BLUE(color), LED_FADE_DURATION, LEDManagerLEDMode::ledpulsefade); //next time, get a new color. If we used all of the colors, start over color_choice++; if (color_choice &gt;= MAX_COLORS) color_choice = 0; //wait before setting the next LED waitms(DELAY_MS); } } return 0; }   ","version":"Next","tagName":"h2"},{"title":"Compiling the Script‚Äã","type":1,"pageTitle":"Scripting with WASM","url":"/scripting/io-app/scripting-with-wasm/#compiling-the-script","content":" At the command line, run the following:  ","version":"Next","tagName":"h2"},{"title":"Ubuntu Linux Terminal‚Äã","type":1,"pageTitle":"Scripting with WASM","url":"/scripting/io-app/scripting-with-wasm/#ubuntu-linux-terminal","content":" /opt/wasi-sdk/bin/wasm32-wasi-clang++ -O3 -s leds.cpp -o leds.wasm   Note the -s argument is critical to force the linker to strip debugging symbols from the output binary.  After a successful compilation, the compiler should output a binary called leds.wasm. This is your FREE-WILi WASM script, and you will need to upload this binary to the FREE-WILi.  ","version":"Next","tagName":"h3"},{"title":"Uploading the Script‚Äã","type":1,"pageTitle":"Scripting with WASM","url":"/scripting/io-app/scripting-with-wasm/#uploading-the-script","content":" Note: If you are using WSL in Windows, you may need to copy over the LEDs.wasm from your Linux file system to Windows file system to upload the script. Install the freewili Python library with: pip install freewili Note: the freewili library requires Python 3.11 or newer. Upload your script with: fwi-serial -s leds.wasm -fn /scripts/leds.wasm   ","version":"Next","tagName":"h2"},{"title":"Executing the Script‚Äã","type":1,"pageTitle":"Scripting with WASM","url":"/scripting/io-app/scripting-with-wasm/#executing-the-script","content":" Once the script is on the FREE-WILi's file system, there are multiple ways it can be executed:  From the FREE-WILi interface, you can select &quot;Scripts&quot; and select your script to execute it.From the command line, you use the FREE-WILi Python Library with the command below to execute the script: fwi-serial -w leds.wasm From the serial terminal interface, you can select w to run a script, then type leds.wasm and hit enter  ","version":"Next","tagName":"h2"},{"title":"Common Issues Targeting FREE-WILi (Troubleshooting)‚Äã","type":1,"pageTitle":"Scripting with WASM","url":"/scripting/io-app/scripting-with-wasm/#common-issues-targeting-free-wili-troubleshooting","content":" Many tools compile binaries that use too many memory pages. FREE-WILi only supports 2 (128Kb). Ensure that the stack size of your binary is limited in this way. Please see the FREE-WILi Wasm Examples for the necessary command line switches.  A good tool for troubleshooting WASM files is the WebAssembly Explorer.  WebAssembly Code Explorer    Visual Studio Code Configuration  Assuming you installed the SDK as described above, you can get Visual Studio code to recognize your WASI-SDK as follows:  Install the CMake extension for VS Code, as well as the CMake Tools extension hereCreate a file called CMakeLists.txt and place it in the root of your projectCopy and paste the following into the CMakeLists.txt  cmake_minimum_required(VERSION 3.0) project(wasm_project) set(CMAKE_EXE_LINKER_FLAGS &quot;${CMAKE_EXE_LINKER_FLAGS} -s&quot;) add_executable(leds.wasm &quot;leds.cpp&quot;)   Create a file called CMakePresets.json and place it in the root of your projectCopy and paste the following into the CMakePresets.json  ","version":"Next","tagName":"h2"},{"title":"Ubuntu Linux‚Äã","type":1,"pageTitle":"Scripting with WASM","url":"/scripting/io-app/scripting-with-wasm/#ubuntu-linux-1","content":" { &quot;version&quot;: 3, &quot;cmakeMinimumRequired&quot;: { &quot;major&quot;: 3, &quot;minor&quot;: 16, &quot;patch&quot;: 0 }, &quot;configurePresets&quot;: [ { &quot;name&quot;: &quot;default&quot;, &quot;hidden&quot;: true, &quot;generator&quot;: &quot;Ninja&quot; }, { &quot;name&quot;: &quot;wasi&quot;, &quot;description&quot;: &quot;Configure for WASI using wasi-sdk&quot;, &quot;inherits&quot;: &quot;default&quot;, &quot;toolchainFile&quot;: &quot;/opt/wasi-sdk/share/cmake/wasi-sdk.cmake&quot;, &quot;cacheVariables&quot;: { &quot;CMAKE_BUILD_TYPE&quot;: &quot;Release&quot; } } ] }   Use CTRL-SHIFT-P in Visual Studio code and select &quot;CMake: Select Configure Preset&quot;. Select 'wasi` from the dropdown that appears. (Note: You may need to reload VS Code for this option to appear.)You can now use the build button in Visual Studio Code to build your WASM project with one click.  Alternatively, you can run the following CMake commands in Visual Studio Code  Inside the VSCode command Palette run the following commands: &gt;CMake: Select Variant and select MinSizeRel&gt;CMake: Configure&gt;CMake: Build Target&gt;CMake: Select A Kit Make sure the kit is unspecified.  Next Steps  Look at our FWWasm Submodule for supported FREE-WILi WASM APIs. You can use this module in your projects.  There are several WASM examples written in different languages in the FREE-WILi WASM Example repo  Examples of programming languages that FREE-WILi WASM supports can be found below:  CXXRustGoZig ","version":"Next","tagName":"h2"},{"title":"Quickstart","type":0,"sectionRef":"#","url":"/","content":"","keywords":"FREE-WILi buy FREE-WILi FREE-WILi distributor purchase FREE-WILi","version":"Next"},{"title":"Tools & Downloads‚Äã","type":1,"pageTitle":"Quickstart","url":"/#tools--downloads","content":" Learn how to integrate FREE-WILi into your projects with step-by-step guides, examples, and best practices.  FREE-WILi GUI Cross-platform interface for GPIO, SPI, I¬≤C, UART, Radio, LEDs, audio, scripting, and file management. FREE-WILi Updater One-click tool to flash or update UF2 firmware.  ","version":"Next","tagName":"h2"},{"title":"Scripting‚Äã","type":1,"pageTitle":"Quickstart","url":"/#scripting","content":" WASM Examples Ready-to-run sample projects showcasing capabilities. Python Library and Examples Python library for controlling and communicating with FreeWili. Firmware Files Download stable, beta, and archived UF2 builds PNG ‚Üí FWI Converter Convert images for display on the badge Audio ‚Üí WAV Converter Prepare audio for playback on the badge.  ","version":"Next","tagName":"h2"},{"title":"Orca Series Modules‚Äã","type":1,"pageTitle":"Quickstart","url":"/#orca-series-modules","content":" Maestro Debug Orca Debug and develop with ease ‚Äî RP2040 support with IO test points. - Bottlenose WiFi &amp; BT Orca A compact ESP32-C6 board with Wi-Fi, BT, USB-C, and Qwiic ‚Äî ideal for IoT prototyping. Jambu Serial LED Control Orca 8-channel LED driver breakout module for dynamic lighting control. WhaleTail Badge Orca Compact badge module with CAN FD and 10BASE-T1L, built for industrial protocol learning. WILEYE Camera Orca The Vision Accessory for FREE-WILi Orca Modules ","version":"Next","tagName":"h2"},{"title":"How to use the FREE-WILi Bracelet using .sub file","type":0,"sectionRef":"#","url":"/tutorials/how-to-use-the-free-wili-bracelet-using-sub-file/","content":"","keywords":"FREE-WILi bracelet FREE-WILi .sub files FREE-WILi bracelet guide FREE-WILi upload .sub FREE-WILi radio playlists FREE-WILi LED bracelet sync FREE-WILi bracelet setup fwi-serial FREE-WILi FREE-WILi bracelet transmit FREE-WILi bracelet patterns","version":"Next"},{"title":"Uploading the .sub Files to FREE-WILi‚Äã","type":1,"pageTitle":"How to use the FREE-WILi Bracelet using .sub file","url":"/tutorials/how-to-use-the-free-wili-bracelet-using-sub-file/#uploading-the-sub-files-to-free-wili","content":" üìã Prerequisites  Python 3.10+Install the FREE-WILi Python library: pip install freewili    - Method 1: Using the Upload Scripts (Recommended)  The easiest way to upload all .sub files is with the provided scripts:  Windows (PowerShell):  .\\upload.ps1   Linux/macOS (Bash):  ./upload.sh   These scripts will automatically upload all .sub files to the /radio/ directory on your device.    - Method 2: Manual Upload  For manual control, you can use the fwi-serial tool.  Check your version:  fwi-serial --version # fwi-serial 0.0.29   List connected devices:  fwi-serial -l # Found 1 FreeWili(s)   # Found 1 FreeWili(s) # 1. Free-Wili FW4852 # 1. Main: MainCPU v54 (USB Composite Device): COM4 # 2. Display: DisplayCPU v54 (USB Composite Device): COM3 # 3. FPGA: FreeWili (USB Serial Converter): COM49   Upload an individual .sub file:  fwi-serial -s yellow.sub   ","version":"Next","tagName":"h2"},{"title":"‚úÖ Verification‚Äã","type":1,"pageTitle":"How to use the FREE-WILi Bracelet using .sub file","url":"/tutorials/how-to-use-the-free-wili-bracelet-using-sub-file/#-verification","content":" Uploaded .sub files will appear under Radios ‚Üí Transmit on your FREE-WiLi device.A power cycle of the device may be required for them to show up.All files are stored automatically in the /radio/ directory. ","version":"Next","tagName":"h2"},{"title":"How to Disable FREE-WILi Boot Sounds via Serial CLI","type":0,"sectionRef":"#","url":"/tutorials/how-to-disable-free-wili-boot-sounds-via-serial-cli/","content":"","keywords":"FREE-WILi boot sound disable startup sound CLI sound settings PuTTY serial connection FREE-WILi terminal settings turn off display sound sound configuration FREE-WILi mute boot audio FREE-WILi","version":"Next"},{"title":"üîå Connecting via PuTTY‚Äã","type":1,"pageTitle":"How to Disable FREE-WILi Boot Sounds via Serial CLI","url":"/tutorials/how-to-disable-free-wili-boot-sounds-via-serial-cli/#-connecting-via-putty","content":" Launch PuTTY.In the &quot;Category&quot; pane, select Session.Select Serial as the connection type.Set the Serial line (e.g., COM11). Note - You can find the correct COM port in Device Manager. Set Speed to 115200.Click Open to to initiate the connection.  Connecting with PuTTY  ","version":"Next","tagName":"h2"},{"title":"‚öôÔ∏è Configuring Sound Settings‚Äã","type":1,"pageTitle":"How to Disable FREE-WILi Boot Sounds via Serial CLI","url":"/tutorials/how-to-disable-free-wili-boot-sounds-via-serial-cli/#Ô∏è-configuring-sound-settings","content":" From the Main Menu, press z to go to Settings.  Navigate to Settings      Select Settings    Once in the &quot;Settings&quot; menu, press g to open Sound configuration.  Configure Sound  To adjust the speaker volume, press v to adjust volume. When prompted, enter 0 and press Enter to set the volume to zero.  Adjust Speaker Volume  Press p to disable system sounds. Enter 0 and press Enter to turn sounds select off.  Disable Sound  ","version":"Next","tagName":"h2"},{"title":"üíæ Saving the Configuration‚Äã","type":1,"pageTitle":"How to Disable FREE-WILi Boot Sounds via Serial CLI","url":"/tutorials/how-to-disable-free-wili-boot-sounds-via-serial-cli/#-saving-the-configuration","content":" Press q to exit the &quot;Configure Sound&quot; menu and return to the &quot;Settings&quot; menu.  Select Settings  Press s to Save Settings as Startup.  Save Settings as Startup  A confirmation message: Saving Settings to settings.txt... will appear.  Confirm Settings  The FREE-WILi startup sound is now successfully disabled.‚úÖ  ","version":"Next","tagName":"h2"},{"title":"üìù Related‚Äã","type":1,"pageTitle":"How to Disable FREE-WILi Boot Sounds via Serial CLI","url":"/tutorials/how-to-disable-free-wili-boot-sounds-via-serial-cli/#-related","content":" FREE-WiLi Product Overview ","version":"Next","tagName":"h2"},{"title":"Bottlenose Getting Started Guide","type":0,"sectionRef":"#","url":"/extending-with-orcas/bottlenose-wifi-orca/bottlenose-getting-started/","content":"","keywords":"Bottlenose getting started ESP32-C6 tutorial WiFi quick start first project Bt tutorial network setup","version":"Next"},{"title":"What You'll Build‚Äã","type":1,"pageTitle":"Bottlenose Getting Started Guide","url":"/extending-with-orcas/bottlenose-wifi-orca/bottlenose-getting-started/#what-youll-build","content":" By the end of this guide, you'll have a working WiFi system that:  Connects to your WiFi network automaticallySends periodic status updates over WiFiCommunicates with FREE-WILi via UARTDisplays connection status via LEDs  ","version":"Next","tagName":"h2"},{"title":"Prerequisites‚Äã","type":1,"pageTitle":"Bottlenose Getting Started Guide","url":"/extending-with-orcas/bottlenose-wifi-orca/bottlenose-getting-started/#prerequisites","content":" Before starting, make sure you have:  Bottlenose WiFi Orca properly connected to FREE-WILi (see Hardware Hookup)FREE-WILi device with latest firmware installedComputer connected to FREE-WILi (via USB or network)UART Orca Communication enabled for Bottlenose (see Step 1 below)  UART Communication Required CRITICAL: You must enable UART Orca Communication for Bottlenose in FREE-WILi settings before the module will function. Bottlenose will not work without this setting enabled.    ","version":"Next","tagName":"h2"},{"title":"Step 1: Enable UART Orca Communication‚Äã","type":1,"pageTitle":"Bottlenose Getting Started Guide","url":"/extending-with-orcas/bottlenose-wifi-orca/bottlenose-getting-started/#step-1-enable-uart-orca-communication","content":" Before flashing firmware or using Bottlenose, you must first enable UART Orca Communication in FREE-WILi settings.  ","version":"Next","tagName":"h2"},{"title":"Accessing Orca Setup Settings‚Äã","type":1,"pageTitle":"Bottlenose Getting Started Guide","url":"/extending-with-orcas/bottlenose-wifi-orca/bottlenose-getting-started/#accessing-orca-setup-settings","content":" Connect to FREE-WILi via USB console or web interfaceNavigate to Settings menu from main consoleFind Orca Setup section in settingsAccess Configure Orca Communication option  ","version":"Next","tagName":"h3"},{"title":"Configure UART Communication‚Äã","type":1,"pageTitle":"Bottlenose Getting Started Guide","url":"/extending-with-orcas/bottlenose-wifi-orca/bottlenose-getting-started/#configure-uart-communication","content":" In the Orca Setup menu, you'll see:  ======== Configure Orca Communication ======== u) Orca Communication over UART [WILEye] Enter Letter: (q to exit)   Press 'u' to configure UART communicationSelect Bottlenose option from the menu:  ======== Configure Orca Communication ======== 0) Off 1) BottleNose 2) WhaleTail 3) WILEye Orca Communication over UART Enter Number [3]   Enter '1' to select BottleNoseSave settings and exit configuration menu  ","version":"Next","tagName":"h3"},{"title":"Verify Configuration‚Äã","type":1,"pageTitle":"Bottlenose Getting Started Guide","url":"/extending-with-orcas/bottlenose-wifi-orca/bottlenose-getting-started/#verify-configuration","content":" After setting UART communication to BottleNose:  ======== Configure Orca Communication ======== u) Orca Communication over UART [BottleNose] ‚úÖ   The setting should now show [BottleNose] instead of the default [WILEye].  Why This Setting Matters The UART Orca Communication setting tells FREE-WILi which type of Orca module is connected and how to communicate with it. Each Orca module (BottleNose, WhaleTail, WILEye) has different communication protocols and capabilities. Bottlenose UART Parameters: Baud Rate: 3 Mbps - Optimized for WiFi/Bt command and data transferFlow Control: CTS and RTS enabled (Hardware flow control)Data Bits: 8Stop Bits: 1Parity: None Hardware flow control ensures reliable communication for network data, terminal bridging, and configuration commands between FREE-WILi and Bottlenose.  ","version":"Next","tagName":"h3"},{"title":"Restart FREE-WILi‚Äã","type":1,"pageTitle":"Bottlenose Getting Started Guide","url":"/extending-with-orcas/bottlenose-wifi-orca/bottlenose-getting-started/#restart-free-wili","content":" After changing the UART communication setting:  Power cycle FREE-WILi to apply the new configurationWait for full boot before proceeding with firmware flashingVerify Orca detection in FREE-WILi status messages    ","version":"Next","tagName":"h3"},{"title":"Step 2: Flash Bottlenose Firmware‚Äã","type":1,"pageTitle":"Bottlenose Getting Started Guide","url":"/extending-with-orcas/bottlenose-wifi-orca/bottlenose-getting-started/#step-2-flash-bottlenose-firmware","content":" Before you can use Bottlenose with FREE-WILi, you need to flash the proper firmware to the ESP32-C6. The Bottlenose firmware is built into the FREE-WILi firmware and can be flashed directly from FREE-WILi.  ","version":"Next","tagName":"h2"},{"title":"Hardware Preparation‚Äã","type":1,"pageTitle":"Bottlenose Getting Started Guide","url":"/extending-with-orcas/bottlenose-wifi-orca/bottlenose-getting-started/#hardware-preparation","content":" Connect Bottlenose to FREE-WILi: Ensure Bottlenose is properly connected via the Orca connectorPower on your FREE-WILi device Locate Control Buttons: On the Bottlenose PCB, you'll find two buttons: &quot;BOOT&quot; button - Used to enter bootloader mode&quot;RESET&quot; button - Used to reset the ESP32-C6  Button Location The BOOT and RESET buttons are typically located near the ESP32-C6 chip on the Bottlenose PCB. Look for small tactile buttons labeled &quot;BOOT&quot; and &quot;RST&quot; or &quot;RESET&quot;.  Enter Bootloader Mode: The ESP32-C6 must be in bootloader mode to receive firmware from FREE-WILi: Step-by-step process: Hold down the &quot;BOOT&quot; button and keep it pressedWhile holding BOOT, press and release the &quot;RESET&quot; button (quick tap)Release the &quot;BOOT&quot; button ‚úÖ The ESP32-C6 is now in bootloader mode and ready to receive firmware  Important Timing Make sure to hold the BOOT button BEFORE pressing RESET, and only release BOOT after you've released RESET. This timing is critical for entering bootloader mode correctly.  ","version":"Next","tagName":"h3"},{"title":"Method A: Flash via USB Console App‚Äã","type":1,"pageTitle":"Bottlenose Getting Started Guide","url":"/extending-with-orcas/bottlenose-wifi-orca/bottlenose-getting-started/#method-a-flash-via-usb-console-app","content":" Connect to FREE-WILi via USB and open your serial terminal application Navigate to ESP32 Flasher Menu: Main Menu ‚Üí Extended Menus (e) ‚Üí Extended Menus (e) Press e to enter Extended MenusPress e again to access the ESP32 Flasher menu Select Bottlenose Firmware: In the ESP32 Flasher menu, press n to select the option for flashing Bottlenose firmwareYou should see: &quot;Flash Bottlenose WiFi Orca Firmware&quot; Initiate Flashing: Follow the on-screen promptsThe console will show flashing progressWait for &quot;Flashing Complete&quot; message  Expected Console Output:  ESP32 Flasher Menu ================== n) Flash Bottlenose WiFi Orca Firmware x) Return to Main Menu Selection: n [FLASHER] Detecting ESP32-C6 in bootloader mode... [FLASHER] ESP32-C6 detected successfully [FLASHER] Starting firmware flash... [FLASHER] Writing bootloader... [‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà] 100% [FLASHER] Writing application... [‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà] 100% [FLASHER] Writing partitions... [‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà] 100% [FLASHER] Flashing completed successfully! [FLASHER] Resetting ESP32-C6...   ","version":"Next","tagName":"h3"},{"title":"Method B: Flash via FREE-WILi UI‚Äã","type":1,"pageTitle":"Bottlenose Getting Started Guide","url":"/extending-with-orcas/bottlenose-wifi-orca/bottlenose-getting-started/#method-b-flash-via-free-wili-ui","content":" Open FREE-WILi Web Interface: Connect to FREE-WILi via network or USBOpen the FREE-WILi web interface in your browser Navigate to Wireless Menu: Click on the &quot;Wireless&quot; menu in the main navigationThis will open the wireless configuration pages Find ESP32 Flasher Page: Cycle through the pages in the wireless menu (use Next/Previous buttons)Look for the page titled &quot;ESP32 Default App Flasher&quot;This page contains the firmware flashing controls Flash Firmware: On the ESP32 Default App Flasher page, you'll see options for different modulesFind the &quot;Bottlenose WiFi Orca&quot; sectionClick the green &quot;Flash Firmware&quot; button to initiate flashing Monitor Progress: The interface will show a progress bar during flashingWait for the &quot;Flashing Complete&quot; confirmation messageThe ESP32-C6 will automatically reset after successful flashing  ","version":"Next","tagName":"h3"},{"title":"Verify Successful Flashing‚Äã","type":1,"pageTitle":"Bottlenose Getting Started Guide","url":"/extending-with-orcas/bottlenose-wifi-orca/bottlenose-getting-started/#verify-successful-flashing","content":" After flashing completes:  Check Status Indicators: Look for LED indicators on Bottlenose (if present)Status LEDs should show normal operation patterns Verify Communication: The FREE-WILi interface should detect the Bottlenose moduleCheck the Orcas menu for Bottlenose options Test Basic Functionality: Try connecting to WiFi through BottlenoseVerify Bt functionality if needed  ","version":"Next","tagName":"h3"},{"title":"Troubleshooting Firmware Flashing‚Äã","type":1,"pageTitle":"Bottlenose Getting Started Guide","url":"/extending-with-orcas/bottlenose-wifi-orca/bottlenose-getting-started/#troubleshooting-firmware-flashing","content":" Common Issues:‚Äã  Problem: &quot;ESP32-C6 not detected in bootloader mode&quot;  Solution: Repeat the bootloader entry processCheck: Ensure BOOT button timing is correct (hold BOOT, tap RESET, release BOOT)Verify: Bottlenose is properly connected to FREE-WILi with power  Problem: &quot;Flashing failed&quot; or &quot;Connection timeout&quot;  Solution: Reset both FREE-WILi and BottlenoseRetry entering bootloader modeAttempt flashing again Check: USB connection is stable (for console method)  Problem: &quot;No firmware available&quot; message  Solution: Ensure FREE-WILi firmware is up to dateCheck: FREE-WILi firmware includes latest Bottlenose firmwareAction: Update FREE-WILi firmware if necessary  Problem: Flashing appears successful but module doesn't work  Solution: Perform a hard reset: hold RESET button for 5 secondsCheck hardware connectionsTry flashing again Check: Power supply is stable during operation  Firmware Updates The Bottlenose firmware embedded in FREE-WILi may be updated with new FREE-WILi firmware releases. Check for FREE-WILi updates periodically to get the latest Bottlenose features and improvements.  ","version":"Next","tagName":"h3"},{"title":"Understanding the Default Bottlenose Application‚Äã","type":1,"pageTitle":"Bottlenose Getting Started Guide","url":"/extending-with-orcas/bottlenose-wifi-orca/bottlenose-getting-started/#understanding-the-default-bottlenose-application","content":" Once firmware is flashed successfully, Bottlenose runs a default application that provides several key networking and communication features:  Core Functionality‚Äã  The default Bottlenose app is designed to extend FREE-WILi's connectivity options:  üåê WebSocket Terminal Bridge - Bridges FREE-WILi's main terminal over WebSocket connectionsüì± Bt Terminal Bridge - Provides terminal access via Bt Low Energyüì° WiFi Network Scanner - Scans for available WiFi access pointsüîç Bt Device Scanner - Discovers nearby Bt devicesüíª HTTP Web Browser Interface - Hosts a web server for browser-based terminal access  Default App Benefits‚Äã  Remote Access: Control FREE-WILi wirelessly through WiFi or BtWeb Integration: Access FREE-WILi terminal from any web browserNetwork Discovery: Find and connect to available networksCross-Platform: Works with phones, tablets, laptops, and other devicesNo Additional Software: Built-in web server requires no special apps  Typical Usage Scenarios‚Äã  Wireless Debugging: Access FREE-WILi terminal without USB cableRemote Configuration: Configure settings from across the roomMultiple Users: Share access through web interfaceMobile Integration: Control FREE-WILi from smartphone or tabletNetwork Troubleshooting: Scan and analyze WiFi/Bt environments    ","version":"Next","tagName":"h3"},{"title":"Step 3: Configure Bottlenose Settings‚Äã","type":1,"pageTitle":"Bottlenose Getting Started Guide","url":"/extending-with-orcas/bottlenose-wifi-orca/bottlenose-getting-started/#step-3-configure-bottlenose-settings","content":" Before using Bottlenose functionality, you need to configure the networking and communication settings through FREE-WILi's configuration system.  ","version":"Next","tagName":"h2"},{"title":"Accessing Configuration Settings‚Äã","type":1,"pageTitle":"Bottlenose Getting Started Guide","url":"/extending-with-orcas/bottlenose-wifi-orca/bottlenose-getting-started/#accessing-configuration-settings","content":" Connect to FREE-WILi via USB console or web interfaceNavigate to Settings menuFind Bottlenose configuration sections: WiFi, Bt, and WebSocket Server  ","version":"Next","tagName":"h3"},{"title":"WiFi Configuration‚Äã","type":1,"pageTitle":"Bottlenose Getting Started Guide","url":"/extending-with-orcas/bottlenose-wifi-orca/bottlenose-getting-started/#wifi-configuration","content":" Configure Bottlenose WiFi functionality through the WiFi settings menu:  ======== Configure Wifi ======== s) Enable Wifi Station Mode [off] d) SSID for Wifi Station Mode [] p) Password for Wifi Station Mode [] a) Enable Access Point Mode [off] u) Access Point Authentication [open] h) Access Point hide SSID [visible] g) SSID for Access Point [] x) Password for Access Point []   WiFi Settings Explained:‚Äã  Station Mode Settings:  s) Enable Wifi Station Mode - Connect Bottlenose to existing WiFi networkd) SSID for Station Mode - Network name to connect top) Password for Station Mode - Network password (leave blank for open networks)  Access Point Mode Settings:  a) Enable Access Point Mode - Create WiFi hotspot using Bottlenoseu) Access Point Authentication - Security type (open/WPA2/WPA3)h) Access Point Hide SSID - Make hotspot visible or hiddeng) SSID for Access Point - Hotspot name (e.g., &quot;Bottlenose_AP&quot;)x) Password for Access Point - Hotspot password (8+ characters for secured networks)  WiFi Configuration Example:‚Äã  Configure WiFi for home network connection: s) Enable Wifi Station Mode [on] d) SSID for Wifi Station Mode [MyHomeWiFi] p) Password for Wifi Station Mode [mypassword123] a) Enable Access Point Mode [off] Or configure as mobile hotspot: s) Enable Wifi Station Mode [off] a) Enable Access Point Mode [on] u) Access Point Authentication [WPA2] h) Access Point hide SSID [visible] g) SSID for Access Point [Bottlenose_Mobile] x) Password for Access Point [mobile123secure]   ","version":"Next","tagName":"h3"},{"title":"Bt Configuration‚Äã","type":1,"pageTitle":"Bottlenose Getting Started Guide","url":"/extending-with-orcas/bottlenose-wifi-orca/bottlenose-getting-started/#bt-configuration","content":" Configure Bottlenose Bt functionality:  ======== Configure BT ======== s) Enable BT [off] t) BT Terminal Bridge [off] a) BT Advertising Name []   Bt Settings Explained:‚Äã  s) Enable BT - Turn on Bt Low Energy functionalityt) BT Terminal Bridge - Enable terminal access via Bt connectionsa) BT Advertising Name - Device name visible to other Bt devices  Bt Configuration Example:‚Äã  Enable Bt with terminal access: s) Enable BT [on] t) BT Terminal Bridge [on] a) BT Advertising Name [Bottlenose_Terminal_01]   Bt Device Names Choose descriptive names for easy identification when multiple Bottlenose devices are nearby. Include location or purpose in the name (e.g., &quot;Lab_Bottlenose&quot;, &quot;Mobile_Unit_A&quot;).  ","version":"Next","tagName":"h3"},{"title":"WebSocket Server Configuration‚Äã","type":1,"pageTitle":"Bottlenose Getting Started Guide","url":"/extending-with-orcas/bottlenose-wifi-orca/bottlenose-getting-started/#websocket-server-configuration","content":" Configure the web-based terminal access:  ======== Websocket Server Configuration ======== r) Start Websocket Server [on] p) Websocket Server Port [8765] m) Authentication Mode [open] u) Authentication Username [] d) Authentication Password []   WebSocket Settings Explained:‚Äã  r) Start Websocket Server - Enable web-based terminal accessp) Websocket Server Port - TCP port for web connections (default: 8765)m) Authentication Mode - Security level (open/password-protected)u) Authentication Username - Login username (if authentication enabled)d) Authentication Password - Login password (if authentication enabled)  WebSocket Configuration Examples:‚Äã  Open Access (No Authentication):  r) Start Websocket Server [on] p) Websocket Server Port [8765] m) Authentication Mode [open]   Secure Access (Password Protected):  r) Start Websocket Server [on] p) Websocket Server Port [8765] m) Authentication Mode [password] u) Authentication Username [admin] d) Authentication Password [secure123]   ","version":"Next","tagName":"h3"},{"title":"Configuration Workflow‚Äã","type":1,"pageTitle":"Bottlenose Getting Started Guide","url":"/extending-with-orcas/bottlenose-wifi-orca/bottlenose-getting-started/#configuration-workflow","content":" Basic Setup (WiFi + Web Access):‚Äã  Configure WiFi Station Mode: Enable WiFi Station ModeSet your network SSID and passwordSave settings Enable WebSocket Server: Start WebSocket ServerUse default port 8765 or customizeConfigure authentication if needed Test Connection: Restart Bottlenose to apply settingsConnect to your WiFi networkAccess web interface via browser  Advanced Setup (Full Functionality):‚Äã  Configure All Services: Set up WiFi (Station and/or AP mode)Enable Bt with custom device nameConfigure WebSocket server with authentication Security Considerations: Use strong passwords for AP modeEnable WebSocket authentication for public networksChoose unique Bt advertising names Test All Interfaces: Verify WiFi connection and web accessTest Bt terminal connectivityConfirm WebSocket server accessibility  ","version":"Next","tagName":"h3"},{"title":"Applying Configuration Changes‚Äã","type":1,"pageTitle":"Bottlenose Getting Started Guide","url":"/extending-with-orcas/bottlenose-wifi-orca/bottlenose-getting-started/#applying-configuration-changes","content":" After configuring settings:  Save Configuration: Exit settings menus to save changesConfiguration is stored in FREE-WILi's non-volatile memory Restart Services: Restart FREE-WILi or power cycle to apply all settingsBottlenose will automatically start with new configuration Verify Operation: Check WiFi connection statusTest Bt discoverabilityConfirm web server accessibility  Access Your Configured Bottlenose:‚Äã  Via Web Browser:  Connect to same WiFi network as BottlenoseNavigate to: http://&lt;bottlenose-ip&gt;:8765Use authentication credentials if configured  Via Bt:  Scan for Bt devicesConnect to your configured device nameAccess terminal through BLE app  Via WiFi Hotspot:  Connect device to Bottlenose APNavigate to: http://192.168.4.1:8765Access terminal interface    ","version":"Next","tagName":"h3"},{"title":"Step 4: Set Up Your Project‚Äã","type":1,"pageTitle":"Bottlenose Getting Started Guide","url":"/extending-with-orcas/bottlenose-wifi-orca/bottlenose-getting-started/#step-4-set-up-your-project","content":" ","version":"Next","tagName":"h2"},{"title":"Create New Project‚Äã","type":1,"pageTitle":"Bottlenose Getting Started Guide","url":"/extending-with-orcas/bottlenose-wifi-orca/bottlenose-getting-started/#create-new-project","content":" # Clone the ESP-IDF example template git clone https://github.com/espressif/esp-idf.git cd esp-idf/examples/get-started/hello_world cp -r hello_world ../../../bottlenose_first_project cd ../../../bottlenose_first_project   ","version":"Next","tagName":"h3"},{"title":"Project Configuration‚Äã","type":1,"pageTitle":"Bottlenose Getting Started Guide","url":"/extending-with-orcas/bottlenose-wifi-orca/bottlenose-getting-started/#project-configuration","content":" # Configure for ESP32-C6 idf.py set-target esp32c6 # Open menuconfig for additional settings idf.py menuconfig   In menuconfig:  Navigate to Example Connection ConfigurationSet your WiFi SSID and passwordNavigate to Component config ‚Üí ESP32C6-SpecificConfigure power management settings  ","version":"Next","tagName":"h3"},{"title":"Step 5: Basic WiFi Code‚Äã","type":1,"pageTitle":"Bottlenose Getting Started Guide","url":"/extending-with-orcas/bottlenose-wifi-orca/bottlenose-getting-started/#step-5-basic-wifi-code","content":" Replace the contents of main/hello_world_main.c:  #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &quot;freertos/FreeRTOS.h&quot; #include &quot;freertos/task.h&quot; #include &quot;freertos/event_groups.h&quot; #include &quot;esp_system.h&quot; #include &quot;esp_wifi.h&quot; #include &quot;esp_event.h&quot; #include &quot;esp_log.h&quot; #include &quot;nvs_flash.h&quot; #include &quot;driver/gpio.h&quot; // WiFi credentials #define WIFI_SSID &quot;YourWiFiNetwork&quot; #define WIFI_PASS &quot;YourPassword&quot; // GPIO pins #define LED_WIFI_PIN 2 #define LED_STATUS_PIN 8 static const char *TAG = &quot;BottlenoseDemo&quot;; static EventGroupHandle_t s_wifi_event_group; static const int WIFI_CONNECTED_BIT = BIT0; static void wifi_event_handler(void* arg, esp_event_base_t event_base, int32_t event_id, void* event_data) { if (event_base == WIFI_EVENT &amp;&amp; event_id == WIFI_EVENT_STA_START) { esp_wifi_connect(); } else if (event_base == WIFI_EVENT &amp;&amp; event_id == WIFI_EVENT_STA_DISCONNECTED) { esp_wifi_connect(); ESP_LOGI(TAG, &quot;Retrying WiFi connection...&quot;); gpio_set_level(LED_WIFI_PIN, 0); // Turn off WiFi LED } else if (event_base == IP_EVENT &amp;&amp; event_id == IP_EVENT_STA_GOT_IP) { ip_event_got_ip_t* event = (ip_event_got_ip_t*) event_data; ESP_LOGI(TAG, &quot;Got IP:&quot; IPSTR, IP2STR(&amp;event-&gt;ip_info.ip)); xEventGroupSetBits(s_wifi_event_group, WIFI_CONNECTED_BIT); gpio_set_level(LED_WIFI_PIN, 1); // Turn on WiFi LED } } void wifi_init_sta(void) { s_wifi_event_group = xEventGroupCreate(); ESP_ERROR_CHECK(esp_netif_init()); ESP_ERROR_CHECK(esp_event_loop_create_default()); esp_netif_create_default_wifi_sta(); wifi_init_config_t cfg = WIFI_INIT_CONFIG_DEFAULT(); ESP_ERROR_CHECK(esp_wifi_init(&amp;cfg)); esp_event_handler_instance_t instance_any_id; esp_event_handler_instance_t instance_got_ip; ESP_ERROR_CHECK(esp_event_handler_instance_register(WIFI_EVENT, ESP_EVENT_ANY_ID, &amp;wifi_event_handler, NULL, &amp;instance_any_id)); ESP_ERROR_CHECK(esp_event_handler_instance_register(IP_EVENT, IP_EVENT_STA_GOT_IP, &amp;wifi_event_handler, NULL, &amp;instance_got_ip)); wifi_config_t wifi_config = { .sta = { .ssid = WIFI_SSID, .password = WIFI_PASS, }, }; ESP_ERROR_CHECK(esp_wifi_set_mode(WIFI_MODE_STA) ); ESP_ERROR_CHECK(esp_wifi_set_config(WIFI_IF_STA, &amp;wifi_config) ); ESP_ERROR_CHECK(esp_wifi_start() ); ESP_LOGI(TAG, &quot;WiFi initialization finished.&quot;); } void init_gpio(void) { gpio_config_t io_conf = { .pin_bit_mask = (1ULL &lt;&lt; LED_WIFI_PIN) | (1ULL &lt;&lt; LED_STATUS_PIN), .mode = GPIO_MODE_OUTPUT, .pull_up_en = GPIO_PULLUP_DISABLE, .pull_down_en = GPIO_PULLDOWN_DISABLE, .intr_type = GPIO_INTR_DISABLE }; gpio_config(&amp;io_conf); } void status_task(void *pvParameters) { int counter = 0; while (1) { // Blink status LED gpio_set_level(LED_STATUS_PIN, counter % 2); // Print status every 10 seconds if (counter % 10 == 0) { ESP_LOGI(TAG, &quot;System running for %d seconds&quot;, counter); ESP_LOGI(TAG, &quot;Free heap: %d bytes&quot;, esp_get_free_heap_size()); // Check WiFi status wifi_ap_record_t ap_info; if (esp_wifi_sta_get_ap_info(&amp;ap_info) == ESP_OK) { ESP_LOGI(TAG, &quot;Connected to: %s, RSSI: %d&quot;, ap_info.ssid, ap_info.rssi); } } counter++; vTaskDelay(pdMS_TO_TICKS(1000)); } } void app_main(void) { ESP_LOGI(TAG, &quot;Bottlenose WiFi Orca - Getting Started Example&quot;); ESP_LOGI(TAG, &quot;===============================================&quot;); // Initialize NVS esp_err_t ret = nvs_flash_init(); if (ret == ESP_ERR_NVS_NO_FREE_PAGES || ret == ESP_ERR_NVS_NEW_VERSION_FOUND) { ESP_ERROR_CHECK(nvs_flash_erase()); ret = nvs_flash_init(); } ESP_ERROR_CHECK(ret); // Initialize GPIO init_gpio(); // Initialize WiFi ESP_LOGI(TAG, &quot;Initializing WiFi...&quot;); wifi_init_sta(); // Wait for connection EventBits_t bits = xEventGroupWaitBits(s_wifi_event_group, WIFI_CONNECTED_BIT, pdFALSE, pdFALSE, portMAX_DELAY); if (bits &amp; WIFI_CONNECTED_BIT) { ESP_LOGI(TAG, &quot;Connected to WiFi successfully!&quot;); } else { ESP_LOGE(TAG, &quot;Failed to connect to WiFi&quot;); return; } // Start status task xTaskCreate(status_task, &quot;status_task&quot;, 4096, NULL, 5, NULL); ESP_LOGI(TAG, &quot;System initialized. Check the LEDs and monitor output!&quot;); }   ","version":"Next","tagName":"h2"},{"title":"Step 6: Update CMakeLists.txt‚Äã","type":1,"pageTitle":"Bottlenose Getting Started Guide","url":"/extending-with-orcas/bottlenose-wifi-orca/bottlenose-getting-started/#step-6-update-cmakeliststxt","content":" Update main/CMakeLists.txt to include required components:  idf_component_register(SRCS &quot;hello_world_main.c&quot; INCLUDE_DIRS &quot;.&quot; REQUIRES wifi nvs_flash)   ","version":"Next","tagName":"h2"},{"title":"Step 7: Configure WiFi Credentials‚Äã","type":1,"pageTitle":"Bottlenose Getting Started Guide","url":"/extending-with-orcas/bottlenose-wifi-orca/bottlenose-getting-started/#step-7-configure-wifi-credentials","content":" Edit the WiFi credentials in the code:  #define WIFI_SSID &quot;YourWiFiNetwork&quot; // Replace with your network name #define WIFI_PASS &quot;YourPassword&quot; // Replace with your password   ","version":"Next","tagName":"h2"},{"title":"Step 8: Build and Flash‚Äã","type":1,"pageTitle":"Bottlenose Getting Started Guide","url":"/extending-with-orcas/bottlenose-wifi-orca/bottlenose-getting-started/#step-8-build-and-flash","content":" ","version":"Next","tagName":"h2"},{"title":"Build the project‚Äã","type":1,"pageTitle":"Bottlenose Getting Started Guide","url":"/extending-with-orcas/bottlenose-wifi-orca/bottlenose-getting-started/#build-the-project","content":" idf.py build   ","version":"Next","tagName":"h3"},{"title":"Flash to Bottlenose‚Äã","type":1,"pageTitle":"Bottlenose Getting Started Guide","url":"/extending-with-orcas/bottlenose-wifi-orca/bottlenose-getting-started/#flash-to-bottlenose","content":" idf.py -p COM3 flash # Replace COM3 with your port   ","version":"Next","tagName":"h3"},{"title":"Monitor output‚Äã","type":1,"pageTitle":"Bottlenose Getting Started Guide","url":"/extending-with-orcas/bottlenose-wifi-orca/bottlenose-getting-started/#monitor-output","content":" idf.py -p COM3 monitor   You should see output like:  I (324) BottlenoseDemo: Bottlenose WiFi Orca - Getting Started Example I (324) BottlenoseDemo: =============================================== I (334) BottlenoseDemo: Initializing WiFi... I (344) BottlenoseDemo: WiFi initialization finished. I (2344) BottlenoseDemo: Connected to WiFi successfully! I (3344) BottlenoseDemo: System running for 0 seconds I (3344) BottlenoseDemo: Free heap: 290876 bytes I (3344) BottlenoseDemo: Connected to: YourWiFiNetwork, RSSI: -45   ","version":"Next","tagName":"h3"},{"title":"Step 9: Add HTTP Client (Optional)‚Äã","type":1,"pageTitle":"Bottlenose Getting Started Guide","url":"/extending-with-orcas/bottlenose-wifi-orca/bottlenose-getting-started/#step-9-add-http-client-optional","content":" To make your Bottlenose send data over WiFi, add this HTTP client code:  #include &quot;esp_http_client.h&quot; esp_err_t http_event_handler(esp_http_client_event_t *evt) { switch(evt-&gt;event_id) { case HTTP_EVENT_ERROR: ESP_LOGD(TAG, &quot;HTTP_EVENT_ERROR&quot;); break; case HTTP_EVENT_ON_CONNECTED: ESP_LOGD(TAG, &quot;HTTP_EVENT_ON_CONNECTED&quot;); break; case HTTP_EVENT_HEADERS_SENT: ESP_LOGD(TAG, &quot;HTTP_EVENT_HEADERS_SENT&quot;); break; case HTTP_EVENT_ON_FINISH: ESP_LOGD(TAG, &quot;HTTP_EVENT_ON_FINISH&quot;); break; default: break; } return ESP_OK; } void send_http_request(void) { esp_http_client_config_t config = { .url = &quot;http://httpbin.org/post&quot;, .event_handler = http_event_handler, }; esp_http_client_handle_t client = esp_http_client_init(&amp;config); // Set POST data const char *post_data = &quot;{\\&quot;device\\&quot;:\\&quot;Bottlenose\\&quot;,\\&quot;status\\&quot;:\\&quot;online\\&quot;}&quot;; esp_http_client_set_method(client, HTTP_METHOD_POST); esp_http_client_set_header(client, &quot;Content-Type&quot;, &quot;application/json&quot;); esp_http_client_set_post_field(client, post_data, strlen(post_data)); // Perform request esp_err_t err = esp_http_client_perform(client); if (err == ESP_OK) { ESP_LOGI(TAG, &quot;HTTP POST Status = %d&quot;, esp_http_client_get_status_code(client)); } else { ESP_LOGE(TAG, &quot;HTTP POST request failed: %s&quot;, esp_err_to_name(err)); } esp_http_client_cleanup(client); }   ","version":"Next","tagName":"h2"},{"title":"Step 10: Test Your Setup‚Äã","type":1,"pageTitle":"Bottlenose Getting Started Guide","url":"/extending-with-orcas/bottlenose-wifi-orca/bottlenose-getting-started/#step-10-test-your-setup","content":" ","version":"Next","tagName":"h2"},{"title":"Expected Results‚Äã","type":1,"pageTitle":"Bottlenose Getting Started Guide","url":"/extending-with-orcas/bottlenose-wifi-orca/bottlenose-getting-started/#expected-results","content":" Serial Monitor: Continuous status updates and WiFi connection infoLEDs: Status LED should blink every secondWiFi LED should be solid when connected Network: Device should appear in your router's connected devices list  ","version":"Next","tagName":"h3"},{"title":"Verify Connection‚Äã","type":1,"pageTitle":"Bottlenose Getting Started Guide","url":"/extending-with-orcas/bottlenose-wifi-orca/bottlenose-getting-started/#verify-connection","content":" Check your router's admin page for the connected deviceTry pinging the IP address shown in the monitorMonitor signal strength (RSSI) values  ","version":"Next","tagName":"h3"},{"title":"Troubleshooting‚Äã","type":1,"pageTitle":"Bottlenose Getting Started Guide","url":"/extending-with-orcas/bottlenose-wifi-orca/bottlenose-getting-started/#troubleshooting","content":" ","version":"Next","tagName":"h2"},{"title":"WiFi Issues‚Äã","type":1,"pageTitle":"Bottlenose Getting Started Guide","url":"/extending-with-orcas/bottlenose-wifi-orca/bottlenose-getting-started/#wifi-issues","content":" Problem: &quot;Failed to connect to WiFi&quot;  Solution: Double-check SSID and passwordCheck: Verify 2.4GHz network (ESP32-C6 doesn't support 5GHz)  Problem: Frequent disconnections  Solution: Move closer to router or check signal strengthCheck: Router compatibility with ESP32 devices  ","version":"Next","tagName":"h3"},{"title":"Power Issues‚Äã","type":1,"pageTitle":"Bottlenose Getting Started Guide","url":"/extending-with-orcas/bottlenose-wifi-orca/bottlenose-getting-started/#power-issues","content":" Problem: Device resets randomly  Solution: Check power supply stabilityCheck: USB cable quality and connection  ","version":"Next","tagName":"h3"},{"title":"Programming Issues‚Äã","type":1,"pageTitle":"Bottlenose Getting Started Guide","url":"/extending-with-orcas/bottlenose-wifi-orca/bottlenose-getting-started/#programming-issues","content":" Problem: Flash/upload failures  Solution: Try different baud rates or portsCheck: USB drivers installation  ","version":"Next","tagName":"h3"},{"title":"Next Steps‚Äã","type":1,"pageTitle":"Bottlenose Getting Started Guide","url":"/extending-with-orcas/bottlenose-wifi-orca/bottlenose-getting-started/#next-steps","content":" Congratulations! You now have a working Bottlenose WiFi system. Here are some ideas for expanding your project:  ","version":"Next","tagName":"h2"},{"title":"Immediate Improvements‚Äã","type":1,"pageTitle":"Bottlenose Getting Started Guide","url":"/extending-with-orcas/bottlenose-wifi-orca/bottlenose-getting-started/#immediate-improvements","content":" Add web server to control the device remotelyImplement MQTT client for IoT communicationAdd sensor reading and data transmissionCreate mobile app interface  ","version":"Next","tagName":"h3"},{"title":"Advanced Features‚Äã","type":1,"pageTitle":"Bottlenose Getting Started Guide","url":"/extending-with-orcas/bottlenose-wifi-orca/bottlenose-getting-started/#advanced-features","content":" OTA updates for wireless firmware updatesWiFi mesh networking with multiple devicesBt configuration for easy setupIntegration with FREE-WILi commands  ","version":"Next","tagName":"h3"},{"title":"Learning Resources‚Äã","type":1,"pageTitle":"Bottlenose Getting Started Guide","url":"/extending-with-orcas/bottlenose-wifi-orca/bottlenose-getting-started/#learning-resources","content":" Bottlenose Interfacing Guide - Deep dive into programmingHardware Hookup Guide - Physical connectionsBottlenose Troubleshooting - Common problems and solutionsMain Bottlenose Documentation - Complete feature overview  ","version":"Next","tagName":"h3"},{"title":"Code Repository‚Äã","type":1,"pageTitle":"Bottlenose Getting Started Guide","url":"/extending-with-orcas/bottlenose-wifi-orca/bottlenose-getting-started/#code-repository","content":" The complete example code is available at:  https://github.com/freewili/bottlenose-examples/getting-started   ","version":"Next","tagName":"h2"},{"title":"Community and Support‚Äã","type":1,"pageTitle":"Bottlenose Getting Started Guide","url":"/extending-with-orcas/bottlenose-wifi-orca/bottlenose-getting-started/#community-and-support","content":" Forum: Join the FREE-WILi community forum for questions and project sharingGitHub: Submit issues and feature requestsDocumentation: Check the main documentation for advanced topics  Happy networking with your Bottlenose WiFi Orca!    ","version":"Next","tagName":"h2"},{"title":"Going Further: Custom ESP32-C6 Programming‚Äã","type":1,"pageTitle":"Bottlenose Getting Started Guide","url":"/extending-with-orcas/bottlenose-wifi-orca/bottlenose-getting-started/#going-further-custom-esp32-c6-programming","content":" For advanced users who want to develop custom applications on the ESP32-C6, you can program the Bottlenose directly using standard ESP32 development tools.  ","version":"Next","tagName":"h2"},{"title":"Development Setup Requirements‚Äã","type":1,"pageTitle":"Bottlenose Getting Started Guide","url":"/extending-with-orcas/bottlenose-wifi-orca/bottlenose-getting-started/#development-setup-requirements","content":" Before you begin custom programming, you'll need:  ESP-IDF or Arduino IDE installed on your computerUSB-C cable for JTAG debugging and programmingBottlenose connected to FREE-WILi for power (USB port is data-only!)ESPTool for firmware flashing  Power Requirements ‚ö†Ô∏è CRITICAL: The USB-C port on Bottlenose is DATA ONLY - it does NOT provide power to the ESP32-C6. You MUST connect Bottlenose to FREE-WILi via the Orca connector to power the device, even when programming via USB.  ","version":"Next","tagName":"h3"},{"title":"Step 1: Install Development Environment‚Äã","type":1,"pageTitle":"Bottlenose Getting Started Guide","url":"/extending-with-orcas/bottlenose-wifi-orca/bottlenose-getting-started/#step-1-install-development-environment","content":" Choose your preferred development environment:  Option A: ESP-IDF (Recommended for Advanced Features)‚Äã  # Install ESP-IDF git clone -b release/v5.1 --recursive https://github.com/espressif/esp-idf.git cd esp-idf ./install.sh esp32c6 # Set up environment . ./export.sh   Option B: Arduino IDE (Easier for Beginners)‚Äã  Install Arduino IDEAdd ESP32 board package: https://espressif.github.io/arduino-esp32/package_esp32_index.jsonSelect &quot;ESP32C6 Dev Module&quot; as target board  Option C: PlatformIO (Professional IDE)‚Äã  # Install PlatformIO extension in VS Code # Create new project with board: esp32-c6-devkitc-1   ","version":"Next","tagName":"h3"},{"title":"Step 2: Hardware Connection for Programming‚Äã","type":1,"pageTitle":"Bottlenose Getting Started Guide","url":"/extending-with-orcas/bottlenose-wifi-orca/bottlenose-getting-started/#step-2-hardware-connection-for-programming","content":" Power Setup: Connect Bottlenose to FREE-WILi via Orca connector (for power)Keep FREE-WILi powered on during programming Programming Connection: Connect USB-C cable from computer to Bottlenose USB portThis provides JTAG debugging and programming interface Verify Connection: # Check if ESP32-C6 is detected esptool.py --list-ports # Should show your COM port   ","version":"Next","tagName":"h3"},{"title":"Step 3: Basic Custom Application‚Äã","type":1,"pageTitle":"Bottlenose Getting Started Guide","url":"/extending-with-orcas/bottlenose-wifi-orca/bottlenose-getting-started/#step-3-basic-custom-application","content":" Here's a simple example to get you started with custom Bottlenose programming:  ESP-IDF Example - WiFi Status LED‚Äã  #include &quot;freertos/FreeRTOS.h&quot; #include &quot;freertos/task.h&quot; #include &quot;esp_wifi.h&quot; #include &quot;esp_event.h&quot; #include &quot;nvs_flash.h&quot; #include &quot;driver/gpio.h&quot; #include &quot;esp_log.h&quot; #define WIFI_SSID &quot;YourNetwork&quot; #define WIFI_PASS &quot;YourPassword&quot; #define LED_PIN GPIO_NUM_2 static const char *TAG = &quot;BottlenoseCustom&quot;; static void wifi_event_handler(void* arg, esp_event_base_t event_base, int32_t event_id, void* event_data) { if (event_base == WIFI_EVENT &amp;&amp; event_id == WIFI_EVENT_STA_START) { esp_wifi_connect(); } else if (event_base == WIFI_EVENT &amp;&amp; event_id == WIFI_EVENT_STA_DISCONNECTED) { gpio_set_level(LED_PIN, 0); // Turn off LED esp_wifi_connect(); ESP_LOGI(TAG, &quot;Retrying WiFi connection...&quot;); } else if (event_base == IP_EVENT &amp;&amp; event_id == IP_EVENT_STA_GOT_IP) { gpio_set_level(LED_PIN, 1); // Turn on LED ip_event_got_ip_t* event = (ip_event_got_ip_t*) event_data; ESP_LOGI(TAG, &quot;Got IP:&quot; IPSTR, IP2STR(&amp;event-&gt;ip_info.ip)); } } void app_main(void) { ESP_LOGI(TAG, &quot;Starting Bottlenose Custom Application&quot;); // Initialize LED gpio_config_t led_config = { .pin_bit_mask = (1ULL &lt;&lt; LED_PIN), .mode = GPIO_MODE_OUTPUT, .pull_up_en = GPIO_PULLUP_DISABLE, .pull_down_en = GPIO_PULLDOWN_DISABLE, .intr_type = GPIO_INTR_DISABLE }; gpio_config(&amp;led_config); // Initialize NVS esp_err_t ret = nvs_flash_init(); if (ret == ESP_ERR_NVS_NO_FREE_PAGES || ret == ESP_ERR_NVS_NEW_VERSION_FOUND) { ESP_ERROR_CHECK(nvs_flash_erase()); ret = nvs_flash_init(); } ESP_ERROR_CHECK(ret); // Initialize WiFi ESP_ERROR_CHECK(esp_netif_init()); ESP_ERROR_CHECK(esp_event_loop_create_default()); esp_netif_create_default_wifi_sta(); wifi_init_config_t cfg = WIFI_INIT_CONFIG_DEFAULT(); ESP_ERROR_CHECK(esp_wifi_init(&amp;cfg)); esp_event_handler_instance_register(WIFI_EVENT, ESP_EVENT_ANY_ID, &amp;wifi_event_handler, NULL, NULL); esp_event_handler_instance_register(IP_EVENT, IP_EVENT_STA_GOT_IP, &amp;wifi_event_handler, NULL, NULL); wifi_config_t wifi_config = { .sta = { .ssid = WIFI_SSID, .password = WIFI_PASS, }, }; ESP_ERROR_CHECK(esp_wifi_set_mode(WIFI_MODE_STA)); ESP_ERROR_CHECK(esp_wifi_set_config(WIFI_IF_STA, &amp;wifi_config)); ESP_ERROR_CHECK(esp_wifi_start()); // Main application loop while (1) { ESP_LOGI(TAG, &quot;Custom application running...&quot;); vTaskDelay(pdMS_TO_TICKS(10000)); } }   Arduino Example - Bt Beacon‚Äã  #include &quot;WiFi.h&quot; #include &quot;BtSerial.h&quot; BtSerial SerialBT; const int ledPin = 2; void setup() { Serial.begin(115200); pinMode(ledPin, OUTPUT); // Initialize Bt SerialBT.begin(&quot;Bottlenose-Custom&quot;); Serial.println(&quot;Bottlenose custom firmware started!&quot;); Serial.println(&quot;Bt discoverable as: Bottlenose-Custom&quot;); // Startup LED sequence for(int i = 0; i &lt; 5; i++) { digitalWrite(ledPin, HIGH); delay(200); digitalWrite(ledPin, LOW); delay(200); } } void loop() { // Handle Bt communication if (SerialBT.available()) { String command = SerialBT.readString(); command.trim(); if (command == &quot;LED_ON&quot;) { digitalWrite(ledPin, HIGH); SerialBT.println(&quot;LED turned ON&quot;); } else if (command == &quot;LED_OFF&quot;) { digitalWrite(ledPin, LOW); SerialBT.println(&quot;LED turned OFF&quot;); } else if (command == &quot;STATUS&quot;) { SerialBT.printf(&quot;Free heap: %d bytes\\n&quot;, ESP.getFreeHeap()); SerialBT.printf(&quot;WiFi MAC: %s\\n&quot;, WiFi.macAddress().c_str()); } } // Periodic status blink digitalWrite(ledPin, HIGH); delay(100); digitalWrite(ledPin, LOW); delay(2900); }   ","version":"Next","tagName":"h3"},{"title":"Step 4: Build and Flash Custom Firmware‚Äã","type":1,"pageTitle":"Bottlenose Getting Started Guide","url":"/extending-with-orcas/bottlenose-wifi-orca/bottlenose-getting-started/#step-4-build-and-flash-custom-firmware","content":" ESP-IDF Method:‚Äã  # Create project directory mkdir bottlenose-custom &amp;&amp; cd bottlenose-custom idf.py create-project bottlenose-app # Set target to ESP32-C6 idf.py set-target esp32c6 # Build the project idf.py build # Flash to Bottlenose (make sure it's powered via FREE-WILi!) idf.py -p COM12 flash # Monitor serial output idf.py -p COM12 monitor   Arduino Method:‚Äã  Select Board: Tools ‚Üí Board ‚Üí ESP32 Arduino ‚Üí ESP32C6 Dev ModuleSelect Port: Tools ‚Üí Port ‚Üí (your COM port)Configure Settings: Flash Mode: QIOFlash Size: 4MBFlash Frequency: 80MHz Upload: Click Upload button  ","version":"Next","tagName":"h3"},{"title":"Step 5: Advanced Features‚Äã","type":1,"pageTitle":"Bottlenose Getting Started Guide","url":"/extending-with-orcas/bottlenose-wifi-orca/bottlenose-getting-started/#step-5-advanced-features","content":" Communicate with FREE-WILi‚Äã  // UART communication with FREE-WILi #include &quot;driver/uart.h&quot; #define UART_FREEWILI UART_NUM_1 #define BUF_SIZE 1024 void init_freewili_uart(void) { uart_config_t uart_config = { .baud_rate = 115200, .data_bits = UART_DATA_8_BITS, .parity = UART_PARITY_DISABLE, .stop_bits = UART_STOP_BITS_1, .flow_ctrl = UART_HW_FLOWCTRL_DISABLE, }; uart_param_config(UART_FREEWILI, &amp;uart_config); uart_set_pin(UART_FREEWILI, 4, 5, UART_PIN_NO_CHANGE, UART_PIN_NO_CHANGE); uart_driver_install(UART_FREEWILI, BUF_SIZE * 2, 0, 0, NULL, 0); } void send_to_freewili(const char* data) { uart_write_bytes(UART_FREEWILI, data, strlen(data)); }   ","version":"Next","tagName":"h3"},{"title":"Programming Tips and Best Practices‚Äã","type":1,"pageTitle":"Bottlenose Getting Started Guide","url":"/extending-with-orcas/bottlenose-wifi-orca/bottlenose-getting-started/#programming-tips-and-best-practices","content":" Power Management‚Äã  // Configure power saving for battery applications #include &quot;esp_pm.h&quot; esp_pm_config_esp32c6_t pm_config = { .max_freq_mhz = 160, .min_freq_mhz = 10, .light_sleep_enable = true }; esp_pm_configure(&amp;pm_config);   Memory Optimization‚Äã  // Monitor memory usage void check_memory(void) { printf(&quot;Free heap: %d bytes\\n&quot;, esp_get_free_heap_size()); printf(&quot;Minimum free heap: %d bytes\\n&quot;, esp_get_minimum_free_heap_size()); }   Debugging with JTAG‚Äã  # Use OpenOCD for debugging openocd -f board/esp32c6-builtin.cfg # In another terminal, connect GDB xtensa-esp32c6-elf-gdb build/your-app.elf (gdb) target remote :3333 (gdb) monitor reset halt (gdb) continue   ","version":"Next","tagName":"h3"},{"title":"Troubleshooting Custom Programming‚Äã","type":1,"pageTitle":"Bottlenose Getting Started Guide","url":"/extending-with-orcas/bottlenose-wifi-orca/bottlenose-getting-started/#troubleshooting-custom-programming","content":" Common Issues:‚Äã  Problem: &quot;Device not found&quot; during flashing  Solution: Ensure Bottlenose is powered via FREE-WILiCheck: USB cable is data-capable (not just charging cable)  Problem: &quot;Boot mode not detected&quot;  Solution: Hold BOOT button on ESP32-C6 while connecting USBAlternative: Use esptool.py --before default_reset option  Problem: High power consumption  Solution: Enable power management and use sleep modesCheck: Disable unused peripherals in your code  Problem: Communication with FREE-WILi fails  Solution: Verify UART pin configuration matches hardwareCheck: Baud rate and protocol settings  ","version":"Next","tagName":"h3"},{"title":"Development Resources‚Äã","type":1,"pageTitle":"Bottlenose Getting Started Guide","url":"/extending-with-orcas/bottlenose-wifi-orca/bottlenose-getting-started/#development-resources","content":" ESP32-C6 Documentation: Espressif ESP32-C6 DocsArduino ESP32: Arduino ESP32 ReferencePlatformIO: PlatformIO ESP32 PlatformExample Code: Check the FREE-WILi GitHub repository for advanced examples  Happy coding! Your Bottlenose WiFi Orca is now ready for custom development while maintaining integration with the FREE-WILi ecosystem! üöÄ ","version":"Next","tagName":"h3"}],"options":{"indexBaseUrl":true,"id":"default"}}
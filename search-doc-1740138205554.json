{"searchDocs":[{"title":"WiLi-Party LED Minigames","type":0,"sectionRef":"#","url":"/blog/wiLi-party/","content":"","keywords":"","version":null},{"title":"Inspiration‚Äã","type":1,"pageTitle":"WiLi-Party LED Minigames","url":"/blog/wiLi-party/#inspiration","content":" We love competitive games like Mario Party and the cuteness of small devices like Tamagotchi. We wanted a project that combines the two, which is why the free wili seemed like a great system to use.  ","version":null,"tagName":"h2"},{"title":"What it does‚Äã","type":1,"pageTitle":"WiLi-Party LED Minigames","url":"/blog/wiLi-party/#what-it-does","content":" Gives users the ability to play four 1v1 games  Mashing game - Who can rack up the highest number of button presses before time runs out?Memory game - A pattern sequence, up to 3 levels of increasing difficulty. Test your memory!Counting game - Keep track of your color light and how many times it flashes. Don't blink.Reaction game - Who can react faster? Click the color that shows up as quick as you can.  The lights at the end of a game blink red if P1 has won and green if P2 (yellow if tie).  ","version":null,"tagName":"h2"},{"title":"How we built it‚Äã","type":1,"pageTitle":"WiLi-Party LED Minigames","url":"/blog/wiLi-party/#how-we-built-it","content":" We used two Python libraries. The FreeWheel API to communicate with the FREE-WILi and flash our code, and the pygame library to receive and read controller input. We also have a given header file for C++ definitions of useful functions that allow us to configure the FREE-WILi board, such as LED toggles and Display images.  ","version":null,"tagName":"h2"},{"title":"Challenges we ran into‚Äã","type":1,"pageTitle":"WiLi-Party LED Minigames","url":"/blog/wiLi-party/#challenges-we-ran-into","content":" The FREE-WILi had some hardware limitations that prevented us from fully fledging out our implementation as was planned. Primarily, its I/O capabilities are limited, and cannot read controller input through USB-C as a general purpose computer can, so we had to keep the system wired to the computer during play. We also ran into space issues in uploading images to the display, so the UI is not as in depth as we would have liked.  ","version":null,"tagName":"h2"},{"title":"Accomplishments that we're proud of‚Äã","type":1,"pageTitle":"WiLi-Party LED Minigames","url":"/blog/wiLi-party/#accomplishments-that-were-proud-of","content":" For having found out about this device only 24 hours before submission, we are very proud of the fact that we were able to flash the device with our software, turn on LEDs, upload images, and have it function properly with our controller input, despite the limitations we encountered.  ","version":null,"tagName":"h2"},{"title":"What we learned‚Äã","type":1,"pageTitle":"WiLi-Party LED Minigames","url":"/blog/wiLi-party/#what-we-learned","content":" We learned a lot about how FREE-WILi works, how to write to it, and its functionalities. We also learned how to use pygame to process user inputs from a controller, to parse and control them correctly, and also how to manage multiple controllers.  ","version":null,"tagName":"h2"},{"title":"What's next for Wili-Party‚Äã","type":1,"pageTitle":"WiLi-Party LED Minigames","url":"/blog/wiLi-party/#whats-next-for-wili-party","content":" Ideally, we would love to make the controller input work without running it through a computer for processing. We want the games to be able to be fully run on the FREE-WILi itself, with just two controllers as support. We would also like to make the communication wireless, so we are not cluttered with USB-C cables while playing.  ","version":null,"tagName":"h2"},{"title":"Built With‚Äã","type":1,"pageTitle":"WiLi-Party LED Minigames","url":"/blog/wiLi-party/#built-with","content":" c++ freewili pygame python time  Source - https://devpost.com/software/wili-party ","version":null,"tagName":"h3"},{"title":"thereMINI: Creating Music with Hand Gestures Using FREE-WILi for a Touch-Free Sound Experience","type":0,"sectionRef":"#","url":"/blog/theremini/","content":"","keywords":"","version":null},{"title":"üé∂ thereMINI: A Wearable Theremin üé∂‚Äã","type":1,"pageTitle":"thereMINI: Creating Music with Hand Gestures Using FREE-WILi for a Touch-Free Sound Experience","url":"/blog/theremini/#-theremini-a-wearable-theremin-","content":" Turning motion into music with FREE-WILi    ","version":null,"tagName":"h2"},{"title":"üåü Inspiration‚Äã","type":1,"pageTitle":"thereMINI: Creating Music with Hand Gestures Using FREE-WILi for a Touch-Free Sound Experience","url":"/blog/theremini/#-inspiration","content":" We designed this as an accessibility device for one-handed music creation but soon saw its broader potential. Inspired by conducting, we mapped hand motion to notes and volume, making music creation more intuitive and inclusive. We continue to design this as a accessible device, but it is for everyone!    ","version":null,"tagName":"h2"},{"title":"üéµ What It Does‚Äã","type":1,"pageTitle":"thereMINI: Creating Music with Hand Gestures Using FREE-WILi for a Touch-Free Sound Experience","url":"/blog/theremini/#-what-it-does","content":" Using the FREE-WILi we were able to extract the accelerometer data as serial data. Converting said data to MIDI data (a music data type) we were able to use music software, like Ableton to translate it into virtual instrument playing. Moving your hand down increases volume and putting it down increases it. Moving your hand left or right changes notes, specifically a scale of 8 notes. Combining all that we can emulate a full virtual keyboard with just the movement of your hand!    ","version":null,"tagName":"h2"},{"title":"üõ†Ô∏è How We Built It‚Äã","type":1,"pageTitle":"thereMINI: Creating Music with Hand Gestures Using FREE-WILi for a Touch-Free Sound Experience","url":"/blog/theremini/#Ô∏è-how-we-built-it","content":" Hardware: FREE-WILi device is a wearable microprocessor, outfitted with many sensors and capabilities, the one we focused on is the accelerometer. We used this mainly to translate xyz coordinates into angles, and then MIDI values for the notes and volume. This data is sent through USB serial data to be read by the software.Software: We used C++, and C to embed functionality for the FREE-WILi and python to clean and extract the data from it. loopMIDI is a software that creates a virtual MIDI controller that reads from our script, and feeds it to DAWs.Implementation: The horizontal rotation is used for the notes on a rotation of -90 -&gt; 90 degrees, and the vertical rotation is used for lowering and increasing the pitch on -30 -&gt; 30 degrees.    ","version":null,"tagName":"h2"},{"title":"üöß Challenges We Ran Into‚Äã","type":1,"pageTitle":"thereMINI: Creating Music with Hand Gestures Using FREE-WILi for a Touch-Free Sound Experience","url":"/blog/theremini/#-challenges-we-ran-into","content":" We addressed USB port access challenges between WSL and Windows, ensuring proper connectivity. Translating accelerometer data into MIDI required refining sensitivity and applying filtering to improve accuracy. By optimizing data formatting and transmission, we facilitated seamless MIDI transfer. Through continuous troubleshooting and iterative testing, we achieved smooth integration between hardware and software.    ","version":null,"tagName":"h2"},{"title":"üèÜ Accomplishments We're Proud Of‚Äã","type":1,"pageTitle":"thereMINI: Creating Music with Hand Gestures Using FREE-WILi for a Touch-Free Sound Experience","url":"/blog/theremini/#-accomplishments-were-proud-of","content":" Our project focused on turning complex tasks into key milestones. A major achievement was enabling MIDI data transfer from FREE-WILi to a computer, converting user movements into precise musical instructions like pitch and velocity. Our greatest achievement was the design of the notes and pitch to hand movements, and what was the most ergonomic and accessible way we would implement it.    ","version":null,"tagName":"h2"},{"title":"üìö What We Learned‚Äã","type":1,"pageTitle":"thereMINI: Creating Music with Hand Gestures Using FREE-WILi for a Touch-Free Sound Experience","url":"/blog/theremini/#-what-we-learned","content":" We learned how to process real-time sensor data into MIDI signals, ensuring seamless hardware-software integration. Designing for accessibility taught us the importance of intuitive and ergonomic control. Optimizing MIDI implementation required refining pitch, velocity, and minimizing latency. Through iterative problem-solving, we debugged formatting errors and fine-tuned movement sensitivity.    ","version":null,"tagName":"h2"},{"title":"üöÄ What's Next for thereMINI‚Äã","type":1,"pageTitle":"thereMINI: Creating Music with Hand Gestures Using FREE-WILi for a Touch-Free Sound Experience","url":"/blog/theremini/#-whats-next-for-theremini","content":" We plan to enhance thereMINI with scale mode, chord mode, and octave control, mapped to buttons on the FREE-WILi for seamless switching. A GUI will provide visual feedback and customization options. Beyond development, thereMINI has potential as an accessible instrument, an innovative tool for musicians, and an educational device for learning music through motion.    ","version":null,"tagName":"h2"},{"title":"Built With‚Äã","type":1,"pageTitle":"thereMINI: Creating Music with Hand Gestures Using FREE-WILi for a Touch-Free Sound Experience","url":"/blog/theremini/#built-with","content":" ableton accelerometer c c++ freewili loopmidi pyserial python rtmidi  ","version":null,"tagName":"h3"},{"title":"Try it out‚Äã","type":1,"pageTitle":"thereMINI: Creating Music with Hand Gestures Using FREE-WILi for a Touch-Free Sound Experience","url":"/blog/theremini/#try-it-out","content":"  GitHub Repo  Source - https://devpost.com/software/theremini ","version":null,"tagName":"h3"},{"title":"Buy Now from Our\n Distributor Network","type":0,"sectionRef":"#","url":"/buy-now/","content":"Buy Now from Our Distributor Network Where to Buy‚Äã Buy Now From Intrepid Control Systems, Inc. Buy Now From Amazon (US) Buy Now From Jameco","keywords":"FREE-WILi buy FREE-WILi FREE-WILi distributor purchase FREE-WILi","version":"Next"},{"title":"Extending with Orcas","type":0,"sectionRef":"#","url":"/extending-with-orcas/","content":"","keywords":"FREE-WILi Orca modules Maestro Jambu extension connector custom modules serial LED control debugger board","version":"Next"},{"title":"Custom Orca Modules‚Äã","type":1,"pageTitle":"Extending with Orcas","url":"/extending-with-orcas/#custom-orca-modules","content":" To create your own, example projects are provided. ","version":"Next","tagName":"h2"},{"title":"Custom Orca","type":0,"sectionRef":"#","url":"/extending-with-orcas/custom-orca/","content":"Custom Orca There are example projects for Orca for KiCAD and Altium Designer.","keywords":"Custom Orca KiCAD Altium Designer FREE-WILi Orca modules example projects custom design KiCAD Orca projects Altium Orca projects","version":"Next"},{"title":"WiLi Watch ‚Äì Voice-Activated Wearable for Smart Home Control","type":0,"sectionRef":"#","url":"/blog/wiLi-watch/","content":"","keywords":"","version":null},{"title":"Inspiration‚Äã","type":1,"pageTitle":"WiLi Watch ‚Äì Voice-Activated Wearable for Smart Home Control","url":"/blog/wiLi-watch/#inspiration","content":" In a world increasingly reliant on technology, the ability to interact with our surroundings effortlessly is essential, especially for individuals with mobility challenges. Enter the WiLi Watch, a wearable wristband powered by FREE-WILi and Groq aimed to empower users with independence.  The journey began with a vision: to create a device that could simplify and enhance daily living for individuals with movement impairments. Our team recognized the need for an intuitive interface that would allow users to control their smart home environment without the barriers typically posed by traditional devices. By harnessing the capabilities of the watch's built-in infrared (IR) transmitters, we sought to bridge the gap between technology and accessibility.  ","version":null,"tagName":"h2"},{"title":"What it does‚Äã","type":1,"pageTitle":"WiLi Watch ‚Äì Voice-Activated Wearable for Smart Home Control","url":"/blog/wiLi-watch/#what-it-does","content":" The user wears an embedded wristband device that can be used to control and interact with their environment. Here is the specific tasks that can be performed wirelessly from your wrist:  Turn on and off lightsLock and unlock your doorDisplay live steamed camera footage of your doorstepBring up your GCal or the weather to be displayed These tasks can either be initiated through buttons on the wristband, or from asking out loud for certain actions to be done. We use AI to predict your needs as well based on what you say. For example, if you mention &quot;Oh did I forget to lock the door?&quot; the door will lock automatically, and saying &quot;will I need an umbrella later?&quot; will cause the weather report to go on display. Additionally, a speaker announces to you every action that is done for peace of mind. Finally, one can inquire about who is at their door and the hub will describe to you your visitor.  ","version":null,"tagName":"h2"},{"title":"How we built it‚Äã","type":1,"pageTitle":"WiLi Watch ‚Äì Voice-Activated Wearable for Smart Home Control","url":"/blog/wiLi-watch/#how-we-built-it","content":" This project relies on the wireless IR communication between a FREE-WILi device and a smart home &quot;hub&quot; consisting of an Orange Pi 5 and Arduino Nano that control other peripherals such as a camera, door &quot;locking&quot; system, IR receiver module, speaker, microphone, and external monitor. The frameworks we used for development are Groq for easy LLM use (Whisper for speech to text and Llama for natural language reasoning) and Cartesia for speech-text interfacing, all developed on a python virtual environment. The project is also modular to be used with Intel's IDC if private LLM generation is desired (we setup a flask server serving llama.cpp inferencing on a compute instance but ran out of credits)  ","version":null,"tagName":"h2"},{"title":"Challenges we ran into‚Äã","type":1,"pageTitle":"WiLi Watch ‚Äì Voice-Activated Wearable for Smart Home Control","url":"/blog/wiLi-watch/#challenges-we-ran-into","content":" Using GPIO on the Orange Pi; we had to pivot after hours to integrate another microcontroller with a functional GPIO interface for motor control and IF receivingNetworking compatibility; we found out later than we'd like that the Free WiLi device which we centered our project around does not have capabilities to connect to the internet / Bluetooth so we switched to IF communicationPython development on Linux; Python virtual environments are not for the weak of heart  ","version":null,"tagName":"h2"},{"title":"Accomplishments that we're proud of‚Äã","type":1,"pageTitle":"WiLi Watch ‚Äì Voice-Activated Wearable for Smart Home Control","url":"/blog/wiLi-watch/#accomplishments-that-were-proud-of","content":" Fully functional prototype built from the ground up in 24 hours!!Door locking system on a physical prototype + doorstep cameraOvercoming Free WiLi debugging hurdles in the middle of the nightKept persistence even through sleep deprivation  ","version":null,"tagName":"h2"},{"title":"What we learned‚Äã","type":1,"pageTitle":"WiLi Watch ‚Äì Voice-Activated Wearable for Smart Home Control","url":"/blog/wiLi-watch/#what-we-learned","content":" Hardware hacking is challenging, but super fun!Cable management can and will stress you outImplementing APIs in a larger programWireless communication (IR and RF)Ideation is so important  ","version":null,"tagName":"h2"},{"title":"What's next for The WiLi Watch‚Äã","type":1,"pageTitle":"WiLi Watch ‚Äì Voice-Activated Wearable for Smart Home Control","url":"/blog/wiLi-watch/#whats-next-for-the-wili-watch","content":" Increase in functionalities available on the watch as well as real world implementation (metal instead of cardboard). A few functionalities that we came up with that could be expanded on in further development are as follows:  Autonomous robotic car assistant that can retrieve itemsInteract with kitchen appliances (turn on/off stove)Emergency response / alarm systemTemperature control  ","version":null,"tagName":"h2"},{"title":"Built With‚Äã","type":1,"pageTitle":"WiLi Watch ‚Äì Voice-Activated Wearable for Smart Home Control","url":"/blog/wiLi-watch/#built-with","content":" arduino-nano cartesia freewili groq llama orange-pi python whisper  ","version":null,"tagName":"h2"},{"title":"Try it out‚Äã","type":1,"pageTitle":"WiLi Watch ‚Äì Voice-Activated Wearable for Smart Home Control","url":"/blog/wiLi-watch/#try-it-out","content":"  GitHub Repo  Source - https://devpost.com/software/wili-watch ","version":null,"tagName":"h3"},{"title":"Project Story: Safe X Guardian","type":0,"sectionRef":"#","url":"/blog/safe-x-guardian/","content":"","keywords":"","version":null},{"title":"Built With‚Äã","type":1,"pageTitle":"Project Story: Safe X Guardian","url":"/blog/safe-x-guardian/#built-with","content":" c freewili python raspberry-pi whadda  ","version":null,"tagName":"h3"},{"title":"Try it out‚Äã","type":1,"pageTitle":"Project Story: Safe X Guardian","url":"/blog/safe-x-guardian/#try-it-out","content":"  GitHub Repo  Source - https://devpost.com/software/safe-x-guardian ","version":null,"tagName":"h3"},{"title":"DEFCON32 Badge Edition","type":0,"sectionRef":"#","url":"/defcon32-badge-edition/","content":"","keywords":"FREE-WILi DEFCON32 badge DEFCON32 badge FREE-WILi I2C control IR transmission IR reception GPIO SAO connector FREE-WILi firmware WASM scripting LED control badge development USB serial terminal RP2350 bootloader TSOP38238","version":"Next"},{"title":"Features of FREE-WILi Supported‚Äã","type":1,"pageTitle":"DEFCON32 Badge Edition","url":"/defcon32-badge-edition/#features-of-free-wili-supported","content":" The badge does not contain all hardware in FREE-WILi but it does support a significant amount:  ScreenButtonsAccelerometerLEDs, light show with up to one LED light stripIR TransmissionIR Reception with addition of one sensorI2C controlGPIO control of USER1, USER2, and SAO pinsSound board with integrated buzzerUSB Serial Console TerminalWASM Scripting with ROM images  ","version":"Next","tagName":"h2"},{"title":"Loading FREE-WILi Software‚Äã","type":1,"pageTitle":"DEFCON32 Badge Edition","url":"/defcon32-badge-edition/#loading-free-wili-software","content":" You can load the FREE-WILi uf2 by forcing the badge into the RP2350 boot loader. This is done by holding both the reset and the bootload button down and then releasing the reset. The reset and boot load buttons are on the back of back shown below.  After doing this the badge will present itself as a mass storage device (USB drive). Simple copy over the FreeWilliDefconVX.uf2 file to the drive. It will reset when it is complete flashing.  Booting new firmware into The Defcon32 badge.  ","version":"Next","tagName":"h2"},{"title":"Using The IR receive function‚Äã","type":1,"pageTitle":"DEFCON32 Badge Edition","url":"/defcon32-badge-edition/#using-the-ir-receive-function","content":" The badge has an IRDa sensor. This is not directly compatible with IR Remote devices (although IR Transmit works). To use the FREE-WILi IR features you can add an IRSensor to the SAO connector as shown below. The output of the sensor must be connected to USER 1 as shown.  Addition of an IR Sensor to the SAO connector.  The recommend and tested sensor is the TSOP38238. It is available from Digikey    TSOP38238 | DigiKey Electronics DigiKey Electronics  ","version":"Next","tagName":"h2"},{"title":"The SAO Connector‚Äã","type":1,"pageTitle":"DEFCON32 Badge Edition","url":"/defcon32-badge-edition/#the-sao-connector","content":" The badge has a SAO connector. This is a DEFCON standard IO connector for expansion. The connector has 4 GPIO of which two can be used as I2C. SAO pin in the lower left corner. Please note the I2C pins have pull up resistors. Also, the badge has 3 devices (touch screen, accel, rtc) already connected to the i2c.  The SAO pins with pin 1 in the lower left corner.  The schematic of the badge SAO connector is below.  The connections on the SAO connector.  FREE-WILi allows you to use these as i2c, PWM, IR Rx, GPIO or LED light strip control.  The GPIO view will allow you to manual control your SAO.  ","version":"Next","tagName":"h2"},{"title":"WASM Scripting‚Äã","type":1,"pageTitle":"DEFCON32 Badge Edition","url":"/defcon32-badge-edition/#wasm-scripting","content":" The FREE-WILi badge firmware does not support the touch screen or RTC devices on the badge. This is a great use for WASM scripting. You can write WASM scripts that send and received I2C data. ","version":"Next","tagName":"h2"},{"title":"FREE-WILi Firmware Update","type":0,"sectionRef":"#","url":"/freewili-firmware-update/","content":"","keywords":"FREE-WILi Firmware Update RP2040 Processor Update MAIN Processor Firmware DISPLAY Processor Firmware UF2 File Update FREE-WILi USB Bootloader Firmware Installation Guide","version":"Next"},{"title":"Updating the Main Processor‚Äã","type":1,"pageTitle":"FREE-WILi Firmware Update","url":"/freewili-firmware-update/#updating-the-main-processor","content":" Pressing and holding the RED button as USB is connected activates the RP2040 ROM bootloader. This will enable the default way to program the RP2040 via USB.  Receive or create a FREE-WILi MAIN UF2 file.Hold the RED button and plug in USB.The host computer will show FREE-WILi as a flash drive.Copy the MAIN UF2 file to the flash drive. Allow firmware to update.After the update, FREE-WILi will disconnect from USB and reconnect as a USB COM Port (normal operation).  ","version":"Next","tagName":"h2"},{"title":"Updating the Display Processor‚Äã","type":1,"pageTitle":"FREE-WILi Firmware Update","url":"/freewili-firmware-update/#updating-the-display-processor","content":" Pressing and holding the BLUE button as USB is connected activates the display processor bootloader.  Receive or create a FREE-WILi DISPLAY UF2 file.Hold the BLUE button and plug in USB.The host computer will show FREE-WILi as a flash drive.Copy the DISPLAY UF2 file to the flash drive. Allow firmware to update.After the update, FREE-WILi will disconnect from USB and reconnect as a USB COM Port (normal operation). ","version":"Next","tagName":"h2"},{"title":"Maestro Debug Orca","type":0,"sectionRef":"#","url":"/extending-with-orcas/maestro-debug-orca/","content":"","keywords":"Maestro Orca FREE-WILi USB debugger RP2040 IO test points Pico scope Logic Analyzer GPIO testing I2C SDCARD prototyping connectors","version":"Next"},{"title":"Features‚Äã","type":1,"pageTitle":"Maestro Debug Orca","url":"/extending-with-orcas/maestro-debug-orca/#features","content":" Integrated Raspberry Pi Debug Probe https://www.raspberrypi.com/documentation/microcontrollers/debug-probe.htmlPico scope Logic Analyzer Connector https://www.picotech.com/oscilloscope/2000/picoscope-2000-overviewLEDs which display IO statusSwitches to test GPIOs that are inputsPrototyping connectors for I2C (QWIIC) and SDCARDs.Jumper for selecting or injecting IO voltageConnector for plugging in additional Orca modules  ","version":"Next","tagName":"h2"},{"title":"Schematic‚Äã","type":1,"pageTitle":"Maestro Debug Orca","url":"/extending-with-orcas/maestro-debug-orca/#schematic","content":"   ","version":"Next","tagName":"h2"},{"title":"Useful tools‚Äã","type":1,"pageTitle":"Maestro Debug Orca","url":"/extending-with-orcas/maestro-debug-orca/#useful-tools","content":" Jumper wires  ELEGOO Breadbord Jumper Wires Amazon.com ","version":"Next","tagName":"h2"},{"title":"GUI : Screen, Buttons, and Lights","type":0,"sectionRef":"#","url":"/gui-screen-buttons-and-lights/","content":"GUI : Screen, Buttons, and Lights The FREE-WILi has a user interface that makes interacting with the device use-able without a host PC. The user interface is controlled by a separate CPU and interfaces with the main CPU via a 8 Megabit hardware handshaking UART. Fw Display LEDs, and buttons The core parts of the user interface are listed below: Description\tNotesColor Display\t320 x 240 16 bit color screen with GUI library\tmore information Buttons\t5 Multi color buttons\tmore information Full Color LEDs\t7 full color LEDs\tmore information Speaker\t16 bit audio\tmore information Microphone more information InfrRed Receiver\tReception of IR remote data\tmore information Infrared Transmitter\tTransmission of IR remote data\tmore information Real Time Clock\tTime and date powered from Lith ION battery\tmore information Lithium ION Battery Manager\tControls the Lith-ION battery\tmore information Accelerometer\tUsed as sensor for custom applications\tmore information","keywords":"FREE-WILi user interface color display multi-color buttons LEDs speaker microphone IR receiver IR transmitter real-time clock lithium-ion battery manager accelerometer","version":"Next"},{"title":"About App","type":0,"sectionRef":"#","url":"/gui-screen-buttons-and-lights/about-app/","content":"About App The FREE-WILi has an about app the contains screens about the device. The main about screen includes information about the version of firmware running on the main and display processors. It also includes loop times which are just an idea of how fast the FREE-WILi IO app and GUI app are running. The clr button will reset these maximum times. The about app also include screens for RTC and Battery Charging, these are described in the relative topics. The about screen includes version information, loop times and documentation links.","keywords":"FREE-WILi About App firmware version loop times device monitoring RTC battery charging FreeWili IO GUI app documentation links","version":"Next"},{"title":"Capturing Audio from Microphone","type":0,"sectionRef":"#","url":"/gui-screen-buttons-and-lights/capturing-audio-from-microphone/","content":"","keywords":"FREE-WILi microphone audio recording 8000 Hz FFT algorithm GUI API WAV file audio capture recording settings","version":"Next"},{"title":"Sensors App Microphone View‚Äã","type":1,"pageTitle":"Capturing Audio from Microphone","url":"/gui-screen-buttons-and-lights/capturing-audio-from-microphone/#sensors-app-microphone-view","content":" The sensors app has a microphone shown above. This view also you to record a wave file and play it back. The virtual LED shows if the sound quiet threshold was exceeded. Also, the LED light show indicates sound level.  ","version":"Next","tagName":"h2"},{"title":"Settings‚Äã","type":1,"pageTitle":"Capturing Audio from Microphone","url":"/gui-screen-buttons-and-lights/capturing-audio-from-microphone/#settings","content":" The recording time and volume level can be configured in the settings serial menu. This menu can also set a threshold to determine if the noise level is loud to indicate sound is present. This can be used to trigger device actions like waking up the screen. The record volume can also be set. 5 is the default volume.    ","version":"Next","tagName":"h2"},{"title":"API‚Äã","type":1,"pageTitle":"Capturing Audio from Microphone","url":"/gui-screen-buttons-and-lights/capturing-audio-from-microphone/#api","content":" You can record sounds using the API from wasm. The recordSound API allows you to record a sound to the file system for a specific length of time.  The setAudioSettings will stream the microphone or fft result to the wasm script engine as events. You can also put the mic sound level and/or fft data into a plot data store.  void recordSound(char * szSoundPath, int iLengthSeconds); void setAudioSettings(bool bStreamMic, bool bStreamFFT, bool bEnableMicPlotData, int iMICPlotDataIndex, bool bEnableFFTPlotData, int iFFTPlotDataIndex);   ","version":"Next","tagName":"h2"},{"title":"Technical Details‚Äã","type":1,"pageTitle":"Capturing Audio from Microphone","url":"/gui-screen-buttons-and-lights/capturing-audio-from-microphone/#technical-details","content":" The format of the wave file is compatible with the sound playback allowing you to play recorded sounds. ","version":"Next","tagName":"h2"},{"title":"Buttons","type":0,"sectionRef":"#","url":"/gui-screen-buttons-and-lights/buttons/","content":"","keywords":"FREE-WILi buttons button functions button API click simulation Roku Remote FWGUI events setPanelMenuText bootloader user interface controls","version":"Next"},{"title":"Button Fixed Functions‚Äã","type":1,"pageTitle":"Buttons","url":"/gui-screen-buttons-and-lights/buttons/#button-fixed-functions","content":" The gray button is hard wired to the battery controller. This will wake the device from a shutdown if held for two seconds.  The red button is hard wired to the BOOTSEL feature of the Main CPU. There on a power up this will be read to determine if the Main should stay in the bootloader.  The Blue button is used by the display to enter the boot-loader. This is done in software. So if the display processor enters bootloader it will not return to the main software until the battery is depleted or a valid UF2 file is flashed. The blue button will only enter bootloader on a long press on the main screen.  ","version":"Next","tagName":"h2"},{"title":"Roku Remote Click Simulation‚Äã","type":1,"pageTitle":"Buttons","url":"/gui-screen-buttons-and-lights/buttons/#roku-remote-click-simulation","content":" The Roku Remote can be enabled to simulate a click event on the 5 buttons. More information in the IR topic.  ","version":"Next","tagName":"h2"},{"title":"API‚Äã","type":1,"pageTitle":"Buttons","url":"/gui-screen-buttons-and-lights/buttons/#api","content":" The buttons are available though API through events. Also, you can enable a button menu through the setPanelMenuText API. Please note the panel must enable the panel menu.  // Set Menu panel text, A null string will clear it, must be enabled on panel void setPanelMenuText(int iPanel, int iButtonGreyFromZero, const char * szMessage); case FWGUI_EVENT_GRAY_BUTTON: return &quot;graybutton&quot;; case FWGUI_EVENT_YELLOW_BUTTON: return &quot;yellowbutton&quot;; case FWGUI_EVENT_GREEN_BUTTON: return &quot;greenbutton&quot;; case FWGUI_EVENT_BLUE_BUTTON: return &quot;bluebutton&quot;; case FWGUI_EVENT_RED_BUTTON: return &quot;redbutton&quot;; printf(&quot;event %s &quot;, getEventName(stEvents[iCount].iEvent)); if (stEvents[iCount].iEvent &gt;= FWGUI_EVENT_GRAY_BUTTON &amp;&amp; stEvents[iCount].iEvent &lt;= FWGUI_EVENT_RED_BUTTON) { printf(&quot;%s &quot;, getButtonData(stEvents[iCount].btData[0])); } const char * getButtonData(int iValue) { switch (iValue) { case (int)rpFWGUIButtonEvent::clicked: return &quot;clicked&quot;; case (int)rpFWGUIButtonEvent::doubleclicked: return &quot;doubleclick&quot;; case (int)rpFWGUIButtonEvent::longpress: return &quot;longpress&quot;; case (int)rpFWGUIButtonEvent::poweruppressed: return &quot;longpress&quot;; } return &quot;&quot;; }  ","version":"Next","tagName":"h2"},{"title":"GPIO","type":0,"sectionRef":"#","url":"/gpio/","content":"","keywords":"freewili free-wili FREE-WILi GPIO header pinout voltage levels I2C interface IO pins PCA9517 sn74lxc1t45 GPIO pin descriptions digital protocols","version":"Next"},{"title":"Overview‚Äã","type":1,"pageTitle":"GPIO","url":"/gpio/#overview","content":" FREE-WILi includes a GPIO pin header for interacting with digital protocols. This GPIO header is flexible, allowing varying voltage levels and IO direction. The pin-out and connector are shown below.  FREE-WILi Pinout.    FREE-WILi GPIO Header  ","version":"Next","tagName":"h2"},{"title":"IO Voltage Levels‚Äã","type":1,"pageTitle":"GPIO","url":"/gpio/#io-voltage-levels","content":" The IO voltage levels are shared by all the GPIO. To set the voltage level you must inject a voltage on PIN4. This voltage can be set to 3.3v or 5.0v with a jumper. This would be a jumper between pins 2 and 4 for 5V. Or between 4 and 6 for 3.3V.  ","version":"Next","tagName":"h2"},{"title":"GPIO Pin Descriptions‚Äã","type":1,"pageTitle":"GPIO","url":"/gpio/#gpio-pin-descriptions","content":" The table below describes the pins. All GPIO except dedicated I2C pins can be used bidirectionally depending on the application. So the directions are the default.  Pin\tDescription\tDefault Direction\tNotes1\tSPI Chip Select Out\tOutput 2\t5V Out\tOutput\t5V to power IO and external circuit 3\tGPIO27 OUT\tOutput\tRPi 2040 GPIO27 4\tV PINS IN\tInput\tInput to set the IO voltage 1.1 to 5.5V 5\tUART1 Rx IN\tInput\tRPi 2040 UART 1 Receive (GPIO9) 6\t3.3V Out\tOutput\t3.3 V to Power IO and external circuit 7\tUART1 CTS IN\tInput\tRPi 2040 UART 1 Clear To Send (GPIO10) 8\tI2C0 SCL\tIn/Out\tRPi 2040 I2C 0 Clock (GPIO17) 9\tUART1 TX OUT\tOutput\tRPi 2040 UART1 Transmit (GPIO8) 10\tI2C0 SDA\tIn/Out\tRPi I2C 0 Data (GPIO16) 11\tUART1 RTS OUT\tOutput\tRPi 2040 UART 1 Request To Send (GPIO11) 12\tSPI1 RX IN\tInput\tRPi 2040 SPI 1 Receive (GPIO12) 13\tSPI1 TX OUT\tOutput\tRPi 2050 SPI 1 Transmit (GPIO15) 14\tGPIO 26 IN\tInput\tRPi 2040 GPIO26 15\tSPI1 SCLK OUT\tOutput\tRPi 2040 SPI 1 Clock (GPIO14) 16\tSWCLK IN\tInput\tRPi 2040 debugger clock input for external SWD debugger. 17\tGPIO25 OUT\tOutput\tRPi 2040 GPIO25. GPIO25 also connects to board status LED (same as RPi Pico) 18\tSWDIO\tIn/Out\tRPi 2040 debugger IO for external SWD debugger. 19\tGND 20\tGND   ","version":"Next","tagName":"h2"},{"title":"I2C Interface‚Äã","type":1,"pageTitle":"GPIO","url":"/gpio/#i2c-interface","content":" The I2C interface is connected to the RPi I2C0 peripheral. The I2C Interface uses the chip PCA9517 for buffering. Please see the data sheet below for details.    PCA9517-3139014.pdf pdf  ","version":"Next","tagName":"h2"},{"title":"IO Pins Interface‚Äã","type":1,"pageTitle":"GPIO","url":"/gpio/#io-pins-interface","content":" All the GPIO that is not I2C uses the sn74lxc1t45 for buffering.  sn74lxc1t45.pdf pdf ","version":"Next","tagName":"h2"},{"title":"GUI API Basics","type":0,"sectionRef":"#","url":"/gui-screen-buttons-and-lights/gui-api-basics/","content":"GUI API Basics The GUI API allows you to control all of the screen from a C API. This API is a binary API but there is an integrated wrapper for wasm. This wrapper allows everything on the display processor and GUI system to be controlled. In fact this is the API that all the apps in the FREE-WILi use. The API consists of C calls which control an element of the GUI or GUI processor. There are APIs to build a panel of controls similar to GUI development on desktop OS systems. Then there are APIs which provide access to the sensors. The API uses C function calls and events. The C functions have no return values. If the C function needs to return data it is supplied via an event. The event data goes into a queue and these are read at will by an App. The API supports logging text data through a global Log. There are current 4 global logs and these can be attached to a Log/List control to display by an Index. Similiary, the plot works the same way. Data can be added to a plot global object and then the plot control can display the data.","keywords":"FREE-WILi GUI API C API wasm wrapper display control sensor access event handling global logs GUI development","version":"Next"},{"title":"Color Display Widgets","type":0,"sectionRef":"#","url":"/gui-screen-buttons-and-lights/color-display-widgets/","content":"","keywords":"FREE-WILi color display widgets API LED image widget log list plot text control number control bargraph button control properties control data","version":"Next"},{"title":"Properties for Controls‚Äã","type":1,"pageTitle":"Color Display Widgets","url":"/gui-screen-buttons-and-lights/color-display-widgets/#properties-for-controls","content":" The table below lists the APIs properties for the controls  API\tDescription\tsetControlValueMinMax\tsets min max property of control in int32 setControlValueMinMaxF\tsets min max property of control in float32 setControlProperty\tSets the a property of a control.\tNot in wasm yet setPlotData\tSets color of plot\tNot implemented in wasm yet. Sets colors of plots  ","version":"Next","tagName":"h2"},{"title":"Data for the Controls‚Äã","type":1,"pageTitle":"Color Display Widgets","url":"/gui-screen-buttons-and-lights/color-display-widgets/#data-for-the-controls","content":" The table below lists the APIs for the data in the control.  API\tDescription\tNotessetListItemText\tsets a log text when implementing list mode\tMake sure to have a valid list index setListItemSelected\tsets the selected item in the list setListItemTopIndex\tset the top item in the list clearLogOrPlotData\tclears a log or plot buffer addControlPlotData\tadds data to a plot buffer setLogDataText\tadds test to the list setControlValue\tsets the value of the control in int32 setControlValueFloat\tsets the value of teh control in float32\t ","version":"Next","tagName":"h2"},{"title":"LED Light Show","type":0,"sectionRef":"#","url":"/gui-screen-buttons-and-lights/led-light-show/","content":"","keywords":"FREE-WILI's LED light show full-color LEDs sensor effects API control light strip Roku IR remote LED patterns","version":"Next"},{"title":"Settings‚Äã","type":1,"pageTitle":"LED Light Show","url":"/gui-screen-buttons-and-lights/led-light-show/#settings","content":" The setting are show below. At startup you can pick a default light show. Also you can enable light strip control. Then you can enable a Roku IR remote to switch between the light show options.  Settings for the Light Show  ","version":"Next","tagName":"h2"},{"title":"API‚Äã","type":1,"pageTitle":"LED Light Show","url":"/gui-screen-buttons-and-lights/led-light-show/#api","content":" There are APIs to control the board LEDS below. When setBoardLED is called it will disable the light show.  You can set the LED to a static color or make it flash or fade. The setBoardLED allows you to use the LEDs this way.   // Control Manual enum fwLEDManagerLEDMode { ledsimplevalue, ledflash, ledpulse, ledflashfade, ledpulsefade, }; void setBoardLED(int iLEDIndex0_7, int iR, int iG, int iB, int iDurationMs, fwLEDManagerLEDMode iMode); // Set a Light show void setLEDShowMode(int iLEDShow);  ","version":"Next","tagName":"h2"},{"title":"Displaying Images","type":0,"sectionRef":"#","url":"/gui-screen-buttons-and-lights/displaying-images/","content":"","keywords":"FREE-WILi displaying images image display custom images API integration FWI format image conversion 565 color format ROM images image processing","version":"Next"},{"title":"Displaying Images from the ROM‚Äã","type":1,"pageTitle":"Displaying Images","url":"/gui-screen-buttons-and-lights/displaying-images/#displaying-images-from-the-rom","content":" The FREE-WILi ROM contains a number of images you can use for your own applications. The following file lists the ROM images available.    FwRomAssets.pdf pdf  ","version":"Next","tagName":"h2"},{"title":"Displaying Images from the API‚Äã","type":1,"pageTitle":"Displaying Images","url":"/gui-screen-buttons-and-lights/displaying-images/#displaying-images-from-the-api","content":" The GUIAPI has a function for displaying images from files or ROM. Here we display cookie.fwi in the images directory.  obGUIAPI.addControlPictureFromFile(iPanelNumber,PANEL_PICTURE_COOKIE,20,160,&quot;cookie&quot;,1 );  Cookie.fwi shown on FREE-WILi screen.  To Display from ROM you can use this API  void addControlPicture(int iPanelIndex, int iControlIndex, int iX, int iY, int iPictureId, int iVisible)   ","version":"Next","tagName":"h2"},{"title":"Structure of Image File‚Äã","type":1,"pageTitle":"Displaying Images","url":"/gui-screen-buttons-and-lights/displaying-images/#structure-of-image-file","content":" The file consists of a binary header describing the file and the pixels. The pixels are stored in 16 bit 565 format. The 565 16 bit color format is a common format in embedded systems. There are a number of resources online that discuss this format. The best way to understand the format is to review the source code of fw_image.py  ","version":"Next","tagName":"h2"},{"title":"Binary Header‚Äã","type":1,"pageTitle":"Displaying Images","url":"/gui-screen-buttons-and-lights/displaying-images/#binary-header","content":" The beginning of the file is below. Ints are 32 bit here and shorts are 16 bit.  char szOut[8] = { &quot;FW01IMG&quot; }; unsigned int iImageFlags; unsigned int iImageTotalPixelCount; unsigned short iImageWidth; unsigned short iImageHeight; unsigned short iImageTransparentColor; unsigned short iImageId;   ","version":"Next","tagName":"h2"},{"title":"Pixel Data‚Äã","type":1,"pageTitle":"Displaying Images","url":"/gui-screen-buttons-and-lights/displaying-images/#pixel-data","content":" The pixel data is described below. A 16 bit unsigned short contains the pixel with varying intensities for Red, Green, and Blue. The final value is byte swapped.  rgb = (int(R)&lt;&lt;11) | (int(G)&lt;&lt;5) | int(B) rgb = ((rgb &lt;&lt; 8) &amp; 0xFF00) | ((rgb &gt;&gt; 8) &amp; 0xFF); ","version":"Next","tagName":"h2"},{"title":"Sensors: Accelerometer & Temperature","type":0,"sectionRef":"#","url":"/gui-screen-buttons-and-lights/accelerometer/","content":"","keywords":"FREE-WILi accelerometer LIS3DH ST Microelectronics sensor data API integration axis orientation serial menu accelerometer data","version":"Next"},{"title":"Sensors App‚Äã","type":1,"pageTitle":"Sensors: Accelerometer & Temperature","url":"/gui-screen-buttons-and-lights/accelerometer/#sensors-app","content":" The sensors app Accel and Temperature will display accelerometer in a graphical form on the FREE-WILi screen. The top line shows the the current range, x, y ,z and temperature. If the axis broke the move threshold it will be temporarily white text. Below is a plot of the sensor. The LED will indicate x, y, z in both led position and color. This is usable anytime as a light show.    ","version":"Next","tagName":"h2"},{"title":"Sensor Settings‚Äã","type":1,"pageTitle":"Sensors: Accelerometer & Temperature","url":"/gui-screen-buttons-and-lights/accelerometer/#sensor-settings","content":" The sensor settings contain the settings for the accelerometer. This includes a range and a move threshold. The ranges supported by the Accel include 2, 4, 8, and 16. The move threshold is how much a Accel axis must change indicate FREE-WILi is moving. The moving signal can awake the screen or create events for your custom wasm scripts.  The temperature calibration allow you to tweak the default scaling of the rp chips internal temperature sensor. The calibration applies a floating point scale and offset to the default temperature scaling.    ","version":"Next","tagName":"h2"},{"title":"API Support‚Äã","type":1,"pageTitle":"Sensors: Accelerometer & Temperature","url":"/gui-screen-buttons-and-lights/accelerometer/#api-support","content":" The setSensorSettings API call will enabled the sensors to be reported at a specific rate through a GUI event. Also, it can also add the sensor value to an indicated plot data store. The event FWGUI_EVENT_GUI_SENSOR_DATA will report sensor data. The Accel and sensors can also be logged to a text log with the API setAppLogSettings below.  // FWGUI_EVENT_GUI_SENSOR_DATA if (stEvents[iCount].iEvent == FWGUI_EVENT_GUI_SENSOR_DATA) { short iX = stEvents[iCount].btData[0] | (stEvents[iCount].btData[1]&lt;&lt;8); short iY = stEvents[iCount].btData[2] | (stEvents[iCount].btData[3]&lt;&lt;8); short iZ = stEvents[iCount].btData[4] | (stEvents[iCount].btData[5]&lt;&lt;8); short iTc = stEvents[iCount].btData[6] | (stEvents[iCount].btData[7]&lt;&lt;8); short iTf = stEvents[iCount].btData[8] | (stEvents[iCount].btData[9]&lt;&lt;8); int iMoving = stEvents[iCount].btData[10] &amp; 0x1; int iMovingX = stEvents[iCount].btData[10] &amp; 0x2 ? 1 : 0; int iMovingY = stEvents[iCount].btData[10] &amp; 0x4 ? 1 : 0; int iMovingZ = stEvents[iCount].btData[10] &amp; 0x8 ? 1 : 0; printf(&quot;x %d y %d z %d T %d C T %d F moving %d moveX %d moveY %d moveZ %d&quot;,iX, iY,iZ, iTc, iTf,iMoving,iMovingX,iMovingY,iMovingZ); }    // API to enable accelerometer data void setSensorSettings(int bStreamAccel, int iRateMilliseconds, int bEnableAccelXPlotData, int iAccelXPlotDataIndex, int bEnableAccelYPlotData, int iAccelYPlotDataIndex, int bEnableAccelZPlotData, int iAccelZPlotDataIndex, int bEnableTempPlotDataC, int iTempPlotDataIndexC, int bEnableTempPlotDataF, int iTempPlotDataIndexF ); void setAppLogSettings(int bLogIRCodes, int bLogAccel, int bLogTempC, int bLogTempF, int iLogIndex);   ","version":"Next","tagName":"h2"},{"title":"Sensor Details‚Äã","type":1,"pageTitle":"Sensors: Accelerometer & Temperature","url":"/gui-screen-buttons-and-lights/accelerometer/#sensor-details","content":"   LIS3DH - STMicroelectronics STMicroelectronics    X Axis points to the IO Connector and Y points to the buttons, Z point out of the screen. ","version":"Next","tagName":"h2"},{"title":"Hardware Low Level Details","type":0,"sectionRef":"#","url":"/hardware-low-level-details/","content":"Hardware Low Level Details The hardware low level details section is provided so end users can write their own apps that run on the main RP2040 PI Pico processor and/or develop their own FPGA front end design","keywords":"FREE-WILi Hardware Details RP2040 PI Pico FPGA Front End Design Custom Hardware Apps Low-Level Hardware Development FPGA Integration","version":"Next"},{"title":"Li-ION Battery and Power Management","type":0,"sectionRef":"#","url":"/gui-screen-buttons-and-lights/li-ion-battery-and-power-management/","content":"","keywords":"FREE-WILi battery Lithium ION battery power management battery monitoring Li-ION specifications portable applications display timeout power saving settings battery status","version":"Next"},{"title":"Lithium ION Battery specifications‚Äã","type":1,"pageTitle":"Li-ION Battery and Power Management","url":"/gui-screen-buttons-and-lights/li-ion-battery-and-power-management/#lithium-ion-battery-specifications","content":" Spec\tValue\tNotesEnergy\t1000 mAh Charge Voltage\t4.2V Charge Temp\tbetween 0 and 45C Discharge Temp\tbetween -22 to 55 C Storage Temp\tbetween -10 C to 45C Charger Current Max\t1000 maH Max discharge current\t1000 mA\t  ","version":"Next","tagName":"h2"},{"title":"App‚Äã","type":1,"pageTitle":"Li-ION Battery and Power Management","url":"/gui-screen-buttons-and-lights/li-ion-battery-and-power-management/#app","content":" The About app contains a screen to monitor the Lithium battery charger. The battery voltage, supply voltage for charging, the charging current and the status are shown.  About App indicating battery charging.  The about screen showing battery discharging  ","version":"Next","tagName":"h2"},{"title":"Settings‚Äã","type":1,"pageTitle":"Li-ION Battery and Power Management","url":"/gui-screen-buttons-and-lights/li-ion-battery-and-power-management/#settings","content":" There are settings that control the power usage of FREE-WILi. This includes display brightness, display timeout, wake up sound, and wake up on move. Normally only the button presses wake the screen.  The wake up on sound will wake the display on a sound threshold while the move wakes if the device moves.  You can save power by sleeping the display when battery powered. ","version":"Next","tagName":"h2"},{"title":"iCE40 FPGA","type":0,"sectionRef":"#","url":"/hardware-low-level-details/ice40-fpga/","content":"iCE40 FPGA The FREE-WILi contains an iCE40 FPGA between the RP2040 main processor and the IO drivers. The FPGA allows sophisticated high speed IO and state machines that can process IO and communicate to the RP2040 or communicate to the host directly using high speed USB. The FPGA contains a default application so changing FPGA configuration is entirely optional. But changing the configuration is allowed and can be done at anytime and an unlimited number of times. See FPGA Programming for details. The FPGA is connected to a high speed FTDI USB interface and an 8Mbyte Serial SRAM. The block diagram is shown below. The part numbers associated with the FPGA IO system are below: Part\tPart Number\tNotesFTDI USB\tFT232HQ\tOperates in FT1248 mode. https://ftdichip.com/products/ft232hq/ Serial SRAM 8 MByte\tAPS6404L-3SQR-ZR\thttps://www.apmemory.com FPGA\tICE40UP5K-SG48I\thttps://www.latticesemi.com/en/Products/FPGAandCPLD/iCE40UltraPlus","keywords":"iCE40 FPGA FREE-WILi FPGA Overview FTDI USB FT232HQ Serial SRAM APS6404L FPGA Configuration RP2040 FPGA Integration High-Speed IO FPGA","version":"Next"},{"title":"FPGA Connections","type":0,"sectionRef":"#","url":"/hardware-low-level-details/ice40-fpga/fpga-connections/","content":"FPGA Connections The FPGA connects to the Serial SRAM, IO Drivers, and the RP2040. The FPGA development tools including Open Source (yosys, nextpnr, icestorm) and commercial (icecube2) support a pin constraints file that defines how the pins connect to the HDL (verilog/vhdl) connections. This is included below: The PCF file is a text file you can view in a text editor. In the file you will see the names that end with Rp or Out. The Rp names connect to the RP2040 and the Out connects to the IO driver. set_io SPI_MISO_Rp 14 set_io SPI_MISO_Out 25 fw.pcf","keywords":"FPGA Connections iCE40 FPGA Pin Constraints RP2040 FPGA Serial SRAM FPGA IO Drivers FPGA PCF File FPGA Development Tools yosys nextpnr icestorm icecube2","version":"Next"},{"title":"IR Infrared Devices","type":0,"sectionRef":"#","url":"/gui-screen-buttons-and-lights/ir-infrared-devices/","content":"","keywords":"FREE-WILi IR devices infrared receiver infrared transmitter IR control NEC protocol custom remote Roku remote IR Hacker app IR API remote learning","version":"Next"},{"title":"Roku Remote Control of FREE-WILi‚Äã","type":1,"pageTitle":"IR Infrared Devices","url":"/gui-screen-buttons-and-lights/ir-infrared-devices/#roku-remote-control-of-free-wili","content":" You can enable the Roku remote to control FREE-WILi. This works by receiving the codes and simluating the actual button presses.  Roku Button\tFree Wili Action\tNotesup\tGray Button press down\tYellow Button Press ok/select\tGreen Button Press left\tBlue Button Press right\tRed Button Press home\tReturns to main screen\t  ","version":"Next","tagName":"h2"},{"title":"Settings‚Äã","type":1,"pageTitle":"IR Infrared Devices","url":"/gui-screen-buttons-and-lights/ir-infrared-devices/#settings","content":" There is one setting for IR. This is to use the Roku Remote as a remote control. This can be enabled or disabled.  ","version":"Next","tagName":"h2"},{"title":"API‚Äã","type":1,"pageTitle":"IR Infrared Devices","url":"/gui-screen-buttons-and-lights/ir-infrared-devices/#api","content":" There is an API for sending IR codes in NEC format. Also any IR Recived will be sent as an Event.   // Send IR Data void sendIRData(unsigned int iData); // IR Event Decoding if (stEvents[iCount].iEvent == FWGUI_EVENT_IR_CODE) { unsigned int iIRCode; iIRCode = stEvents[iCount].btData[0]; iIRCode |= ((unsigned int)stEvents[iCount].btData[1]) &lt;&lt; 8; iIRCode |= ((unsigned int)stEvents[iCount].btData[2]) &lt;&lt; 16; iIRCode |= ((unsigned int)stEvents[iCount].btData[3]) &lt;&lt; 24; printf(&quot;%x &quot;,iIRCode); }  ","version":"Next","tagName":"h2"},{"title":"FPGA Clock","type":0,"sectionRef":"#","url":"/hardware-low-level-details/ice40-fpga/fpga-clock/","content":"FPGA Clock The clock signal to the FPGA is supplied by the main RP2040. This is done on GPIO23 using the Clock Generator feature. The clock generated can be generated from numerous clock sources with a integer and fractional divider. For example, the default sys clock of 125 mhz can be used or divided down. Please see the rp2040 data sheet for details. The Intrepid IO app has a device setting where you can select the FPGA clock source and divider. The default setting is sys clock (125Mhz) divided by 4 (31.25 Mhz) .","keywords":"FPGA Clock Configuration RP2040 FPGA Clock Signal Clock Generator Feature iCE40 FPGA Clock Source Intrepid IO App FPGA Settings FPGA Clock Divider","version":"Next"},{"title":"Making sounds","type":0,"sectionRef":"#","url":"/gui-screen-buttons-and-lights/making-sounds/","content":"","keywords":"FREE-WILi sound playback WAV files API calls playSoundFromFile playSoundFromNameOrID playSoundFromNumber Audacity ROM sounds WAV file sources","version":"Next"},{"title":"App‚Äã","type":1,"pageTitle":"Making sounds","url":"/gui-screen-buttons-and-lights/making-sounds/#app","content":" The Sound board app allows you to play select ROM sounds and sounds from the file system.  The sound board app lets you test sounds.  ","version":"Next","tagName":"h2"},{"title":"API Calls for sounds‚Äã","type":1,"pageTitle":"Making sounds","url":"/gui-screen-buttons-and-lights/making-sounds/#api-calls-for-sounds","content":" void playSoundFromFile(char * szSoundPath); void playSoundFromNameOrID(const char * szSoundName, int iID); void playSoundFromNumber(bool bFloat, int iNumber, float fNumber, int iFloatDigits);   ","version":"Next","tagName":"h2"},{"title":"ROM Sounds‚Äã","type":1,"pageTitle":"Making sounds","url":"/gui-screen-buttons-and-lights/making-sounds/#rom-sounds","content":" FREE-WILi includes sounds in its ROM. Below is a list of ROM sounds.    FwROMAudioAssets.pdf pdf  ","version":"Next","tagName":"h2"},{"title":"Software to edit and create proper wav files‚Äã","type":1,"pageTitle":"Making sounds","url":"/gui-screen-buttons-and-lights/making-sounds/#software-to-edit-and-create-proper-wav-files","content":" Home Audacity ¬Æ    Audacity can export an 8000 hz 16 bit PCM wav file  ","version":"Next","tagName":"h2"},{"title":"Source for wav files‚Äã","type":1,"pageTitle":"Making sounds","url":"/gui-screen-buttons-and-lights/making-sounds/#source-for-wav-files","content":" WavSource.com: Free Wav Files and Sound Bites ","version":"Next","tagName":"h2"},{"title":"Helpful Links","type":0,"sectionRef":"#","url":"/helpful-links/","content":"Helpful Links C/C++ Installer for RP2040 Open Processor Raspberry Pi Pico Windows Installer - Raspberry Pi Raspberry Pi Texas Instruments Sub Ghz Help Forums Sub-1 GHz forum - Sub-1 GHz - TI E2E support forums Shawn Hymel's FPGA Tutorials using ice40 and open source tools GitHub - ShawnHymel/introduction-to-fpga Github More info on WebAssembly WebAssembly","keywords":"RP2040 Installer Raspberry Pi Pico Installer Sub-GHz Help Forums Texas Instruments FPGA Tutorials iCE40 FPGA Open Source FPGA Tools WebAssembly Resources","version":"Next"},{"title":"FPGA Programming","type":0,"sectionRef":"#","url":"/hardware-low-level-details/ice40-fpga/fpga-programming/","content":"FPGA Programming The ice40 FPGA is a SRAM configured FPGA that is programmed automatically at power up. By default the ice40 reads a default configuration from its OTP memory. This default image allows basic pass through configuration of the RP2040 gpio to the IO drivers. Because of the SRAM configuration, the FPGA can be reprogrammed unlimted times at anytime by the RP2040 chip. To do this the RP2040 uses the the FPGA DONE, FPGA RESET and SPI interface from the RP2040. The ice40 documentation calls this the &quot;SPI Slave Configuration Interface&quot;. This method of programming is described in the Lattice ICE40 document &quot;iCE40 Programming and Configuration&quot; with document number FPGA-TN-02001. When reprogramming the FPGA the bit file would be fed from the RP2040. An obvious place to store the bit file is RP2040 flash as a const byte array. The Intrepid IO app can store multiple FPGA bit files in its file system and load them on command or at startup. It can also load them directly from USB.","keywords":"iCE40 FPGA Programming FPGA SRAM Configuration RP2040 FPGA Reprogramming SPI Slave Configuration Interface Intrepid IO App FPGA Management FPGA Bit Files Storage","version":"Next"},{"title":"IO App","type":0,"sectionRef":"#","url":"/io-app/","content":"IO App FREE-WILi includes an IO app that allows you to read and write all the IO of FREE-WILi. This app has a Serial Command Line Interface, support for a host API, on-board scripting, and a file system for stand-alone operations without a host. The serial command line interface provides a menu tree of commands to control FREE-WILi's IO interfaces. This is shown below: FREE-WILi's Serial Command Line Interface Main Menu To use a command, press a letter and the enter key. Then follow the instructions. The serial API is simply sending these menu commands and the data they expect. Below is a simple Python API that sets a GPIO high or low using the &quot;h&quot; and &quot;l&quot; commands. In API mode you can disable the menu text with by sending CTRL-B or reenable the menu text with CTRL-C. On board scripting uses web assembly technology. The code uses the WASM 3 engine with custom APIs to control FREE-WILi's interfaces. With this you can compile C/C++ or Rust source code to run on FREE-WILi with our without the host. The recommend Clang based wasi sdk is recommend https://github.com/WebAssembly/wasi-sdk. C/C++ program using WASI SDK and CLion. Finally, the file system provides a way to load scripts or run them at startup, load custom FPGA bit files, and store settings. This is shown below. Note getting files on the FREE-WILi uses the &quot;Download File&quot; command. The Filesystem menu provides interaction with file system.","keywords":"FREE-WILi IO app Serial Command Line Interface Python API WASM scripting File System GPIO control FREE-WILi scripting web assembly Clang wasi sdk FREE-WILi file management","version":"Next"},{"title":"Learn UART","type":0,"sectionRef":"#","url":"/helpful-links/learn-uart/","content":"","keywords":"UART Introduction RP2040 UART Tutorial UART Communication RP2040 Video Guide UART Deep Dive","version":"Next"},{"title":"Watch this introduction video:‚Äã","type":1,"pageTitle":"Learn UART","url":"/helpful-links/learn-uart/#watch-this-introduction-video","content":"           ","version":"Next","tagName":"h3"},{"title":"Do a deep dive with the rp2040 UART‚Äã","type":1,"pageTitle":"Learn UART","url":"/helpful-links/learn-uart/#do-a-deep-dive-with-the-rp2040-uart","content":"  ","version":"Next","tagName":"h3"},{"title":"Host USB Serial API","type":0,"sectionRef":"#","url":"/io-app/host-usb-serial-api/","content":"","keywords":"FREE-WILi USB serial API control FREE-WILi via USB USB serial port commands FREE-WILi command line interface toggle menu text Linux Windows Raspberry Pi control","version":"Next"},{"title":"App‚Äã","type":1,"pageTitle":"Host USB Serial API","url":"/io-app/host-usb-serial-api/#app","content":" FREE-WILi includes a terminal app that allows you do everything from the USB serial terminal. You can add text input clicking the input button. The gray button allows you to switch between the main and display CPU terminal.  The Terminal app allows you to use the serial terminal on the device. ","version":"Next","tagName":"h2"},{"title":"File System Menu","type":0,"sectionRef":"#","url":"/io-app/file-system-menu/","content":"File System Menu The File System Menu allows you to interact with the file menu (shown below). Command\tDescription\tNotesChange Directory\tChanges the current directory Create Directory\tCreates a directory in the current directory Remove File or Directory Download File\tSend a file from the host to FREE-WILi device Upload File\tCopy a file from FREE-WILi to host device Print File\tDisplay file to the serial terminal Create Blank File\tCreates an empty file Rename File or Directory Append to File ","keywords":"FREE-WILi File System Menu file management commands create directory remove file download file upload file print file rename file append to file","version":"Next"},{"title":"FPGA Default Application","type":0,"sectionRef":"#","url":"/hardware-low-level-details/ice40-fpga/fpga-default-application/","content":"FPGA Default Application The default FPGA application is a simple design that transforms the FREE-WILi into a sigrok-compatible logic analyzer. The design features an IO buffer that can set the directions of the SPI and UART pins as well as GPIO_26 and GPIO27. To enable this programming, the IO_CONFIG_ENABLE pin must be asserted - this allows the FPGA's SPI-Slave to assume control of the SPI interface with the main RP2040 as the master. The pin direction defaults are as specified in GPIO. Please note that the pin directionality is also dependent on the sn74lxc1t45 hardware IO buffers between the FPGA and breakout pins. For the logic analyzer, the FPGA samples the SPI pins at the clock frequency provided by the main RP2040 - this design expects a frequency of 31.25 MHz. The samples are encoded via Run-Length Encoding and, once the FPGA is initiated by sigrok via FTDI, stored in a 32 kB FIFO built using the iCE40's on-chip SPRAM. Finally, these samples are sent via the FT1248 4-wire communication protocol to USB where sigrok can collect them. The libsigrok fork where the FREE-WILi hardware driver was developed can be found at libsigrok-fwili. The translation from the sigrok channel name to the corresponding pin for SPI protocol is detailed below. sigrok channel name\tSPI4\tCS 3\tSCLK 2\tMOSI 1\tMISO","keywords":"FPGA Default Application FREE-WILi Logic Analyzer Sigrok-Compatible FPGA SPI Configuration iCE40 FPGA FTDI Communication Run-Length Encoding libsigrok-fwili","version":"Next"},{"title":"RTC Real Time Clock","type":0,"sectionRef":"#","url":"/gui-screen-buttons-and-lights/rtc-real-time-clock/","content":"","keywords":"FREE-WILi RTC MCP7940N real time clock RTC API file timestamping RTC settings RTC events Lithium ION battery RTC trim setting setRTC getRTC","version":"Next"},{"title":"App‚Äã","type":1,"pageTitle":"RTC Real Time Clock","url":"/gui-screen-buttons-and-lights/rtc-real-time-clock/#app","content":" The about app will display the current RTC. The current time is shown as well as the time FREE-WILi started.  About App Screen  ","version":"Next","tagName":"h2"},{"title":"Settings‚Äã","type":1,"pageTitle":"RTC Real Time Clock","url":"/gui-screen-buttons-and-lights/rtc-real-time-clock/#settings","content":" The RTC is currently set from the main USB serial interface (this will be supported in both CPUs in the future).  The settings include a trim setting. This setting is loaded into the MCP7940N Trim (OSCTRIM) register. Please see the data sheet below for an explanation of this value.  The settings allow you to set the RTC values.  ","version":"Next","tagName":"h2"},{"title":"API‚Äã","type":1,"pageTitle":"RTC Real Time Clock","url":"/gui-screen-buttons-and-lights/rtc-real-time-clock/#api","content":" The API supports querying and setting the RTC. The setRTC allows you to set the current time. The getRTC causes the RTC to be read and provided via an event.  // set the RTC IC (Monday is 1 and 7 is Sunday (0 is invalid)) void setRTC(int iRTCHour, int iRTCMin, int iRTCSec, int iRTCWkDay, int iDay, int iRTCMth, int iRTCYear, int iTrim); // request the current RTC via an event void getRTC(); // RTC Event Response if (stEvents[iCount].iEvent == FWGUI_EVENT_GUI_RTC_RESPONSE) { //iRTCHour, int iRTCMin, int iRTCSec, int iRTCWkDay,int iRTCDay, int iRTCMth,int iRTCYear printf(&quot;%d:%d:%d day %d of month %d of year %d weekday %d trim %d&quot;, stEvents[iCount].btData[0], stEvents[iCount].btData[1], stEvents[iCount].btData[2], stEvents[iCount].btData[4], stEvents[iCount].btData[5], stEvents[iCount].btData[6], stEvents[iCount].btData[3], stEvents[iCount].btData[7] ); }   ","version":"Next","tagName":"h2"},{"title":"Hardware Details‚Äã","type":1,"pageTitle":"RTC Real Time Clock","url":"/gui-screen-buttons-and-lights/rtc-real-time-clock/#hardware-details","content":" The MCP7940N IC is used to implement the RTC. The data sheet is below. The RTC is always powered from the Lithium ION battery. When FREE-WILi shuts down the battery will continue to supply power (about 1 micro amp) to the RTC until the battery is physically exhausted. At that point the RTC value will be lost.    MCP7940N ","version":"Next","tagName":"h2"},{"title":"Main Menu Header","type":0,"sectionRef":"#","url":"/io-app/main-menu-header/","content":"Main Menu Header At the top of the main menu there is information on the setup and state of the FREE-WILi IOs. The IO state shows the PIN states and configuration of the UART, SPI, I2C and GPIOs. It also shows the FPGA clock and if UART streaming is enabled. After the IO state the file system contents are shown for the current directory. Finally the current real time clock setting is shown. The top of the main menu has information about the FREE-WILi configuration.","keywords":"FREE-WILi main menu IO state UART configuration SPI settings I2C setup GPIO status FPGA clock file system display real-time clock FREE-WILi configuration","version":"Next"},{"title":"Logic Analyzer","type":0,"sectionRef":"#","url":"/io-app/logic-analyzer/","content":"Logic Analyzer The default FPGA configuration implements a Logic Analyzer compatible with Sigrok Pulseview. This logic analyzer uses the FPGA front end and communicates with the PC using the FTDI High speed user interface. The Logic Analyzer operates transparently to the IO features of FREE-WILi so you can use it to test when you are interfacing to digital protocols. The FPGA bit files for the logic analyzer are always being implemented and are open source. These are available at the FREE-WILi github. You can change the default FPGA bit file in the settings of FREE-WILi. Analyze your digital protocols without attaching wires","keywords":"FREE-WILi Logic Analyzer FPGA Logic Analyzer Sigrok PulseView digital protocol analysis FPGA bit files FREE-WILi settings FTDI High-speed user interface","version":"Next"},{"title":"Main Menu Commands","type":0,"sectionRef":"#","url":"/io-app/main-menu-commands/","content":"Main Menu Commands Commands are a single letter. After you enter the letter additonal information is entered. The following command are available from the main menu: Command\tDescription\tArguments\tNotesh\tset io high\tgpio number l\tset io low\tgpio number o\tgenerate pwm\tgpio number, frequency, and duty cycle g\tget all io Returns the state of all 32 IO of the FREE-WILi processor in hex s\tread/write spi\tthe spi write bytes\tReturns the read bytes in hex t\twrite radio\tthe radio index, and data in hex k\tread radio\tthe radio index and count of read\tReturns the data read i\twrite i2c\tdevice address, register, and additional write bytes r\tread i2c\tdevice address, register and read length\tReturns the data read p\tpoll i2c Returns a table of i2c address that responded to a read u\twrite uart\twrite bytes in hex y\tstream uart toggles on and off of sending uart data to host w\trun script\tname of script in file system m\tload fpga from file\tname of fpga bit file in file systems d\tdownload fpga\tfpga bit file bytes\tsend raw FPGA bits after this command. This has a 10 second timeout. x\tfiles Access the files menu z\tsettings Access the settings menu The Main Menu access the core FREE-WILi Features.","keywords":"FREE-WILi main menu commands GPIO control PWM generation SPI read/write I2C communication UART streaming FPGA loading script execution FREE-WILi commands overview","version":"Next"},{"title":"FPGA Settings","type":0,"sectionRef":"#","url":"/io-app/settings-menu/fpga-settings/","content":"FPGA Settings The FPGA settings are shown below: Name\tDescription\tNotesClock Source\tThis is the internal clock used to generate the FPGA Clock\tThere are 4 options: the main PLL generated clock 125 Mhz, the 12 Mhz source oscillator, the 48 Mhz USB clock, and the internal 48khz RC analog clock Clock divider (int)\tThe integer part of the divider applied to the clock source Clock divider (frac)\tThe fractional part of clock divider The FPGA settings.","keywords":"FREE-WILi FPGA Settings FPGA Clock Source FPGA Clock Divider FPGA Configuration Clock Source Options FPGA Performance Tuning","version":"Next"},{"title":"RTC Settings","type":0,"sectionRef":"#","url":"/io-app/settings-menu/rtc-settings/","content":"RTC Settings The RTC settings allows you to configure the real time clock. See this topic for more information.","keywords":"","version":"Next"},{"title":"Radios","type":0,"sectionRef":"#","url":"/radios/","content":"Radios FREE-WILi has two radios integrate to help develop, validate and test radio systems. The different FREE-WILi devices have different radios to support different applications. Device\tDescription\tNotesblack\tCC1101 Sub GHZ red In development purple In development","keywords":"FREE-WILi CC1101 radios Sub-GHz radio systems radio development radio testing","version":"Next"},{"title":"Scripting with ZoomIO","type":0,"sectionRef":"#","url":"/io-app/scripting-with-zoomio/","content":"Scripting with ZoomIO ZoomIO is a scripting language that allows sub nanosecond precision control of the GPIO. Its very high level but produces native ARM assembly in the correct way to ensure design time determinism. To achieve precise determinism, native code runs in the second CPU core of the rp2040 and takes advantage of single cycle IO and the zero latency CPUs dedicated scratch 4K RAM. The IOApp integrates the ZoomIO compiler. You can simply write the source file and download to the scripts directory. The FREE-WILi will determine which engine to target based on the file extension. The ZoomIO source files have the extension zio. The code below illustrates a simple ZoomIO program. The pin is generating a waveform on pin 27 with nanosecond control of the waveform. setio(27, 1); delay(2000); setio(27, 0); delay(1000); setio(27, 1); delay(2000); setio(27, 0); The ZoomIO commands are executed in a sequence. The following commands are currently supported. Command\tArguments\tNotessetio\t(arg 1) Io pin (arg2) state delay\t(arg1) delay in ns\t32 bit value. Delay precision is based of the CPU clock (default is 125Mhz or 8ns)","keywords":"FREE-WILi ZoomIO scripting sub-nanosecond GPIO control ZoomIO commands ARM assembly for GPIO FREE-WILi IOApp integration ZoomIO examples precision waveform generation","version":"Next"},{"title":"Settings Menu","type":0,"sectionRef":"#","url":"/io-app/settings-menu/","content":"","keywords":"FREE-WILi Settings Menu SPI Configuration I2C Settings UART Configuration FPGA Clock Settings GPIO Directions RTC Configuration Default Script Default FPGA Save Startup Settings","version":"Next"},{"title":"Menu Options‚Äã","type":1,"pageTitle":"Settings Menu","url":"/io-app/settings-menu/#menu-options","content":" The menu options are shown below.  Name\tDescription\tNotesSPI\tConfigures SPI Baud rate, Bit Modes, Bit Width\tmore information I2C\tConfigures I2C bit rate and pull ups\tmore information UART\tConfigures UART Bit Rate, hand shaking, stop bits, and parity\tmore information FPGA Clock\tConfigures the input clock to the FPGA\tmore information Radio 1\tConfigures the CC1101 Radio 1 Radio 2\tConfigures the CC1101 Radio 1 GPIO Directions\tSets up directions of GPIO\tmore information RTC\tConfigures the real-time clock (RTC)\tmore information Default Script\tAllows a script to run on power up Default FPGA\tAllows a FPGA to configured at startup Save settings as Startup\tSaves current settings to &quot;settings.txt&quot; in root filesystem\t  ","version":"Next","tagName":"h2"},{"title":"Settings‚Äã","type":1,"pageTitle":"Settings Menu","url":"/io-app/settings-menu/#settings","content":" Settings are updated when you exit the settings menu.  The settings can be stored as a file when the &quot;r&quot; menu item is selected. This will store the settings so they will be loaded on startup.  These are stored in the file system under the filename &quot;settings.txt&quot;. ","version":"Next","tagName":"h2"},{"title":"GPIO Settings","type":0,"sectionRef":"#","url":"/io-app/settings-menu/gpio-settings/","content":"GPIO Settings","keywords":"","version":"Next"},{"title":"UART Settings","type":0,"sectionRef":"#","url":"/io-app/settings-menu/uart-settings/","content":"UART Settings The UART Settings are listed below. The default is 115200 baud 8 data bits, no parity bit, and one stop bit ( 8N1 ): Learn more about UART here. Name\tDescription\tNotesFrequency\tUART Baud Rate RTS Handshaking\tHardware handshaking CTS Handshaking\tHardware handshaking Data Bits\tBits per UART frame Parity\tChecksum bit per frame Stop Bits\tBits at end of frame Module The UART settings.","keywords":"FREE-WILi UART Settings UART Baud Rate UART Handshaking Data Bits UART UART Parity UART Stop Bits UART Configuration","version":"Next"},{"title":"Black Radio (CC1101)","type":0,"sectionRef":"#","url":"/radios/black-radio-cc1101/","content":"Black Radio (CC1101) The FREE-WILi contains two CC1101 packet radios from Texas Instruments. The CC1101 radio has many settings to configure the radio and integrated packet processor. More information about the capabilities of the CC1101 radio can be found in the data sheet CC1101","keywords":"FREE-WILi Black Radio CC1101 Texas Instruments packet radio radio configuration integrated packet processor radio capabilities CC1101 datasheet","version":"Next"},{"title":"I2C settings","type":0,"sectionRef":"#","url":"/io-app/settings-menu/i2c-settings/","content":"I2C settings The I2C Settings are listed below: Name\tDescription\tNotesFrequency\tBit rate of I2C bus\tLimited to 400Khz. PullUps\tEnable or disable 10K pull ups to VIO\tDefaulted to On","keywords":"FREE-WILi I2C Settings I2C Frequency I2C Bit Rate Pull-Up Resistors I2C Configuration I2C Bus Settings","version":"Next"},{"title":"SPI Settings","type":0,"sectionRef":"#","url":"/io-app/settings-menu/spi-settings/","content":"SPI Settings SPI settings are listed below. The settings are configured using the menu shown below. Setting\tDescription\tNotesFrequency\tSPI Clock Frequency Chip Select Pin\tGPIO used for Chip select.\tGPIO must be configured for output. Data bits\tThe width of the spi bytes\t(only 8 is currently supported) CPOL\tclock polarity\tRefer to RP2040 data sheet section 4.10 on clock phase and polarity. Most common is 0,0. CPHA\tclock phase SPI has 5 settings","keywords":"FREE-WILi SPI Settings SPI Frequency Chip Select Pin Data Bits CPOL CPHA SPI Configuration RP2040 SPI Settings","version":"Next"},{"title":"CC1101 Radio Settings","type":0,"sectionRef":"#","url":"/radios/black-radio-cc1101/cc1101-radio-settings/","content":"CC1101 Radio Settings The radio settings are shown below. The settings closely follow the ELECHOUSE CC1101 Ardunio driver from here: https://github.com/simonmonk/CC1101_arduino/blob/master/ELECHOUSE_CC1101.h Radio Settings.","keywords":"CC1101 radio settings FREE-WILi ELECHOUSE Arduino driver radio configuration CC1101 settings radio configuration guide packet radio","version":"Next"},{"title":"FREE-WILi Overview","type":0,"sectionRef":"#","url":"/","content":"","keywords":"freewili freewili documentation free-wili documentation FREE-WILi free-wili embedded systems development tool electronic systems debugging testing I2C SPI UART","version":"Next"},{"title":"Overview‚Äã","type":1,"pageTitle":"FREE-WILi Overview","url":"/#overview","content":" FREE-WILi Overview  FREE-WILi is a embedded development tool for helping test, debug, and develop electronic systems.  ","version":"Next","tagName":"h2"},{"title":"Use Cases‚Äã","type":1,"pageTitle":"FREE-WILi Overview","url":"/#use-cases","content":" I2C USB interfaceSPI USB interfaceUART USB interfaceGeneric Digital Protocol development (script protocol)USB attached screen and buttons Uart based protocol tool supportTPMS fuzzer or simulatorKeyless Entry simulator/monitorCybersecurity penetration testingDevelopment platform that 80% doneLearning platform for Embedded Systems CPU, FPGA or Hybrid  ","version":"Next","tagName":"h2"},{"title":"Software Features‚Äã","type":1,"pageTitle":"FREE-WILi Overview","url":"/#software-features","content":" USB Serial console API to control from host PC without installing any softwareWASM (webassembly) scripting engine with examples for C/C++, Rust, Zig and Tiny GoHost API Python softwareFAT File systemSigrok Pulse view Logic Analyzer supporthost binary API for Graphical User InterfaceWASM API to control all device featuresZoomIO scripting engine controls IO pins with nanosecond precisionGUI Software with custom panels and graphical controlsIntegrated sounds and images in ROM for enhancing user appsNumbers To Speech feature to speak numbersFile formats compatible with existing market devicesStandard USB boot-loader for firmware updatesRaspberry Pi Pico (RP2040) Open Micro Platform for specific applications or custom code with C/C++, Micro-python or Circuit PythonOpen source github software for updates  ","version":"Next","tagName":"h2"},{"title":"Hardware Features‚Äã","type":1,"pageTitle":"FREE-WILi Overview","url":"/#hardware-features","content":" SPI, I2C, PIO, and UART available on GPIO3 USB interfaces (Integrated HUB with 2 FS, 1 HS) for communication and power11 GPIO programmable voltage level for 1.1 to 5.5V with 24ma@3V or 32ma @5v (sn74lxc1t45)2 GPIO for I2C voltage level between 0.9V to 5.5V with software enabled 10K pulls (PCA9517)GPIO front end includes ICE40UP5k FPGA with 8MByte SRAM and High Speed USB (FT232H)Two SMA connectors for antenna for longer range320 x 240 Color Display5 User configurable buttons7 Full color LEDsIR transmitter and receiverDigital Speaker and Microphone Orca modules plug into GPIO header allows expansion for specific use cases 16 Mbyte x 2 on board storage (22 MByte usable)1000 ma Lithium ION battery with integrated chargerReal Time Clock (RTC)Accelerometer  ","version":"Next","tagName":"h2"},{"title":"Radio Versions‚Äã","type":1,"pageTitle":"FREE-WILi Overview","url":"/#radio-versions","content":" FREE-WILi contains two radios.  FREE-WILi currently has one radio option:  Black contains two CC1101 Sub Ghz Radios with programmable filter ranges for 300-348, 387-464, 779-928 bands. ","version":"Next","tagName":"h2"},{"title":"The Basics","type":0,"sectionRef":"#","url":"/the-basics/","content":"","keywords":"FREE-WILi device operation USB interfaces FPGA IO App GUI App firmware update USB boot loader hardware guide FREE-WILi USB ports","version":"Next"},{"title":"Turning FREE-WILi On or Off‚Äã","type":1,"pageTitle":"The Basics","url":"/the-basics/#turning-free-wili-on-or-off","content":" You can turn FREE-WILi on by pressing the gray button or by connecting it to USB. You can turn FREE-WILi off by holding the red button for 5 seconds. Note when connected to USB FREE-WILi remains on.  ","version":"Next","tagName":"h2"},{"title":"Using the USB interfaces‚Äã","type":1,"pageTitle":"The Basics","url":"/the-basics/#using-the-usb-interfaces","content":" When you plug FREE-WILi into a host, it will present 3 USB serial ports. One port connects to the FREE-WILi FPGA, One port connects to the IO App, and the last port connects to the GUI App processor.  ","version":"Next","tagName":"h2"},{"title":"Updating Firmware‚Äã","type":1,"pageTitle":"The Basics","url":"/the-basics/#updating-firmware","content":" The FREE-WILi has an integrated USB boot loader to update firmware. Please see this topic. ","version":"Next","tagName":"h2"},{"title":"Scripting with WASM","type":0,"sectionRef":"#","url":"/io-app/scripting-with-wasm/","content":"","keywords":"FREE-WILi WebAssembly scripting WASM setup FREE-WILi scripting compile WASM script FREE-WILi execution WASI SDK Visual Studio Code WASM WebAssembly for FREE-WILi","version":"Next"},{"title":"Introduction to WebAssembly (WASM)‚Äã","type":1,"pageTitle":"Scripting with WASM","url":"/io-app/scripting-with-wasm/#introduction-to-webassembly-wasm","content":" WebAssembly (WASM) technology allows a program compiler to target a generic CPU architecture. The program that runs the compiled code is called a WebAssembly runtime. This technology is included in the IO app. Please note that WebAssembly has nothing to do with the Web; it is simply named after the origin of the technology.  Example wasm projects are available from the FREE-WILi Github:    GitHub - freewili/freewili-python: Python applications for FREE-WiLi GitHub    Users can compile programs, store them in the FREE-WILi file system, and execute them either on demand or at power-up.  FREE-WILi uses the WASM3 runtime: WASM3 on GitHub.  ","version":"Next","tagName":"h2"},{"title":"APIs and Implementation‚Äã","type":1,"pageTitle":"Scripting with WASM","url":"/io-app/scripting-with-wasm/#apis-and-implementation","content":" The FREE-WILi IO app implements APIs to control FREE-WILi and provides them to the runtime. These APIs are defined in a header file called fwwasm.h.  ","version":"Next","tagName":"h2"},{"title":"Recommended Toolset‚Äã","type":1,"pageTitle":"Scripting with WASM","url":"/io-app/scripting-with-wasm/#recommended-toolset","content":" The recommended toolset to compile for FREE-WILi WASM is the WASI SDK.  For a development IDE, we recommend using Visual Studio Code or CLion.  ","version":"Next","tagName":"h2"},{"title":"Execution‚Äã","type":1,"pageTitle":"Scripting with WASM","url":"/io-app/scripting-with-wasm/#execution","content":" After compiling your script to WebAssembly (extension .wasm), you must upload the file to the FREE-WILi filesystem. The best way to do this is with the freewili Python library, as will be explained under Getting Started below.  After your script is uploaded to the FREE-WILi, you can have it run on startup. The script will execute every time FREE-WILi is powered on. Alternatively, you can start WASM files on demand from the serial menu, or you can start them using the freewili Python library.    Getting Started  There are a lot of different WebAssembly compilers; you can write your code in Rust, Python, C/C++, and several others.  The following example will use the wasi-sdk, which comes with a clang-based C/C++ compiler.  ","version":"Next","tagName":"h2"},{"title":"Installing the SDK‚Äã","type":1,"pageTitle":"Scripting with WASM","url":"/io-app/scripting-with-wasm/#installing-the-sdk","content":" ","version":"Next","tagName":"h2"},{"title":"Windows 10 and Windows 11‚Äã","type":1,"pageTitle":"Scripting with WASM","url":"/io-app/scripting-with-wasm/#windows-10-and-windows-11","content":" There are issues with using the WASI-SDK Windows binaries in Windows 11. Therefore, we recommend installing and using Windows Subsystem for Linux provided by Microsoft.  Install WSL with the following command in Command Prompt or PowerShell wsl --install After installation, open the WSL app and follow the installation prompt. (You can search for WSL in Window's search bar, or you can select it in the Windows Terminal)Once WSL has successfully installed, follow the Ubuntu Linux setup and build instructions  ","version":"Next","tagName":"h3"},{"title":"Ubuntu Linux‚Äã","type":1,"pageTitle":"Scripting with WASM","url":"/io-app/scripting-with-wasm/#ubuntu-linux","content":" In Ubuntu Linux, the quickest way to get up and running is to download the .deb prebuilt package from Github under Releases. For Ubuntu Linux on an x86-based machine, grab the Debian package (.deb) file for x86. In this example, the file is wasi-sdk-24.0-x86_64-linux.deb.  Download the package with: sudo wget https://github.com/WebAssembly/wasi-sdk/releases/download/wasi-sdk-24/wasi-sdk-24.0-x86_64-linux.deb Then, install the package with: sudo dpkg --install wasi-sdk-24.0-x86_64-linux.deb After installation, the compiler will be located here: /opt/wasi-sdk/bin/wasm32-wasi-clang++ If you want, you could set an alias to the wasm clang compiler with the following command: alias wasm32-wasi-clang++='/opt/wasi-sdk/bin/wasm32-wasi-clang++'   ","version":"Next","tagName":"h3"},{"title":"Writing a Script‚Äã","type":1,"pageTitle":"Scripting with WASM","url":"/io-app/scripting-with-wasm/#writing-a-script","content":" Use VS Code or a text editor, and write your script. For this example, we will use C++ and write a simple script to turn each of the board LEDs a different color.  Make sure you have the fwwasm.h header fileCopy and paste this example script below into your text editor, and save it as leds.cpp  #include &quot;fwwasm.h&quot; #define MAX_LOOPS 20 #define NUM_LEDS 7 #define DELAY_MS 50 #define LED_FADE_DURATION 300 //different color RGB values #define RED 0xFF0000 #define PINK 0xFFC6FF #define ORANGE 0xFF7F00 #define YELLOW 0xFFFF00 #define GREEN 0x00FF00 #define LIGHT_GREEN 0xCAFFBF #define BLUE 0x0000FF #define LIGHT_BLUE 0x9BF6FF #define INDIGO 0x4B0082 #define VIOLET 0x9400D3 #define MAX_COLORS 10 //some macros to get color RGB components #define GET_RED(x) ((x &gt;&gt; 16) &amp; 0xFF) #define GET_GREEN(x) ((x &gt;&gt; 8) &amp; 0xFF) #define GET_BLUE(x) (x &amp; 0xFF) int main() { int rainbow[MAX_COLORS] = {RED, ORANGE, YELLOW, GREEN, LIGHT_GREEN, BLUE, LIGHT_BLUE, INDIGO, VIOLET, PINK}; int color_choice = 0; //do the whole thing multiple times for (int loops = 0; loops &lt; MAX_LOOPS; loops++) { //set every LED one at a time for (int led = 0; led &lt; NUM_LEDS; led++) { //pick a color int color = rainbow[color_choice]; //set the LED setBoardLED(led, GET_RED(color), GET_GREEN(color), GET_BLUE(color), LED_FADE_DURATION, LEDManagerLEDMode::ledpulsefade); //next time, get a new color. If we used all of the colors, start over color_choice++; if (color_choice &gt;= MAX_COLORS) color_choice = 0; //wait before setting the next LED waitms(DELAY_MS); } } return 0; }   ","version":"Next","tagName":"h2"},{"title":"Compiling the Script‚Äã","type":1,"pageTitle":"Scripting with WASM","url":"/io-app/scripting-with-wasm/#compiling-the-script","content":" At the command line, run the following:  ","version":"Next","tagName":"h2"},{"title":"Ubuntu Linux Terminal‚Äã","type":1,"pageTitle":"Scripting with WASM","url":"/io-app/scripting-with-wasm/#ubuntu-linux-terminal","content":" /opt/wasi-sdk/bin/wasm32-wasi-clang++ -O3 -s leds.cpp -o leds.wasm   Note the -s argument is critical to force the linker to strip debugging symbols from the output binary.  After a successful compilation, the compiler should output a binary called leds.wasm. This is your FREE-WILi WASM script, and you will need to upload this binary to the FREE-WILi.  ","version":"Next","tagName":"h3"},{"title":"Uploading the Script‚Äã","type":1,"pageTitle":"Scripting with WASM","url":"/io-app/scripting-with-wasm/#uploading-the-script","content":" Note: If you are using WSL in Windows, you may need to copy over the LEDs.wasm from your Linux file system to Windows file system to upload the script. Install the freewili Python library with: pip install freewili Note: the freewili library requires Python 3.11 or newer. Upload your script with: fwi-serial -s leds.wasm -fn /scripts/leds.wasm   ","version":"Next","tagName":"h2"},{"title":"Executing the Script‚Äã","type":1,"pageTitle":"Scripting with WASM","url":"/io-app/scripting-with-wasm/#executing-the-script","content":" Once the script is on the FREE-WILi's file system, there are multiple ways it can be executed:  From the FREE-WILi interface, you can select &quot;Scripts&quot; and select your script to execute it.From the command line, you use the FREE-WILi Python Library with the command below to execute the script: fwi-serial -w leds.wasm From the serial terminal interface, you can select w to run a script, then type leds.wasm and hit enter  ","version":"Next","tagName":"h2"},{"title":"Common Issues Targeting FREE-WILi (Troubleshooting)‚Äã","type":1,"pageTitle":"Scripting with WASM","url":"/io-app/scripting-with-wasm/#common-issues-targeting-free-wili-troubleshooting","content":" Many tools compile binaries that use too many memory pages. FREE-WILi only supports 2 (128Kb). Ensure that the stack size of your binary is limited in this way. Please see the FREE-WILi Wasm Examples for the necessary command line switches.  A good tool for troubleshooting WASM files is the WebAssembly Explorer.  WebAssembly Code Explorer    Visual Studio Code Configuration  Assuming you installed the SDK as described above, you can get Visual Studio code to recognize your WASI-SDK as follows:  Install the CMake extension for VS Code, as well as the CMake Tools extensionhereCreate a file called CMakeLists.txt and place it in the root of your projectCopy and paste the following into the CMakeLists.txt  cmake_minimum_required(VERSION 3.0) project(wasm_project) set(CMAKE_EXE_LINKER_FLAGS &quot;${CMAKE_EXE_LINKER_FLAGS} -s&quot;) add_executable(leds.wasm &quot;leds.cpp&quot;)   Create a file called CMakePresets.json and place it in the root of your projectCopy and paste the following into the CMakePresets.json  ","version":"Next","tagName":"h2"},{"title":"Ubuntu Linux‚Äã","type":1,"pageTitle":"Scripting with WASM","url":"/io-app/scripting-with-wasm/#ubuntu-linux-1","content":" { &quot;version&quot;: 3, &quot;cmakeMinimumRequired&quot;: { &quot;major&quot;: 3, &quot;minor&quot;: 16, &quot;patch&quot;: 0 }, &quot;configurePresets&quot;: [ { &quot;name&quot;: &quot;default&quot;, &quot;hidden&quot;: true, &quot;generator&quot;: &quot;Ninja&quot; }, { &quot;name&quot;: &quot;wasi&quot;, &quot;description&quot;: &quot;Configure for WASI using wasi-sdk&quot;, &quot;inherits&quot;: &quot;default&quot;, &quot;toolchainFile&quot;: &quot;/opt/wasi-sdk/share/cmake/wasi-sdk.cmake&quot;, &quot;cacheVariables&quot;: { &quot;CMAKE_BUILD_TYPE&quot;: &quot;Release&quot; } } ] }   Use CTRL-SHIFT-P in Visual Studio code and select &quot;CMake: Select Configure Preset&quot;. Select 'wasi` from the dropdown that appears. (Note: You may need to reload VS Code for this option to appear.)You can now use the build button in Visual Studio Code to build your WASM project with one click.  Alternatively, you can run the following CMake commands in Visual Studio Code  Inside the VSCode command Palette run the following commands: &gt;CMake: Select Variant and select MinSizeRel&gt;CMake: Configure&gt;CMake: Build Target&gt;CMake: Select A Kit Make sure the kit is unspecified.  Next Steps  Look at our FWWasm Submodule for supported FREE-WILi WASM APIs. You can use this module in your projects.  There are several WASM examples written in different languages in the FREE-WILi WASM Example repo  Examples of programming languages that FREE-WILi WASM supports can be found below:  CXXRustGoZig ","version":"Next","tagName":"h2"}],"options":{"indexBaseUrl":true,"id":"default"}}